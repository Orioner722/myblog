"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/colorjs.io";
exports.ids = ["vendor-chunks/colorjs.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/colorjs.io/dist/color.js":
/*!***********************************************!*\
  !*** ./node_modules/colorjs.io/dist/color.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Color)\n/* harmony export */ });\n// A is m x n. B is n x p. product is m x p.\nfunction multiplyMatrices (A, B) {\n\tlet m = A.length;\n\n\tif (!Array.isArray(A[0])) {\n\t\t// A is vector, convert to [[a, b, c, ...]]\n\t\tA = [A];\n\t}\n\n\tif (!Array.isArray(B[0])) {\n\t\t// B is vector, convert to [[a], [b], [c], ...]]\n\t\tB = B.map(x => [x]);\n\t}\n\n\tlet p = B[0].length;\n\tlet B_cols = B[0].map((_, i) => B.map(x => x[i])); // transpose B\n\tlet product = A.map(row => B_cols.map(col => {\n\t\tlet ret = 0;\n\n\t\tif (!Array.isArray(row)) {\n\t\t\tfor (let c of col) {\n\t\t\t\tret += row * c;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (let i=0; i < row.length; i++) {\n\t\t\tret += row[i] * (col[i] || 0);\n\t\t}\n\n\t\treturn ret;\n\t}));\n\n\tif (m === 1) {\n\t\tproduct = product[0]; // Avoid [[a, b, c, ...]]\n\t}\n\n\tif (p === 1) {\n\t\treturn product.map(x => x[0]); // Avoid [[a], [b], [c], ...]]\n\t}\n\n\treturn product;\n}\n\n/**\n * Various utility functions\n */\n\n\n/**\n * Check if a value is a string (including a String object)\n * @param {*} str - Value to check\n * @returns {boolean}\n */\nfunction isString (str) {\n\treturn type(str) === \"string\";\n}\n\n/**\n * Determine the internal JavaScript [[Class]] of an object.\n * @param {*} o - Value to check\n * @returns {string}\n */\nfunction type (o) {\n\tlet str = Object.prototype.toString.call(o);\n\n\treturn (str.match(/^\\[object\\s+(.*?)\\]$/)[1] || \"\").toLowerCase();\n}\n\n/**\n * Round a number to a certain number of significant digits\n * @param {number} n - The number to round\n * @param {number} precision - Number of significant digits\n */\nfunction toPrecision (n, precision) {\n\tn = +n;\n\tprecision = +precision;\n\tlet integerLength = (Math.floor(n) + \"\").length;\n\n\tif (precision > integerLength) {\n\t\treturn +n.toFixed(precision - integerLength);\n\t}\n\telse {\n\t\tlet p10 = 10 ** (integerLength - precision);\n\t\treturn Math.round(n / p10) * p10;\n\t}\n}\n\n/**\n* Parse a CSS function, regardless of its name and arguments\n* @param String str String to parse\n* @return {{name, args, rawArgs}}\n*/\nfunction parseFunction (str) {\n\tif (!str) {\n\t\treturn;\n\t}\n\n\tstr = str.trim();\n\n\tconst isFunctionRegex = /^([a-z]+)\\((.+?)\\)$/i;\n\tconst isNumberRegex = /^-?[\\d.]+$/;\n\tlet parts = str.match(isFunctionRegex);\n\n\tif (parts) {\n\t\t// It is a function, parse args\n\t\tlet args = [];\n\t\tparts[2].replace(/\\/?\\s*([-\\w.]+(?:%|deg)?)/g, ($0, arg) => {\n\t\t\tif (/%$/.test(arg)) {\n\t\t\t\t// Convert percentages to 0-1 numbers\n\t\t\t\targ = new Number(arg.slice(0, -1) / 100);\n\t\t\t\targ.type = \"<percentage>\";\n\t\t\t}\n\t\t\telse if (/deg$/.test(arg)) {\n\t\t\t\t// Drop deg from degrees and convert to number\n\t\t\t\t// TODO handle other units too\n\t\t\t\targ = new Number(+arg.slice(0, -3));\n\t\t\t\targ.type = \"<angle>\";\n\t\t\t\targ.unit = \"deg\";\n\t\t\t}\n\t\t\telse if (isNumberRegex.test(arg)) {\n\t\t\t\t// Convert numerical args to numbers\n\t\t\t\targ = new Number(arg);\n\t\t\t\targ.type = \"<number>\";\n\t\t\t}\n\n\t\t\tif ($0.startsWith(\"/\")) {\n\t\t\t\t// It's alpha\n\t\t\t\targ = arg instanceof Number? arg : new Number(arg);\n\t\t\t\targ.alpha = true;\n\t\t\t}\n\n\t\t\targs.push(arg);\n\t\t});\n\n\t\treturn {\n\t\t\tname: parts[1].toLowerCase(),\n\t\t\trawName: parts[1],\n\t\t\trawArgs: parts[2],\n\t\t\t// An argument could be (as of css-color-4):\n\t\t\t// a number, percentage, degrees (hue), ident (in color())\n\t\t\targs\n\t\t};\n\t}\n}\n\nfunction last (arr) {\n\treturn arr[arr.length - 1];\n}\n\nfunction interpolate (start, end, p) {\n\tif (isNaN(start)) {\n\t\treturn end;\n\t}\n\n\tif (isNaN(end)) {\n\t\treturn start;\n\t}\n\n\treturn start + (end - start) * p;\n}\n\nfunction interpolateInv (start, end, value) {\n\treturn (value - start) / (end - start);\n}\n\nfunction mapRange (from, to, value) {\n\treturn interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));\n}\n\nfunction parseCoordGrammar (coordGrammars) {\n\treturn coordGrammars.map(coordGrammar => {\n\t\treturn coordGrammar.split(\"|\").map(type => {\n\t\t\ttype = type.trim();\n\t\t\tlet range = type.match(/^(<[a-z]+>)\\[(-?[.\\d]+),\\s*(-?[.\\d]+)\\]?$/);\n\n\t\t\tif (range) {\n\t\t\t\tlet ret = new String(range[1]);\n\t\t\t\tret.range = [+range[2], +range[3]];\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn type;\n\t\t});\n\t});\n}\n\nvar util = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tinterpolate: interpolate,\n\tinterpolateInv: interpolateInv,\n\tisString: isString,\n\tlast: last,\n\tmapRange: mapRange,\n\tmultiplyMatrices: multiplyMatrices,\n\tparseCoordGrammar: parseCoordGrammar,\n\tparseFunction: parseFunction,\n\ttoPrecision: toPrecision,\n\ttype: type\n});\n\n/**\n * A class for adding deep extensibility to any piece of JS code\n */\nclass Hooks {\n\tadd (name, callback, first) {\n\t\tif (typeof arguments[0] != \"string\") {\n\t\t\t// Multiple hooks\n\t\t\tfor (var name in arguments[0]) {\n\t\t\t\tthis.add(name, arguments[0][name], arguments[1]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t(Array.isArray(name)? name : [name]).forEach(function (name) {\n\t\t\tthis[name] = this[name] || [];\n\n\t\t\tif (callback) {\n\t\t\t\tthis[name][first? \"unshift\" : \"push\"](callback);\n\t\t\t}\n\t\t}, this);\n\t}\n\n\trun (name, env) {\n\t\tthis[name] = this[name] || [];\n\t\tthis[name].forEach(function (callback) {\n\t\t\tcallback.call(env && env.context? env.context : env, env);\n\t\t});\n\t}\n}\n/**\n * The instance of {@link Hooks} used throughout Color.js\n */\nconst hooks = new Hooks();\n\n// Global defaults one may want to configure\n\nvar defaults = {\n\tgamut_mapping: \"lch.c\",\n\tprecision: 5,\n\tdeltaE: \"76\", // Default deltaE method\n};\n\nconst WHITES = {\n\t// for compatibility, the four-digit chromaticity-derived ones everyone else uses\n\tD50: [0.3457 / 0.3585, 1.00000, (1.0 - 0.3457 - 0.3585) / 0.3585],\n\tD65: [0.3127 / 0.3290, 1.00000, (1.0 - 0.3127 - 0.3290) / 0.3290],\n};\n\nfunction getWhite (name) {\n\tif (Array.isArray(name)) {\n\t\treturn name;\n\t}\n\n\treturn WHITES[name];\n}\n\n// Adapt XYZ from white point W1 to W2\nfunction adapt$1 (W1, W2, XYZ, options = {}) {\n\tW1 = getWhite(W1);\n\tW2 = getWhite(W2);\n\n\tif (!W1 || !W2) {\n\t\tthrow new TypeError(`Missing white point to convert ${!W1? \"from\" : \"\"}${!W1&&!W2? \"/\" : \"\"}${!W2? \"to\" : \"\"}`);\n\t}\n\n\tif (W1 === W2) {\n\t\t// Same whitepoints, no conversion needed\n\t\treturn XYZ;\n\t}\n\n\tlet env = {W1, W2, XYZ, options};\n\n\thooks.run(\"chromatic-adaptation-start\", env);\n\n\tif (!env.M) {\n\t\tif (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {\n\t\t\tenv.M = [\n\t\t\t\t[  1.0479298208405488,    0.022946793341019088,  -0.05019222954313557 ],\n\t\t\t\t[  0.029627815688159344,  0.990434484573249,     -0.01707382502938514 ],\n\t\t\t\t[ -0.009243058152591178,  0.015055144896577895,   0.7518742899580008  ]\n\t\t\t];\n\t\t}\n\t\telse if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {\n\n\t\t\tenv.M = [\n\t\t\t\t[  0.9554734527042182,   -0.023098536874261423,  0.0632593086610217   ],\n\t\t\t\t[ -0.028369706963208136,  1.0099954580058226,    0.021041398966943008 ],\n\t\t\t\t[  0.012314001688319899, -0.020507696433477912,  1.3303659366080753   ]\n\t\t\t];\n\t\t}\n\t}\n\n\thooks.run(\"chromatic-adaptation-end\", env);\n\n\tif (env.M) {\n\t\treturn multiplyMatrices(env.M, env.XYZ);\n\t}\n\telse {\n\t\tthrow new TypeError(\"Only Bradford CAT with white points D50 and D65 supported for now.\");\n\t}\n}\n\nconst ε$4 = .000075;\n\n/**\n * Class to represent a color space\n */\nclass ColorSpace {\n\tconstructor (options) {\n\t\tthis.id = options.id;\n\t\tthis.name = options.name;\n\t\tthis.base = options.base ? ColorSpace.get(options.base) : null;\n\t\tthis.aliases = options.aliases;\n\n\t\tif (this.base) {\n\t\t\tthis.fromBase = options.fromBase;\n\t\t\tthis.toBase = options.toBase;\n\t\t}\n\n\t\t// Coordinate metadata\n\n\t\tlet coords = options.coords ?? this.base.coords;\n\n\t\tfor (let name in coords) {\n\t\t\tif (!(\"name\" in coords[name])) {\n\t\t\t\tcoords[name].name = name;\n\t\t\t}\n\t\t}\n\t\tthis.coords = coords;\n\n\t\t// White point\n\n\t\tlet white = options.white ?? this.base.white ?? \"D65\";\n\t\tthis.white = getWhite(white);\n\n\t\t// Sort out formats\n\n\t\tthis.formats = options.formats ?? {};\n\n\t\tfor (let name in this.formats) {\n\t\t\tlet format = this.formats[name];\n\t\t\tformat.type ||= \"function\";\n\t\t\tformat.name ||= name;\n\t\t}\n\n\t\tif (options.cssId && !this.formats.functions?.color) {\n\t\t\tthis.formats.color = { id: options.cssId };\n\t\t\tObject.defineProperty(this, \"cssId\", {value: options.cssId});\n\t\t}\n\t\telse if (this.formats?.color && !this.formats?.color.id) {\n\t\t\tthis.formats.color.id = this.id;\n\t\t}\n\n\t\t// Other stuff\n\t\tthis.referred = options.referred;\n\n\t\t// Compute ancestors and store them, since they will never change\n\t\tObject.defineProperty(this, \"path\", {\n\t\t\tvalue: getPath(this).reverse(),\n\t\t\twritable: false,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t});\n\n\t\thooks.run(\"colorspace-init-end\", this);\n\t}\n\n\tinGamut (coords, {epsilon = ε$4} = {}) {\n\t\tif (this.isPolar) {\n\t\t\t// Do not check gamut through polar coordinates\n\t\t\tcoords = this.toBase(coords);\n\n\t\t\treturn this.base.inGamut(coords, {epsilon});\n\t\t}\n\n\t\tlet coordMeta = Object.values(this.coords);\n\n\t\treturn coords.every((c, i) => {\n\t\t\tlet meta = coordMeta[i];\n\n\t\t\tif (meta.type !== \"angle\" && meta.range) {\n\t\t\t\tif (Number.isNaN(c)) {\n\t\t\t\t\t// NaN is always in gamut\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tlet [min, max] = meta.range;\n\t\t\t\treturn (min === undefined || c >= min - epsilon)\n\t\t\t\t    && (max === undefined || c <= max + epsilon);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\tget cssId () {\n\t\treturn this.formats.functions?.color?.id || this.id;\n\t}\n\n\tget isPolar () {\n\t\tfor (let id in this.coords) {\n\t\t\tif (this.coords[id].type === \"angle\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetFormat (format) {\n\t\tif (typeof format === \"object\") {\n\t\t\tformat = processFormat(format, this);\n\t\t\treturn format;\n\t\t}\n\n\t\tlet ret;\n\t\tif (format === \"default\") {\n\t\t\t// Get first format\n\t\t\tret = Object.values(this.formats)[0];\n\t\t}\n\t\telse {\n\t\t\tret = this.formats[format];\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret = processFormat(ret, this);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// We cannot rely on simple === because then ColorSpace objects cannot be proxied\n\tequals (space) {\n\t\tif (!space) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this === space || this.id === space.id;\n\t}\n\n\tto (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\t[space, coords] = [space.space, space.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (this.equals(space)) {\n\t\t\t// Same space, no change needed\n\t\t\treturn coords;\n\t\t}\n\n\t\t// Convert NaN to 0, which seems to be valid in every coordinate of every color space\n\t\tcoords = coords.map(c => Number.isNaN(c)? 0 : c);\n\n\t\t// Find connection space = lowest common ancestor in the base tree\n\t\tlet myPath = this.path;\n\t\tlet otherPath = space.path;\n\n\t\tlet connectionSpace, connectionSpaceIndex;\n\n\t\tfor (let i=0; i < myPath.length; i++) {\n\t\t\tif (myPath[i].equals(otherPath[i])) {\n\t\t\t\tconnectionSpace = myPath[i];\n\t\t\t\tconnectionSpaceIndex = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!connectionSpace) {\n\t\t\t// This should never happen\n\t\t\tthrow new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);\n\t\t}\n\n\t\t// Go up from current space to connection space\n\t\tfor (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {\n\t\t\tcoords = myPath[i].toBase(coords);\n\t\t}\n\n\t\t// Go down from connection space to target space\n\t\tfor (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {\n\t\t\tcoords = otherPath[i].fromBase(coords);\n\t\t}\n\n\t\treturn coords;\n\t}\n\n\tfrom (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\t[space, coords] = [space.space, space.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\treturn space.to(this, coords);\n\t}\n\n\ttoString () {\n\t\treturn `${this.name} (${this.id})`;\n\t}\n\n\tgetMinCoords () {\n\t\tlet ret = [];\n\n\t\tfor (let id in this.coords) {\n\t\t\tlet meta = this.coords[id];\n\t\t\tlet range = meta.range || meta.refRange;\n\t\t\tret.push(range?.min ?? 0);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic registry = {};\n\n\t// Returns array of unique color spaces\n\tstatic get all () {\n\t\treturn [...new Set(Object.values(ColorSpace.registry))];\n\t}\n\n\tstatic register (id, space) {\n\t\tif (arguments.length === 1) {\n\t\t\tspace = arguments[0];\n\t\t\tid = space.id;\n\t\t}\n\n\t\tspace = this.get(space);\n\n\t\tif (this.registry[id] && this.registry[id] !== space) {\n\t\t\tthrow new Error(`Duplicate color space registration: '${id}'`);\n\t\t}\n\t\tthis.registry[id] = space;\n\n\t\t// Register aliases when called without an explicit ID.\n\t\tif (arguments.length === 1 && space.aliases) {\n\t\t\tfor (let alias of space.aliases) {\n\t\t\t\tthis.register(alias, space);\n\t\t\t}\n\t\t}\n\n\t\treturn space;\n\t}\n\n\t/**\n\t * Lookup ColorSpace object by name\n\t * @param {ColorSpace | string} name\n\t */\n\tstatic get (space, ...alternatives) {\n\t\tif (!space || space instanceof ColorSpace) {\n\t\t\treturn space;\n\t\t}\n\n\t\tlet argType = type(space);\n\n\t\tif (argType === \"string\") {\n\t\t\t// It's a color space id\n\t\t\tlet ret = ColorSpace.registry[space.toLowerCase()];\n\n\t\t\tif (!ret) {\n\t\t\t\tthrow new TypeError(`No color space found with id = \"${space}\"`);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (alternatives.length) {\n\t\t\treturn ColorSpace.get(...alternatives);\n\t\t}\n\n\t\tthrow new TypeError(`${space} is not a valid color space`);\n\t}\n\n\t/**\n\t * Get metadata about a coordinate of a color space\n\t *\n\t * @static\n\t * @param {Array | string} ref\n\t * @param {ColorSpace | string} [workingSpace]\n\t * @return {Object}\n\t */\n\tstatic resolveCoord (ref, workingSpace) {\n\t\tlet coordType = type(ref);\n\t\tlet space, coord;\n\n\t\tif (coordType === \"string\") {\n\t\t\tif (ref.includes(\".\")) {\n\t\t\t\t// Absolute coordinate\n\t\t\t\t[space, coord] = ref.split(\".\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Relative coordinate\n\t\t\t\t[space, coord] = [, ref];\n\t\t\t}\n\t\t}\n\t\telse if (Array.isArray(ref)) {\n\t\t\t[space, coord] = ref;\n\t\t}\n\t\telse {\n\t\t\t// Object\n\t\t\tspace = ref.space;\n\t\t\tcoord = ref.coordId;\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (!space) {\n\t\t\tspace = workingSpace;\n\t\t}\n\n\t\tif (!space) {\n\t\t\tthrow new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);\n\t\t}\n\n\t\tcoordType = type(coord);\n\n\t\tif (coordType === \"number\" || coordType === \"string\" && coord >= 0) {\n\t\t\t// Resolve numerical coord\n\t\t\tlet meta = Object.entries(space.coords)[coord];\n\n\t\t\tif (meta) {\n\t\t\t\treturn {space, id: meta[0], index: coord, ...meta[1]};\n\t\t\t}\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tlet normalizedCoord = coord.toLowerCase();\n\n\t\tlet i = 0;\n\t\tfor (let id in space.coords) {\n\t\t\tlet meta = space.coords[id];\n\n\t\t\tif (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {\n\t\t\t\treturn {space, id, index: i, ...meta};\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tthrow new TypeError(`No \"${coord}\" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(\", \")}`);\n\t}\n\n\tstatic DEFAULT_FORMAT = {\n\t\ttype: \"functions\",\n\t\tname: \"color\",\n\t};\n}\n\nfunction getPath (space) {\n\tlet ret = [space];\n\n\tfor (let s = space; s = s.base;) {\n\t\tret.push(s);\n\t}\n\n\treturn ret;\n}\n\nfunction processFormat (format, {coords} = {}) {\n\tif (format.coords && !format.coordGrammar) {\n\t\tformat.type ||= \"function\";\n\t\tformat.name ||= \"color\";\n\n\t\t// Format has not been processed\n\t\tformat.coordGrammar = parseCoordGrammar(format.coords);\n\n\t\tlet coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {\n\t\t\t// Preferred format for each coord is the first one\n\t\t\tlet outputType = format.coordGrammar[i][0];\n\n\t\t\tlet fromRange = coordMeta.range || coordMeta.refRange;\n\t\t\tlet toRange = outputType.range, suffix = \"\";\n\n\t\t\t// Non-strict equals intentional since outputType could be a string object\n\t\t\tif (outputType == \"<percentage>\") {\n\t\t\t\ttoRange = [0, 100];\n\t\t\t\tsuffix = \"%\";\n\t\t\t}\n\t\t\telse if (outputType == \"<angle>\") {\n\t\t\t\tsuffix = \"deg\";\n\t\t\t}\n\n\t\t\treturn  {fromRange, toRange, suffix};\n\t\t});\n\n\t\tformat.serializeCoords = (coords, precision) => {\n\t\t\treturn coords.map((c, i) => {\n\t\t\t\tlet {fromRange, toRange, suffix} = coordFormats[i];\n\n\t\t\t\tif (fromRange && toRange) {\n\t\t\t\t\tc = mapRange(fromRange, toRange, c);\n\t\t\t\t}\n\n\t\t\t\tc = toPrecision(c, precision);\n\n\t\t\t\tif (suffix) {\n\t\t\t\t\tc += suffix;\n\t\t\t\t}\n\n\t\t\t\treturn c;\n\t\t\t});\n\t\t};\n\t}\n\n\treturn format;\n}\n\nvar XYZ_D65 = new ColorSpace({\n\tid: \"xyz-d65\",\n\tname: \"XYZ D65\",\n\tcoords: {\n\t\tx: {name: \"X\"},\n\t\ty: {name: \"Y\"},\n\t\tz: {name: \"Z\"},\n\t},\n\twhite: \"D65\",\n\tformats: {\n\t\tcolor: {\n\t\t\tids: [\"xyz-d65\", \"xyz\"],\n\t\t}\n\t},\n\taliases: [\"xyz\"],\n});\n\n/**\n * Convenience class for RGB color spaces\n * @extends {ColorSpace}\n */\nclass RGBColorSpace extends ColorSpace {\n\t/**\n\t * Creates a new RGB ColorSpace.\n\t * If coords are not specified, they will use the default RGB coords.\n\t * Instead of `fromBase()` and `toBase()` functions,\n\t * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.\n\t * @param {*} options - Same options as {@link ColorSpace} plus:\n\t * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ\n\t * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ\n\t */\n\tconstructor (options) {\n\t\tif (!options.coords) {\n\t\t\toptions.coords = {\n\t\t\t\tr: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Red\"\n\t\t\t\t},\n\t\t\t\tg: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Green\"\n\t\t\t\t},\n\t\t\t\tb: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Blue\"\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tif (!options.base) {\n\t\t\toptions.base = XYZ_D65;\n\t\t}\n\n\t\tif (options.toXYZ_M && options.fromXYZ_M) {\n\t\t\toptions.toBase ??= rgb => {\n\t\t\t\tlet xyz = multiplyMatrices(options.toXYZ_M, rgb);\n\n\t\t\t\tif (this.white !== this.base.white) {\n\t\t\t\t\t// Perform chromatic adaptation\n\t\t\t\t\txyz = adapt$1(this.white, this.base.white, xyz);\n\t\t\t\t}\n\n\t\t\t\treturn xyz;\n\t\t\t};\n\n\t\t\toptions.fromBase ??= xyz => {\n\t\t\t\txyz = adapt$1(this.base.white, this.white, xyz);\n\t\t\t\treturn multiplyMatrices(options.fromXYZ_M, xyz);\n\t\t\t};\n\t\t}\n\n\t\toptions.referred ??= \"display\";\n\n\t\tsuper(options);\n\t}\n}\n\n/**\n * Convert a CSS Color string to a color object\n * @param {string} str\n * @param {object} [options]\n * @param {object} [options.meta] - Object for additional information about the parsing\n * @returns { Color }\n */\nfunction parse (str, {meta} = {}) {\n\tlet env = {\"str\": String(str)?.trim()};\n\thooks.run(\"parse-start\", env);\n\n\tif (env.color) {\n\t\treturn env.color;\n\t}\n\n\tenv.parsed = parseFunction(env.str);\n\n\tif (env.parsed) {\n\t\t// Is a functional syntax\n\t\tlet name = env.parsed.name;\n\n\t\tif (name === \"color\") {\n\t\t\t// color() function\n\t\t\tlet id = env.parsed.args.shift();\n\t\t\tlet alpha = env.parsed.rawArgs.indexOf(\"/\") > 0? env.parsed.args.pop() : 1;\n\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\tlet colorSpec = space.getFormat(\"color\");\n\n\t\t\t\tif (colorSpec) {\n\t\t\t\t\tif (id === colorSpec.id || colorSpec.ids?.includes(id)) {\n\t\t\t\t\t\t// From https://drafts.csswg.org/css-color-4/#color-function\n\t\t\t\t\t\t// If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.\n\t\t\t\t\t\t// If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page won’t use.)\n\t\t\t\t\t\tconst coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);\n\n\t\t\t\t\t\tif (meta) {\n\t\t\t\t\t\t\tmeta.formatId = \"color\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {spaceId: space.id, coords, alpha};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not found\n\t\t\tlet didYouMean = \"\";\n\t\t\tif (id in ColorSpace.registry) {\n\t\t\t\t// Used color space id instead of color() id, these are often different\n\t\t\t\tlet cssId = ColorSpace.registry[id].formats?.functions?.color?.id;\n\n\t\t\t\tif (cssId) {\n\t\t\t\t\tdidYouMean = `Did you mean color(${cssId})?`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new TypeError(`Cannot parse color(${id}). ` + (didYouMean || \"Missing a plugin?\"));\n\t\t}\n\t\telse {\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\t// color space specific function\n\t\t\t\tlet format = space.getFormat(name);\n\t\t\t\tif (format && format.type === \"function\") {\n\t\t\t\t\tlet alpha = 1;\n\n\t\t\t\t\tif (format.lastAlpha || last(env.parsed.args).alpha) {\n\t\t\t\t\t\talpha = env.parsed.args.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tlet coords = env.parsed.args;\n\n\t\t\t\t\tlet types;\n\n\t\t\t\t\tif (format.coordGrammar) {\n\t\t\t\t\t\ttypes = Object.entries(space.coords).map(([id, coordMeta], i) => {\n\t\t\t\t\t\t\tlet coordGrammar = format.coordGrammar[i];\n\t\t\t\t\t\t\tlet providedType = coords[i]?.type;\n\n\t\t\t\t\t\t\t// Find grammar alternative that matches the provided type\n\t\t\t\t\t\t\t// Non-strict equals is intentional because we are comparing w/ string objects\n\t\t\t\t\t\t\tlet type = coordGrammar.find(c => c == providedType);\n\n\t\t\t\t\t\t\t// Check that each coord conforms to its grammar\n\t\t\t\t\t\t\tif (!type) {\n\t\t\t\t\t\t\t\t// Type does not exist in the grammar, throw\n\t\t\t\t\t\t\t\tlet coordName = coordMeta.name || id;\n\t\t\t\t\t\t\t\tthrow new TypeError(`${providedType} not allowed for ${coordName} in ${name}()`);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet fromRange = type.range;\n\n\t\t\t\t\t\t\tif (providedType === \"<percentage>\") {\n\t\t\t\t\t\t\t\tfromRange ||= [0, 1];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet toRange = coordMeta.range || coordMeta.refRange;\n\n\t\t\t\t\t\t\tif (fromRange && toRange) {\n\t\t\t\t\t\t\t\tcoords[i] = mapRange(fromRange, toRange, coords[i]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn type;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tObject.assign(meta, {formatId: format.name, types});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tspaceId: space.id,\n\t\t\t\t\t\tcoords, alpha\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Custom, colorspace-specific format\n\t\tfor (let space of ColorSpace.all) {\n\t\t\tfor (let formatId in space.formats) {\n\t\t\t\tlet format = space.formats[formatId];\n\n\t\t\t\tif (format.type !== \"custom\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (format.test && !format.test(env.str)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet color = format.parse(env.str);\n\n\t\t\t\tif (color) {\n\t\t\t\t\tcolor.alpha ??= 1;\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tmeta.formatId = formatId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// If we're here, we couldn't parse\n\tthrow new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);\n}\n\n/**\n * Resolves a color reference (object or string) to a plain color object\n * @param {Color | {space, coords, alpha} | string} color\n * @returns {{space, coords, alpha}}\n */\nfunction getColor (color) {\n\tif (!color) {\n\t\tthrow new TypeError(\"Empty color reference\");\n\t}\n\n\tif (isString(color)) {\n\t\tcolor = parse(color);\n\t}\n\n\t// Object fixup\n\tlet space = color.space || color.spaceId;\n\n\tif (!(space instanceof ColorSpace)) {\n\t\t// Convert string id to color space object\n\t\tcolor.space = ColorSpace.get(space);\n\t}\n\n\tif (color.alpha === undefined) {\n\t\tcolor.alpha = 1;\n\t}\n\n\treturn color;\n}\n\n/**\n * Get the coordinates of a color in another color space\n *\n * @param {string | ColorSpace} space\n * @returns {number[]}\n */\nfunction getAll (color, space) {\n\tspace = ColorSpace.get(space);\n\treturn space.from(color);\n}\n\nfunction get (color, prop) {\n\tlet {space, index} = ColorSpace.resolveCoord(prop, color.space);\n\tlet coords = getAll(color, space);\n\treturn coords[index];\n}\n\nfunction setAll (color, space, coords) {\n\tspace = ColorSpace.get(space);\n\tcolor.coords = space.to(color.space, coords);\n\treturn color;\n}\n\n// Set properties and return current instance\nfunction set (color, prop, value) {\n\tcolor = getColor(color);\n\n\tif (arguments.length === 2 && type(arguments[1]) === \"object\") {\n\t\t// Argument is an object literal\n\t\tlet object = arguments[1];\n\t\tfor (let p in object) {\n\t\t\tset(color, p, object[p]);\n\t\t}\n\t}\n\telse {\n\t\tif (typeof value === \"function\") {\n\t\t\tvalue = value(get(color, prop));\n\t\t}\n\n\t\tlet {space, index} = ColorSpace.resolveCoord(prop, color.space);\n\t\tlet coords = getAll(color, space);\n\t\tcoords[index] = value;\n\t\tsetAll(color, space, coords);\n\t}\n\n\treturn color;\n}\n\nvar XYZ_D50 = new ColorSpace({\n\tid: \"xyz-d50\",\n\tname: \"XYZ D50\",\n\twhite: \"D50\",\n\tbase: XYZ_D65,\n\tfromBase: coords => adapt$1(XYZ_D65.white, \"D50\", coords),\n\ttoBase: coords => adapt$1(\"D50\", XYZ_D65.white, coords),\n\tformats: {\n\t\tcolor: {}\n\t},\n});\n\n// κ * ε  = 2^3 = 8\nconst ε$3 = 216/24389;  // 6^3/29^3 == (24/116)^3\nconst ε3$1 = 24/116;\nconst κ$1 = 24389/27;   // 29^3/3^3\n\nlet white$1 = WHITES.D50;\n\nvar lab = new ColorSpace({\n\tid: \"lab\",\n\tname: \"Lab\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"L\"\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-125, 125]\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-125, 125]\n\t\t}\n\t},\n\n\t// Assuming XYZ is relative to D50, convert to CIE Lab\n\t// from CIE standard, which now defines these as a rational fraction\n\twhite: white$1,\n\n\tbase: XYZ_D50,\n\t// Convert D50-adapted XYX to Lab\n\t//  CIE 15.3:2004 section 8.2.1.1\n\tfromBase (XYZ) {\n\t\t// compute xyz, which is XYZ scaled relative to reference white\n\t\tlet xyz = XYZ.map((value, i) => value / white$1[i]);\n\n\t\t// now compute f\n\t\tlet f = xyz.map(value => value > ε$3 ? Math.cbrt(value) : (κ$1 * value + 16)/116);\n\n\t\treturn [\n\t\t\t(116 * f[1]) - 16, \t // L\n\t\t\t500 * (f[0] - f[1]), // a\n\t\t\t200 * (f[1] - f[2])  // b\n\t\t];\n\t},\n\t// Convert Lab to D50-adapted XYZ\n\t// Same result as CIE 15.3:2004 Appendix D although the derivation is different\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\ttoBase (Lab) {\n\t\t// compute f, starting with the luminance-related term\n\t\tlet f = [];\n\t\tf[1] = (Lab[0] + 16)/116;\n\t\tf[0] = Lab[1]/500 + f[1];\n\t\tf[2] = f[1] - Lab[2]/200;\n\n\t\t// compute xyz\n\t\tlet xyz = [\n\t\t\tf[0]   > ε3$1  ?  Math.pow(f[0], 3)            : (116*f[0]-16)/κ$1,\n\t\t\tLab[0] > 8   ?  Math.pow((Lab[0]+16)/116, 3) : Lab[0]/κ$1,\n\t\t\tf[2]   > ε3$1  ?  Math.pow(f[2], 3)            : (116*f[2]-16)/κ$1\n\t\t];\n\n\t\t// Compute XYZ by scaling xyz by reference white\n\t\treturn xyz.map((value, i) => value * white$1[i]);\n\t},\n\n\tformats: {\n\t\t\"lab\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t}\n\t}\n});\n\nfunction constrain (angle) {\n\treturn ((angle % 360) + 360) % 360;\n}\n\nfunction adjust (arc, angles) {\n\tif (arc === \"raw\") {\n\t\treturn angles;\n\t}\n\n\tlet [a1, a2] = angles.map(constrain);\n\n\tlet angleDiff = a2 - a1;\n\n\tif (arc === \"increasing\") {\n\t\tif (angleDiff < 0) {\n\t\t\ta2 += 360;\n\t\t}\n\t}\n\telse if (arc === \"decreasing\") {\n\t\tif (angleDiff > 0) {\n\t\t\ta1 += 360;\n\t\t}\n\t}\n\telse if (arc === \"longer\") {\n\t\tif (-180 < angleDiff && angleDiff < 180) {\n\t\t\tif (angleDiff > 0) {\n\t\t\t\ta1 += 360;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta2 += 360;\n\t\t\t}\n\t\t}\n\t}\n\telse if (arc === \"shorter\") {\n\t\tif (angleDiff > 180) {\n\t\t\ta1 += 360;\n\t\t}\n\t\telse if (angleDiff < -180) {\n\t\t\ta2 += 360;\n\t\t}\n\t}\n\n\treturn [a1, a2];\n}\n\nvar lch = new ColorSpace({\n\tid: \"lch\",\n\tname: \"LCH\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\"\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 150],\n\t\t\tname: \"Chroma\"\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\"\n\t\t}\n\t},\n\n\tbase: lab,\n\tfromBase (Lab) {\n\t\t// Convert to polar form\n\t\tlet [L, a, b] = Lab;\n\t\tlet hue;\n\t\tconst ε = 0.02;\n\n\t\tif (Math.abs(a) < ε && Math.abs(b) < ε) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(b, a) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // L is still L\n\t\t\tMath.sqrt(a ** 2 + b ** 2), // Chroma\n\t\t\tconstrain(hue) // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (LCH) {\n\t\t// Convert from polar form\n\t\tlet [Lightness, Chroma, Hue] = LCH;\n\t\t// Clamp any negative Chroma\n\t\tif (Chroma < 0) {\n\t\t\tChroma = 0;\n\t\t}\t\t// Deal with NaN Hue\n\t\tif (isNaN(Hue)) {\n\t\t\tHue = 0;\n\t\t}\n\t\treturn [\n\t\t\tLightness, // L is still L\n\t\t\tChroma * Math.cos(Hue * Math.PI / 180), // a\n\t\t\tChroma * Math.sin(Hue * Math.PI / 180)  // b\n\t\t];\n\t},\n\n\tformats: {\n\t\t\"lch\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>\", \"<number> | <angle>\"],\n\t\t}\n\t}\n});\n\n// deltaE2000 is a statistically significant improvement\n// and is recommended by the CIE and Idealliance\n// especially for color differences less than 10 deltaE76\n// but is wicked complicated\n// and many implementations have small errors!\n// DeltaE2000 is also discontinuous; in case this\n// matters to you, use deltaECMC instead.\n\nconst Gfactor = 25 ** 7;\nconst π$1 = Math.PI;\nconst r2d = 180 / π$1;\nconst d2r$1 = π$1 / 180;\n\nfunction deltaE2000 (color, sample, {kL = 1, kC = 1, kH = 1} = {}) {\n\t// Given this color as the reference\n\t// and the function parameter as the sample,\n\t// calculate deltaE 2000.\n\n\t// This implementation assumes the parametric\n\t// weighting factors kL, kC and kH\n\t// for the influence of viewing conditions\n\t// are all 1, as sadly seems typical.\n\t// kL should be increased for lightness texture or noise\n\t// and kC increased for chroma noise\n\n\tlet [L1, a1, b1] = lab.from(color);\n\tlet C1 = lch.from(lab, [L1, a1, b1])[1];\n\tlet [L2, a2, b2] = lab.from(sample);\n\tlet C2 = lch.from(lab, [L2, a2, b2])[1];\n\n\t// Check for negative Chroma,\n\t// which might happen through\n\t// direct user input of LCH values\n\n\tif (C1 < 0) {\n\t\tC1 = 0;\n\t}\n\tif (C2 < 0) {\n\t\tC2 = 0;\n\t}\n\n\tlet Cbar = (C1 + C2)/2; // mean Chroma\n\n\t// calculate a-axis asymmetry factor from mean Chroma\n\t// this turns JND ellipses for near-neutral colors back into circles\n\tlet C7 = Cbar ** 7;\n\n\tlet G = 0.5 * (1 - Math.sqrt(C7/(C7 + Gfactor)));\n\n\t// scale a axes by asymmetry factor\n\t// this by the way is why there is no Lab2000 colorspace\n\tlet adash1 = (1 + G) * a1;\n\tlet adash2 = (1 + G) * a2;\n\n\t// calculate new Chroma from scaled a and original b axes\n\tlet Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);\n\tlet Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);\n\n\t// calculate new hues, with zero hue for true neutrals\n\t// and in degrees, not radians\n\n\tlet h1 = (adash1 === 0 && b1 === 0)? 0: Math.atan2(b1, adash1);\n\tlet h2 = (adash2 === 0 && b2 === 0)? 0: Math.atan2(b2, adash2);\n\n\tif (h1 < 0) {\n\t\th1 += 2 * π$1;\n\t}\n\tif (h2 < 0) {\n\t\th2 += 2 * π$1;\n\t}\n\n\th1 *= r2d;\n\th2 *= r2d;\n\n\t// Lightness and Chroma differences; sign matters\n\tlet ΔL = L2 - L1;\n\tlet ΔC = Cdash2 - Cdash1;\n\n\t// Hue difference, getting the sign correct\n\tlet hdiff = h2 - h1;\n\tlet hsum = h1 + h2;\n\tlet habs = Math.abs(hdiff);\n\tlet Δh;\n\n\tif (Cdash1 * Cdash2 === 0) {\n\t\tΔh = 0;\n\t}\n\telse if (habs <= 180) {\n\t\tΔh = hdiff;\n\t}\n\telse if (hdiff > 180) {\n\t\tΔh = hdiff - 360;\n\t}\n\telse if (hdiff < -180) {\n\t\tΔh = hdiff + 360;\n\t}\n\telse {\n\t\tconsole.log(\"the unthinkable has happened\");\n\t}\n\n\t// weighted Hue difference, more for larger Chroma\n\tlet ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);\n\n\t// calculate mean Lightness and Chroma\n\tlet Ldash = (L1 + L2)/2;\n\tlet Cdash = (Cdash1 + Cdash2)/2;\n\tlet Cdash7 = Math.pow(Cdash, 7);\n\n\t// Compensate for non-linearity in the blue region of Lab.\n\t// Four possibilities for hue weighting factor,\n\t// depending on the angles, to get the correct sign\n\tlet hdash;\n\tif (Cdash1 * Cdash2 === 0) {\n\t\thdash = hsum;   // which should be zero\n\t}\n\telse if (habs <= 180) {\n\t\thdash = hsum / 2;\n\t}\n\telse if (hsum < 360) {\n\t\thdash = (hsum + 360) / 2;\n\t}\n\telse {\n\t\thdash = (hsum - 360) / 2;\n\t}\n\n\t// positional corrections to the lack of uniformity of CIELAB\n\t// These are all trying to make JND ellipsoids more like spheres\n\n\t// SL Lightness crispening factor\n\t// a background with L=50 is assumed\n\tlet lsq = (Ldash - 50) ** 2;\n\tlet SL = 1 + ((0.015 * lsq) / Math.sqrt(20 + lsq));\n\n\t// SC Chroma factor, similar to those in CMC and deltaE 94 formulae\n\tlet SC = 1 + 0.045 * Cdash;\n\n\t// Cross term T for blue non-linearity\n\tlet T = 1;\n\tT -= (0.17 * Math.cos((     hdash - 30)  * d2r$1));\n\tT += (0.24 * Math.cos(  2 * hdash        * d2r$1));\n\tT += (0.32 * Math.cos(((3 * hdash) + 6)  * d2r$1));\n\tT -= (0.20 * Math.cos(((4 * hdash) - 63) * d2r$1));\n\n\t// SH Hue factor depends on Chroma,\n\t// as well as adjusted hue angle like deltaE94.\n\tlet SH = 1 + 0.015 * Cdash * T;\n\n\t// RT Hue rotation term compensates for rotation of JND ellipses\n\t// and Munsell constant hue lines\n\t// in the medium-high Chroma blue region\n\t// (Hue 225 to 315)\n\tlet Δθ = 30 * Math.exp(-1 * (((hdash - 275)/25) ** 2));\n\tlet RC = 2 * Math.sqrt(Cdash7/(Cdash7 + Gfactor));\n\tlet RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;\n\n\t// Finally calculate the deltaE, term by term as root sume of squares\n\tlet dE = (ΔL / (kL * SL)) ** 2;\n\tdE += (ΔC / (kC * SC)) ** 2;\n\tdE += (ΔH / (kH * SH)) ** 2;\n\tdE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));\n\treturn Math.sqrt(dE);\n\t// Yay!!!\n}\n\nconst ε$2 = .000075;\n\n/**\n * Check if a color is in gamut of either its own or another color space\n * @return {Boolean} Is the color in gamut?\n */\nfunction inGamut (color, space = color.space, {epsilon = ε$2} = {}) {\n\tcolor = getColor(color);\n\tspace = ColorSpace.get(space);\n\tlet coords = color.coords;\n\n\tif (space !== color.space) {\n\t\tcoords = space.from(color);\n\t}\n\n\treturn space.inGamut(coords, {epsilon});\n}\n\nfunction clone (color) {\n\treturn {\n\t\tspace: color.space,\n\t\tcoords: color.coords.slice(),\n\t\talpha: color.alpha\n\t};\n}\n\n/**\n * Force coordinates to be in gamut of a certain color space.\n * Mutates the color it is passed.\n * @param {Object} options\n * @param {string} options.method - How to force into gamut.\n *        If \"clip\", coordinates are just clipped to their reference range.\n *        If in the form [colorSpaceId].[coordName], that coordinate is reduced\n *        until the color is in gamut. Please note that this may produce nonsensical\n *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.\n * @param {ColorSpace|string} options.space - The space whose gamut we want to map to\n */\nfunction toGamut (color, {method = defaults.gamut_mapping, space = color.space} = {}) {\n\tif (isString(arguments[1])) {\n\t\tspace = arguments[1];\n\t}\n\n\tspace = ColorSpace.get(space);\n\n\tif (inGamut(color, space, {epsilon: 0})) {\n\t\treturn getColor(color);\n\t}\n\n\t// 3 spaces:\n\t// color.space: current color space\n\t// space: space whose gamut we are mapping to\n\t// mapSpace: space with the coord we're reducing\n\tlet spaceColor = to(color, space);\n\n\tif (method !== \"clip\" && !inGamut(color, space)) {\n\t\tlet clipped = toGamut(clone(spaceColor), {method: \"clip\", space});\n\t\tif (deltaE2000(color, clipped) > 2) {\n\t\t\t// Reduce a coordinate of a certain color space until the color is in gamut\n\t\t\tlet coordMeta = ColorSpace.resolveCoord(method);\n\t\t\tlet mapSpace = coordMeta.space;\n\t\t\tlet coordId = coordMeta.id;\n\n\t\t\tlet mappedColor = to(spaceColor, mapSpace);\n\t\t\tlet bounds = coordMeta.range || coordMeta.refRange;\n\t\t\tlet min = bounds[0];\n\t\t\tlet ε = .01; // for deltaE\n\t\t\tlet low = min;\n\t\t\tlet high = get(mappedColor, coordId);\n\n\t\t\twhile (high - low > ε) {\n\t\t\t\tlet clipped = clone(mappedColor);\n\t\t\t\tclipped = toGamut(clipped, {space, method: \"clip\"});\n\t\t\t\tlet deltaE = deltaE2000(mappedColor, clipped);\n\n\t\t\t\tif (deltaE - 2 < ε) {\n\t\t\t\t\tlow = get(mappedColor, coordId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thigh = get(mappedColor, coordId);\n\t\t\t\t}\n\n\t\t\t\tset(mappedColor, coordId, (low + high) / 2);\n\t\t\t}\n\n\t\t\tspaceColor = to(mappedColor, space);\n\t\t}\n\t\telse {\n\t\t\tspaceColor = clipped;\n\t\t}\n\t}\n\n\tif (method === \"clip\" // Dumb coord clipping\n\t\t// finish off smarter gamut mapping with clip to get rid of ε, see #17\n\t\t|| !inGamut(spaceColor, space, {epsilon: 0})\n\t) {\n\t\tlet bounds = Object.values(space.coords).map(c => c.range || []);\n\n\t\tspaceColor.coords = spaceColor.coords.map((c, i) => {\n\t\t\tlet [min, max] = bounds[i];\n\n\t\t\tif (min !== undefined) {\n\t\t\t\tc = Math.max(min, c);\n\t\t\t}\n\n\t\t\tif (max !== undefined) {\n\t\t\t\tc = Math.min(c, max);\n\t\t\t}\n\n\t\t\treturn c;\n\t\t});\n\t}\n\n\tif (space !== color.space) {\n\t\tspaceColor = to(spaceColor, color.space);\n\t}\n\n\tcolor.coords = spaceColor.coords;\n\treturn color;\n}\n\ntoGamut.returns = \"color\";\n\n/**\n * Convert to color space and return a new color\n * @param {Object|string} space - Color space object or id\n * @param {Object} options\n * @param {boolean} options.inGamut - Whether to force resulting color in gamut\n * @returns {Color}\n */\nfunction to (color, space, {inGamut} = {}) {\n\tcolor = getColor(color);\n\tspace = ColorSpace.get(space);\n\n\tlet coords = space.from(color);\n\tlet ret = {space, coords, alpha: color.alpha};\n\n\tif (inGamut) {\n\t\tret = toGamut(ret);\n\t}\n\n\treturn ret;\n}\n\nto.returns = \"color\";\n\n/**\n * Generic toString() method, outputs a color(spaceId ...coords) function, a functional syntax, or custom formats defined by the color space\n * @param {Object} options\n * @param {number} options.precision - Significant digits\n * @param {boolean} options.inGamut - Adjust coordinates to fit in gamut first? [default: false]\n */\nfunction serialize (color, {\n\tprecision = defaults.precision,\n\tformat = \"default\",\n\tinGamut: inGamut$1 = true,\n\t...customOptions\n} = {}) {\n\tlet ret;\n\n\tcolor = getColor(color);\n\n\tlet formatId = format;\n\tformat = color.space.getFormat(format)\n\t\t   ?? color.space.getFormat(\"default\")\n\t\t   ?? ColorSpace.DEFAULT_FORMAT;\n\n\tinGamut$1 ||= format.toGamut;\n\n\tlet coords = color.coords;\n\n\t// Convert NaN to zeros to have a chance at a valid CSS color\n\t// Also convert -0 to 0\n\t// This also clones it so we can manipulate it\n\tcoords = coords.map(c => c? c : 0);\n\n\tif (inGamut$1 && !inGamut(color)) {\n\t\tcoords = toGamut(clone(color), inGamut$1 === true? undefined : inGamut$1).coords;\n\t}\n\n\tif (format.type === \"custom\") {\n\t\tcustomOptions.precision = precision;\n\n\t\tif (format.serialize) {\n\t\t\tret = format.serialize(coords, color.alpha, customOptions);\n\t\t}\n\t\telse {\n\t\t\tthrow new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);\n\t\t}\n\t}\n\telse {\n\t\t// Functional syntax\n\t\tlet name = format.name || \"color\";\n\n\t\tif (format.serializeCoords) {\n\t\t\tcoords = format.serializeCoords(coords, precision);\n\t\t}\n\t\telse {\n\t\t\tif (precision !== null) {\n\t\t\t\tcoords = coords.map(c => toPrecision(c, precision));\n\t\t\t}\n\t\t}\n\n\t\tlet args = [...coords];\n\n\t\tif (name === \"color\") {\n\t\t\t// If output is a color() function, add colorspace id as first argument\n\t\t\tlet cssId = format.id || format.ids?.[0] || color.space.id;\n\t\t\targs.unshift(cssId);\n\t\t}\n\n\t\tlet alpha = color.alpha;\n\t\tif (precision !== null) {\n\t\t\talpha = toPrecision(alpha, precision);\n\t\t}\n\n\t\tlet strAlpha = color.alpha < 1 && !format.noAlpha? `${format.commas? \",\" : \" /\"} ${alpha}` : \"\";\n\t\tret = `${name}(${args.join(format.commas? \", \" : \" \")}${strAlpha})`;\n\t}\n\n\treturn ret;\n}\n\n// convert an array of linear-light rec2020 values to CIE XYZ\n// using  D65 (no chromatic adaptation)\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// 0 is actually calculated as  4.994106574466076e-17\nconst toXYZ_M$5 = [\n\t[ 0.6369580483012914, 0.14461690358620832,  0.1688809751641721  ],\n\t[ 0.2627002120112671, 0.6779980715188708,   0.05930171646986196 ],\n\t[ 0.000000000000000,  0.028072693049087428, 1.060985057710791   ]\n];\n\n// from ITU-R BT.2124-0 Annex 2 p.3\nconst fromXYZ_M$5 = [\n\t[  1.716651187971268,  -0.355670783776392, -0.253366281373660  ],\n\t[ -0.666684351832489,   1.616481236634939,  0.0157685458139111 ],\n\t[  0.017639857445311,  -0.042770613257809,  0.942103121235474  ]\n];\n\nvar REC2020Linear = new RGBColorSpace({\n\tid: \"rec2020-linear\",\n\tname: \"Linear REC.2020\",\n\twhite: \"D65\",\n\ttoXYZ_M: toXYZ_M$5,\n\tfromXYZ_M: fromXYZ_M$5,\n\tformats: {\n\t\tcolor: {},\n\t}\n});\n\n// import sRGB from \"./srgb.js\";\n\nconst α = 1.09929682680944;\nconst β = 0.018053968510807;\n\nvar REC2020 = new RGBColorSpace({\n\tid: \"rec2020\",\n\tname: \"REC.2020\",\n\tbase: REC2020Linear,\n\t// Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4\n\ttoBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val < β * 4.5 ) {\n\t\t\t\treturn val / 4.5;\n\t\t\t}\n\n\t\t\treturn Math.pow((val + α -1 ) / α, 1/0.45);\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val >= β ) {\n\t\t\t\treturn α * Math.pow(val, 0.45) - (α - 1);\n\t\t\t}\n\n\t\t\treturn 4.5 * val;\n\t\t});\n\t},\n\tformats: {\n\t\tcolor: {},\n\t}\n});\n\nconst toXYZ_M$4 = [\n\t[0.4865709486482162, 0.26566769316909306, 0.1982172852343625],\n\t[0.2289745640697488, 0.6917385218365064,  0.079286914093745],\n\t[0.0000000000000000, 0.04511338185890264, 1.043944368900976]\n];\n\nconst fromXYZ_M$4 = [\n\t[ 2.493496911941425,   -0.9313836179191239, -0.40271078445071684],\n\t[-0.8294889695615747,   1.7626640603183463,  0.023624685841943577],\n\t[ 0.03584583024378447, -0.07617238926804182, 0.9568845240076872]\n];\n\nvar P3Linear = new RGBColorSpace({\n\tid: \"p3-linear\",\n\tname: \"Linear P3\",\n\twhite: \"D65\",\n\ttoXYZ_M: toXYZ_M$4,\n\tfromXYZ_M: fromXYZ_M$4\n});\n\n// This is the linear-light version of sRGB\n// as used for example in SVG filters\n// or in Canvas\n\n// This matrix was calculated directly from the RGB and white chromaticities\n// when rounded to 8 decimal places, it agrees completely with the official matrix\n// see https://github.com/w3c/csswg-drafts/issues/5922\nconst toXYZ_M$3 = [\n\t[ 0.41239079926595934, 0.357584339383878,   0.1804807884018343  ],\n\t[ 0.21263900587151027, 0.715168678767756,   0.07219231536073371 ],\n\t[ 0.01933081871559182, 0.11919477979462598, 0.9505321522496607  ]\n];\n\n// This matrix is the inverse of the above;\n// again it agrees with the official definition when rounded to 8 decimal places\nconst fromXYZ_M$3 = [\n\t[  3.2409699419045226,  -1.537383177570094,   -0.4986107602930034  ],\n\t[ -0.9692436362808796,   1.8759675015077202,   0.04155505740717559 ],\n\t[  0.05563007969699366, -0.20397695888897652,  1.0569715142428786  ]\n];\n\nvar sRGBLinear = new RGBColorSpace({\n\tid: \"srgb-linear\",\n\tname: \"Linear sRGB\",\n\twhite: \"D65\",\n\ttoXYZ_M: toXYZ_M$3,\n\tfromXYZ_M: fromXYZ_M$3,\n\tformats: {\n\t\tcolor: {}\n\t},\n});\n\n/* List of CSS color keywords\n * Note that this does not include currentColor, transparent,\n * or system colors\n */\n\n// To produce: Visit https://www.w3.org/TR/css-color-4/#named-colors\n// and run in the console:\n// copy($$(\"tr\", $(\".named-color-table tbody\")).map(tr => `\"${tr.cells[2].textContent.trim()}\": [${tr.cells[4].textContent.trim().split(/\\s+/).map(c => c === \"0\"? \"0\" : c === \"255\"? \"1\" : c + \" / 255\").join(\", \")}]`).join(\",\\n\"))\nvar KEYWORDS = {\n\t\"aliceblue\": [240 / 255, 248 / 255, 1],\n\t\"antiquewhite\": [250 / 255, 235 / 255, 215 / 255],\n\t\"aqua\": [0, 1, 1],\n\t\"aquamarine\": [127 / 255, 1, 212 / 255],\n\t\"azure\": [240 / 255, 1, 1],\n\t\"beige\": [245 / 255, 245 / 255, 220 / 255],\n\t\"bisque\": [1, 228 / 255, 196 / 255],\n\t\"black\": [0, 0, 0],\n\t\"blanchedalmond\": [1, 235 / 255, 205 / 255],\n\t\"blue\": [0, 0, 1],\n\t\"blueviolet\": [138 / 255, 43 / 255, 226 / 255],\n\t\"brown\": [165 / 255, 42 / 255, 42 / 255],\n\t\"burlywood\": [222 / 255, 184 / 255, 135 / 255],\n\t\"cadetblue\": [95 / 255, 158 / 255, 160 / 255],\n\t\"chartreuse\": [127 / 255, 1, 0],\n\t\"chocolate\": [210 / 255, 105 / 255, 30 / 255],\n\t\"coral\": [1, 127 / 255, 80 / 255],\n\t\"cornflowerblue\": [100 / 255, 149 / 255, 237 / 255],\n\t\"cornsilk\": [1, 248 / 255, 220 / 255],\n\t\"crimson\": [220 / 255, 20 / 255, 60 / 255],\n\t\"cyan\": [0, 1, 1],\n\t\"darkblue\": [0, 0, 139 / 255],\n\t\"darkcyan\": [0, 139 / 255, 139 / 255],\n\t\"darkgoldenrod\": [184 / 255, 134 / 255, 11 / 255],\n\t\"darkgray\": [169 / 255, 169 / 255, 169 / 255],\n\t\"darkgreen\": [0, 100 / 255, 0],\n\t\"darkgrey\": [169 / 255, 169 / 255, 169 / 255],\n\t\"darkkhaki\": [189 / 255, 183 / 255, 107 / 255],\n\t\"darkmagenta\": [139 / 255, 0, 139 / 255],\n\t\"darkolivegreen\": [85 / 255, 107 / 255, 47 / 255],\n\t\"darkorange\": [1, 140 / 255, 0],\n\t\"darkorchid\": [153 / 255, 50 / 255, 204 / 255],\n\t\"darkred\": [139 / 255, 0, 0],\n\t\"darksalmon\": [233 / 255, 150 / 255, 122 / 255],\n\t\"darkseagreen\": [143 / 255, 188 / 255, 143 / 255],\n\t\"darkslateblue\": [72 / 255, 61 / 255, 139 / 255],\n\t\"darkslategray\": [47 / 255, 79 / 255, 79 / 255],\n\t\"darkslategrey\": [47 / 255, 79 / 255, 79 / 255],\n\t\"darkturquoise\": [0, 206 / 255, 209 / 255],\n\t\"darkviolet\": [148 / 255, 0, 211 / 255],\n\t\"deeppink\": [1, 20 / 255, 147 / 255],\n\t\"deepskyblue\": [0, 191 / 255, 1],\n\t\"dimgray\": [105 / 255, 105 / 255, 105 / 255],\n\t\"dimgrey\": [105 / 255, 105 / 255, 105 / 255],\n\t\"dodgerblue\": [30 / 255, 144 / 255, 1],\n\t\"firebrick\": [178 / 255, 34 / 255, 34 / 255],\n\t\"floralwhite\": [1, 250 / 255, 240 / 255],\n\t\"forestgreen\": [34 / 255, 139 / 255, 34 / 255],\n\t\"fuchsia\": [1, 0, 1],\n\t\"gainsboro\": [220 / 255, 220 / 255, 220 / 255],\n\t\"ghostwhite\": [248 / 255, 248 / 255, 1],\n\t\"gold\": [1, 215 / 255, 0],\n\t\"goldenrod\": [218 / 255, 165 / 255, 32 / 255],\n\t\"gray\": [128 / 255, 128 / 255, 128 / 255],\n\t\"green\": [0, 128 / 255, 0],\n\t\"greenyellow\": [173 / 255, 1, 47 / 255],\n\t\"grey\": [128 / 255, 128 / 255, 128 / 255],\n\t\"honeydew\": [240 / 255, 1, 240 / 255],\n\t\"hotpink\": [1, 105 / 255, 180 / 255],\n\t\"indianred\": [205 / 255, 92 / 255, 92 / 255],\n\t\"indigo\": [75 / 255, 0, 130 / 255],\n\t\"ivory\": [1, 1, 240 / 255],\n\t\"khaki\": [240 / 255, 230 / 255, 140 / 255],\n\t\"lavender\": [230 / 255, 230 / 255, 250 / 255],\n\t\"lavenderblush\": [1, 240 / 255, 245 / 255],\n\t\"lawngreen\": [124 / 255, 252 / 255, 0],\n\t\"lemonchiffon\": [1, 250 / 255, 205 / 255],\n\t\"lightblue\": [173 / 255, 216 / 255, 230 / 255],\n\t\"lightcoral\": [240 / 255, 128 / 255, 128 / 255],\n\t\"lightcyan\": [224 / 255, 1, 1],\n\t\"lightgoldenrodyellow\": [250 / 255, 250 / 255, 210 / 255],\n\t\"lightgray\": [211 / 255, 211 / 255, 211 / 255],\n\t\"lightgreen\": [144 / 255, 238 / 255, 144 / 255],\n\t\"lightgrey\": [211 / 255, 211 / 255, 211 / 255],\n\t\"lightpink\": [1, 182 / 255, 193 / 255],\n\t\"lightsalmon\": [1, 160 / 255, 122 / 255],\n\t\"lightseagreen\": [32 / 255, 178 / 255, 170 / 255],\n\t\"lightskyblue\": [135 / 255, 206 / 255, 250 / 255],\n\t\"lightslategray\": [119 / 255, 136 / 255, 153 / 255],\n\t\"lightslategrey\": [119 / 255, 136 / 255, 153 / 255],\n\t\"lightsteelblue\": [176 / 255, 196 / 255, 222 / 255],\n\t\"lightyellow\": [1, 1, 224 / 255],\n\t\"lime\": [0, 1, 0],\n\t\"limegreen\": [50 / 255, 205 / 255, 50 / 255],\n\t\"linen\": [250 / 255, 240 / 255, 230 / 255],\n\t\"magenta\": [1, 0, 1],\n\t\"maroon\": [128 / 255, 0, 0],\n\t\"mediumaquamarine\": [102 / 255, 205 / 255, 170 / 255],\n\t\"mediumblue\": [0, 0, 205 / 255],\n\t\"mediumorchid\": [186 / 255, 85 / 255, 211 / 255],\n\t\"mediumpurple\": [147 / 255, 112 / 255, 219 / 255],\n\t\"mediumseagreen\": [60 / 255, 179 / 255, 113 / 255],\n\t\"mediumslateblue\": [123 / 255, 104 / 255, 238 / 255],\n\t\"mediumspringgreen\": [0, 250 / 255, 154 / 255],\n\t\"mediumturquoise\": [72 / 255, 209 / 255, 204 / 255],\n\t\"mediumvioletred\": [199 / 255, 21 / 255, 133 / 255],\n\t\"midnightblue\": [25 / 255, 25 / 255, 112 / 255],\n\t\"mintcream\": [245 / 255, 1, 250 / 255],\n\t\"mistyrose\": [1, 228 / 255, 225 / 255],\n\t\"moccasin\": [1, 228 / 255, 181 / 255],\n\t\"navajowhite\": [1, 222 / 255, 173 / 255],\n\t\"navy\": [0, 0, 128 / 255],\n\t\"oldlace\": [253 / 255, 245 / 255, 230 / 255],\n\t\"olive\": [128 / 255, 128 / 255, 0],\n\t\"olivedrab\": [107 / 255, 142 / 255, 35 / 255],\n\t\"orange\": [1, 165 / 255, 0],\n\t\"orangered\": [1, 69 / 255, 0],\n\t\"orchid\": [218 / 255, 112 / 255, 214 / 255],\n\t\"palegoldenrod\": [238 / 255, 232 / 255, 170 / 255],\n\t\"palegreen\": [152 / 255, 251 / 255, 152 / 255],\n\t\"paleturquoise\": [175 / 255, 238 / 255, 238 / 255],\n\t\"palevioletred\": [219 / 255, 112 / 255, 147 / 255],\n\t\"papayawhip\": [1, 239 / 255, 213 / 255],\n\t\"peachpuff\": [1, 218 / 255, 185 / 255],\n\t\"peru\": [205 / 255, 133 / 255, 63 / 255],\n\t\"pink\": [1, 192 / 255, 203 / 255],\n\t\"plum\": [221 / 255, 160 / 255, 221 / 255],\n\t\"powderblue\": [176 / 255, 224 / 255, 230 / 255],\n\t\"purple\": [128 / 255, 0, 128 / 255],\n\t\"rebeccapurple\": [102 / 255, 51 / 255, 153 / 255],\n\t\"red\": [1, 0, 0],\n\t\"rosybrown\": [188 / 255, 143 / 255, 143 / 255],\n\t\"royalblue\": [65 / 255, 105 / 255, 225 / 255],\n\t\"saddlebrown\": [139 / 255, 69 / 255, 19 / 255],\n\t\"salmon\": [250 / 255, 128 / 255, 114 / 255],\n\t\"sandybrown\": [244 / 255, 164 / 255, 96 / 255],\n\t\"seagreen\": [46 / 255, 139 / 255, 87 / 255],\n\t\"seashell\": [1, 245 / 255, 238 / 255],\n\t\"sienna\": [160 / 255, 82 / 255, 45 / 255],\n\t\"silver\": [192 / 255, 192 / 255, 192 / 255],\n\t\"skyblue\": [135 / 255, 206 / 255, 235 / 255],\n\t\"slateblue\": [106 / 255, 90 / 255, 205 / 255],\n\t\"slategray\": [112 / 255, 128 / 255, 144 / 255],\n\t\"slategrey\": [112 / 255, 128 / 255, 144 / 255],\n\t\"snow\": [1, 250 / 255, 250 / 255],\n\t\"springgreen\": [0, 1, 127 / 255],\n\t\"steelblue\": [70 / 255, 130 / 255, 180 / 255],\n\t\"tan\": [210 / 255, 180 / 255, 140 / 255],\n\t\"teal\": [0, 128 / 255, 128 / 255],\n\t\"thistle\": [216 / 255, 191 / 255, 216 / 255],\n\t\"tomato\": [1, 99 / 255, 71 / 255],\n\t\"turquoise\": [64 / 255, 224 / 255, 208 / 255],\n\t\"violet\": [238 / 255, 130 / 255, 238 / 255],\n\t\"wheat\": [245 / 255, 222 / 255, 179 / 255],\n\t\"white\": [1, 1, 1],\n\t\"whitesmoke\": [245 / 255, 245 / 255, 245 / 255],\n\t\"yellow\": [1, 1, 0],\n\t\"yellowgreen\": [154 / 255, 205 / 255, 50 / 255]\n};\n\nlet coordGrammar = Array(3).fill(\"<percentage> | <number>[0, 255]\");\nlet coordGrammarNumber = Array(3).fill(\"<number>[0, 255]\");\n\nvar sRGB = new RGBColorSpace({\n\tid: \"srgb\",\n\tname: \"sRGB\",\n\tbase: sRGBLinear,\n\tfromBase: rgb => {\n\t\t// convert an array of linear-light sRGB values in the range 0.0-1.0\n\t\t// to gamma corrected form\n\t\t// https://en.wikipedia.org/wiki/SRGB\n\t\treturn rgb.map(val => {\n\t\t\tlet sign = val < 0? -1 : 1;\n\t\t\tlet abs = val * sign;\n\n\t\t\tif (abs > 0.0031308) {\n\t\t\t\treturn sign * (1.055 * (abs ** (1/2.4)) - 0.055);\n\t\t\t}\n\n\t\t\treturn 12.92 * val;\n\t\t});\n\t},\n\ttoBase: rgb => {\n\t\t// convert an array of sRGB values in the range 0.0 - 1.0\n\t\t// to linear light (un-companded) form.\n\t\t// https://en.wikipedia.org/wiki/SRGB\n\t\treturn rgb.map(val => {\n\t\t\tlet sign = val < 0? -1 : 1;\n\t\t\tlet abs = val * sign;\n\n\t\t\tif (abs < 0.04045) {\n\t\t\t\treturn val / 12.92;\n\t\t\t}\n\n\t\t\treturn sign * (((abs + 0.055) / 1.055) ** 2.4);\n\t\t});\n\t},\n\tformats: {\n\t\t\"rgb\": {\n\t\t\tcoords: coordGrammar,\n\t\t},\n\t\t\"rgb_number\": {\n\t\t\tname: \"rgb\",\n\t\t\tcommas: true,\n\t\t\tcoords: coordGrammarNumber,\n\t\t\tnoAlpha: true,\n\t\t},\n\t\t\"color\": { /* use defaults */ },\n\t\t\"rgba\": {\n\t\t\tcoords: coordGrammar,\n\t\t\tcommas: true,\n\t\t\tlastAlpha: true,\n\t\t},\n\t\t\"rgba_number\": {\n\t\t\tname: \"rgba\",\n\t\t\tcommas: true,\n\t\t\tcoords: coordGrammarNumber\n\t\t},\n\t\t\"hex\": {\n\t\t\ttype: \"custom\",\n\t\t\ttoGamut: true,\n\t\t\ttest: str => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),\n\t\t\tparse (str) {\n\t\t\t\tif (str.length <= 5) {\n\t\t\t\t\t// #rgb or #rgba, duplicate digits\n\t\t\t\t\tstr = str.replace(/[a-f0-9]/gi, \"$&$&\");\n\t\t\t\t}\n\n\t\t\t\tlet rgba = [];\n\t\t\t\tstr.replace(/[a-f0-9]{2}/gi, component => {\n\t\t\t\t\trgba.push(parseInt(component, 16) / 255);\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tspaceId: \"srgb\",\n\t\t\t\t\tcoords: rgba.slice(0, 3),\n\t\t\t\t\talpha: rgba.slice(3)[0]\n\t\t\t\t};\n\t\t\t},\n\t\t\tserialize: (coords, alpha, {\n\t\t\t\tcollapse = true // collapse to 3-4 digit hex when possible?\n\t\t\t} = {}) => {\n\t\t\t\tif (alpha < 1) {\n\t\t\t\t\tcoords.push(alpha);\n\t\t\t\t}\n\n\t\t\t\tcoords = coords.map(c => Math.round(c * 255));\n\n\t\t\t\tlet collapsible = collapse && coords.every(c => c % 17 === 0);\n\n\t\t\t\tlet hex = coords.map(c => {\n\t\t\t\t\tif (collapsible) {\n\t\t\t\t\t\treturn (c/17).toString(16);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn c.toString(16).padStart(2, \"0\");\n\t\t\t\t}).join(\"\");\n\n\t\t\t\treturn \"#\" + hex;\n\t\t\t}\n\t\t},\n\t\t\"keyword\": {\n\t\t\ttype: \"custom\",\n\t\t\ttest: str => /^[a-z]+$/i.test(str),\n\t\t\tparse (str) {\n\t\t\t\tstr = str.toLowerCase();\n\t\t\t\tlet ret = {spaceId: \"srgb\", coords: null, alpha: 1};\n\n\t\t\t\tif (str === \"transparent\") {\n\t\t\t\t\tret.coords = KEYWORDS.black;\n\t\t\t\t\tret.alpha = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.coords = KEYWORDS[str];\n\t\t\t\t}\n\n\t\t\t\tif (ret.coords) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n});\n\nvar P3 = new RGBColorSpace({\n\tid: \"p3\",\n\tname: \"P3\",\n\tbase: P3Linear,\n\t// Gamma encoding/decoding is the same as sRGB\n\tfromBase: sRGB.fromBase,\n\ttoBase: sRGB.toBase,\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"display-p3\",\n\t\t}\n\t},\n});\n\n// Default space for CSS output. Code in Color.js makes this wider if there's a DOM available\ndefaults.display_space = sRGB;\n\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n\t// Find widest supported color space for CSS\n\tfor (let space of [lab, REC2020, P3]) {\n\t\tlet coords = space.getMinCoords();\n\t\tlet color = {space, coords, alpha: 1};\n\t\tlet str = serialize(color);\n\n\t\tif (CSS.supports(\"color\", str)) {\n\t\t\tdefaults.display_space = space;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Returns a serialization of the color that can actually be displayed in the browser.\n * If the default serialization can be displayed, it is returned.\n * Otherwise, the color is converted to Lab, REC2020, or P3, whichever is the widest supported.\n * In Node.js, this is basically equivalent to `serialize()` but returns a `String` object instead.\n *\n * @export\n * @param {{space, coords} | Color | string} color\n * @param {*} [options={}] Options to be passed to serialize()\n * @param {ColorSpace | string} [options.space = defaults.display_space] Color space to use for serialization if default is not supported\n * @returns {String} String object containing the serialized color with a color property containing the converted color (or the original, if no conversion was necessary)\n */\nfunction display (color, {space = defaults.display_space, ...options} = {}) {\n\tlet ret = serialize(color, options);\n\n\tif (typeof CSS === \"undefined\" || CSS.supports(\"color\", ret) || !defaults.display_space) {\n\t\tret = new String(ret);\n\t\tret.color = color;\n\t}\n\telse {\n\t\t// If we're here, what we were about to output is not supported\n\t\t// Fall back to fallback space\n\t\tlet fallbackColor = to(color, space);\n\t\tret = new String(serialize(fallbackColor, options));\n\t\tret.color = fallbackColor;\n\t}\n\n\treturn ret;\n}\n\n/**\n * Euclidean distance of colors in an arbitrary color space\n */\nfunction distance (color1, color2, space = \"lab\") {\n\tspace = ColorSpace.get(space);\n\n\tlet coords1 = space.from(color1);\n\tlet coords2 = space.from(color2);\n\n\treturn Math.sqrt(coords1.reduce((acc, c1, i) => {\n\t\tlet c2 = coords2[i];\n\t\tif (isNaN(c1) || isNaN(c2)) {\n\t\t\treturn acc;\n\t\t}\n\n\t\treturn acc + (c2 - c1) ** 2;\n\t}, 0));\n}\n\nfunction equals (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\treturn color1.space === color2.space\n\t\t   && color1.alpha === color2.alpha\n\t\t   && color1.coords.every((c, i) => c === color2.coords[i]);\n}\n\n/**\n * Relative luminance\n */\n\nfunction getLuminance (color) {\n\treturn get(color, [XYZ_D65, \"y\"]);\n}\n\nfunction setLuminance (color, value) {\n\tset(color, [XYZ_D65, \"y\"], value);\n}\n\nfunction register$2 (Color) {\n\tObject.defineProperty(Color.prototype, \"luminance\", {\n\t\tget () {\n\t\t\treturn getLuminance(this);\n\t\t},\n\t\tset (value) {\n\t\t\tsetLuminance(this, value);\n\t\t}\n\t});\n}\n\nvar luminance = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tgetLuminance: getLuminance,\n\tregister: register$2,\n\tsetLuminance: setLuminance\n});\n\n// WCAG 2.0 contrast https://www.w3.org/TR/WCAG20-TECHS/G18.html\n// Simple contrast, with fixed 5% viewing flare contribution\n// Symmetric, does not matter which is foreground and which is background\n\n\nfunction contrastWCAG21 (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\treturn (Y1 + .05) / (Y2 + .05);\n}\n\n// APCA 0.0.98G\n// https://github.com/Myndex/apca-w3\n// see also https://github.com/w3c/silver/issues/643\n\n\n// exponents\nconst normBG = 0.56;\nconst normTXT = 0.57;\nconst revTXT = 0.62;\nconst revBG = 0.65;\n\n// clamps\nconst blkThrs = 0.022;\nconst blkClmp = 1.414;\nconst loClip = 0.1;\nconst deltaYmin = 0.0005;\n\n// scalers\n// see https://github.com/w3c/silver/issues/645\nconst scaleBoW = 1.14;\nconst loBoWoffset = 0.027;\nconst scaleWoB= 1.14;\n\nfunction fclamp (Y) {\n\tif (Y >= blkThrs) {\n\t\treturn Y;\n\t}\n\treturn Y + (blkThrs - Y) ** blkClmp;\n}\n\nfunction linearize (val) {\n\tlet sign = val < 0? -1 : 1;\n\tlet abs = Math.abs(val);\n\treturn sign * Math.pow(abs, 2.4);\n}\n\n// Not symmetric, requires a foreground (text) color, and a background color\nfunction contrastAPCA (background, foreground) {\n\tforeground = getColor(foreground);\n\tbackground = getColor(background);\n\n\tlet S;\n\tlet C;\n\tlet Sapc;\n\n\t// Myndex as-published, assumes sRGB inputs\n\tlet R, G, B;\n\n\tforeground = to(foreground, \"srgb\");\n\t// Should these be clamped to in-gamut values?\n\n\t// Calculates \"screen luminance\" with non-standard simple gamma EOTF\n\t// weights should be from CSS Color 4, not the ones here which are via Myndex and copied from Lindbloom\n\t[R, G, B] = foreground.coords;\n\tlet lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n\n\tbackground = to(background, \"srgb\");\n\t[R, G, B] = background.coords;\n\tlet lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n\n\t// toe clamping of very dark values to account for flare\n\tlet Ytxt = fclamp(lumTxt);\n\tlet Ybg = fclamp(lumBg);\n\n\t// are we \"Black on White\" (dark on light), or light on dark?\n\tlet BoW = Ybg > Ytxt;\n\n\t// why is this a delta, when Y is not perceptually uniform?\n\t// Answer: it is a noise gate, see\n\t// https://github.com/LeaVerou/color.js/issues/208\n\tif (Math.abs(Ybg - Ytxt) < deltaYmin) {\n\t\tC = 0;\n\t}\n\telse {\n\t\tif (BoW) {\n\t\t\t// dark text on light background\n\t\t\tS = Ybg ** normBG - Ytxt ** normTXT;\n\t\t\tC = S * scaleBoW;\n\t\t}\n\t\telse {\n\t\t\t// light text on dark background\n\t\t\tS = Ybg ** revBG - Ytxt ** revTXT;\n\t\t\tC = S * scaleWoB;\n\t\t}\n\t}\n\tif (Math.abs(C) < loClip) {\n\t\tSapc = 0;\n\t}\n\telse if (C > 0) {\n\t\t// not clear whether Woffset is loBoWoffset or loWoBoffset\n\t\t// but they have the same value\n\t\tSapc = C - loBoWoffset;\n\t}\n\telse {\n\t\tSapc = C + loBoWoffset;\n\t}\n\n\treturn Sapc * 100;\n}\n\n// Michelson  luminance contrast\n// the relation between the spread and the sum of the two luminances\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\n\n\nfunction contrastMichelson (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\tlet denom = (Y1 + Y2);\n\treturn denom === 0 ? 0 : (Y1 - Y2) / denom;\n}\n\n// Weber luminance contrast\n// The difference between the two luminances divided by the lower luminance\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\n\n\n// the darkest sRGB color above black is #000001 and this produces\n// a plain Weber contrast of ~45647.\n// So, setting the divide-by-zero result at 50000 is a reasonable\n// max clamp for the plain Weber\nconst max = 50000;\n\nfunction contrastWeber (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\treturn Y2 === 0 ? max : (Y1 - Y2) / Y2;\n}\n\n// CIE Lightness difference, as used by Google Material Design\n// Google HCT Tone is the same as CIE Lightness\n// https://material.io/blog/science-of-color-design\n\n\nfunction contrastLstar (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet L1 = get(color1, [lab, \"l\"]);\n\tlet L2 = get(color2, [lab, \"l\"]);\n\n\treturn Math.abs(L1 - L2);\n}\n\n// κ * ε  = 2^3 = 8\nconst ε$1 = 216/24389;  // 6^3/29^3 == (24/116)^3\nconst ε3 = 24/116;\nconst κ = 24389/27;   // 29^3/3^3\n\nlet white = WHITES.D65;\n\nvar lab_d65 = new ColorSpace({\n\tid: \"lab-d65\",\n\tname: \"Lab D65\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"L\"\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-125, 125]\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-125, 125]\n\t\t}\n\t},\n\n\t// Assuming XYZ is relative to D65, convert to CIE Lab\n\t// from CIE standard, which now defines these as a rational fraction\n\twhite,\n\n\tbase: XYZ_D65,\n\t// Convert D65-adapted XYZ to Lab\n\t//  CIE 15.3:2004 section 8.2.1.1\n\tfromBase (XYZ) {\n\t\t// compute xyz, which is XYZ scaled relative to reference white\n\t\tlet xyz = XYZ.map((value, i) => value / white[i]);\n\n\t\t// now compute f\n\t\tlet f = xyz.map(value => value > ε$1 ? Math.cbrt(value) : (κ * value + 16)/116);\n\n\t\treturn [\n\t\t\t(116 * f[1]) - 16, \t // L\n\t\t\t500 * (f[0] - f[1]), // a\n\t\t\t200 * (f[1] - f[2])  // b\n\t\t];\n\t},\n\t// Convert Lab to D65-adapted XYZ\n\t// Same result as CIE 15.3:2004 Appendix D although the derivation is different\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\ttoBase (Lab) {\n\t\t// compute f, starting with the luminance-related term\n\t\tlet f = [];\n\t\tf[1] = (Lab[0] + 16)/116;\n\t\tf[0] = Lab[1]/500 + f[1];\n\t\tf[2] = f[1] - Lab[2]/200;\n\n\t\t// compute xyz\n\t\tlet xyz = [\n\t\t\tf[0]   > ε3  ?  Math.pow(f[0], 3)            : (116*f[0]-16)/κ,\n\t\t\tLab[0] > 8   ?  Math.pow((Lab[0]+16)/116, 3) : Lab[0]/κ,\n\t\t\tf[2]   > ε3  ?  Math.pow(f[2], 3)            : (116*f[2]-16)/κ\n\t\t];\n\n\t\t// Compute XYZ by scaling xyz by reference white\n\t\treturn xyz.map((value, i) => value * white[i]);\n\t},\n\n\tformats: {\n\t\t\"lab-d65\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t}\n\t}\n});\n\n// Delta Phi Star perceptual lightness contrast\n// See https://github.com/Myndex/deltaphistar\n// The (difference between two Lstars each raised to phi) raised to (1/phi)\n// Symmetric, does not matter which is foreground and which is background\n\n\nconst phi = Math.pow(5, 0.5) * 0.5 + 0.5; // Math.phi can be used if Math.js\n\nfunction contrastDeltaPhi (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Lstr1 = get(color1, [lab_d65, \"l\"]);\n\tlet Lstr2 = get(color2, [lab_d65, \"l\"]);\n\n\tlet deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));\n\n\tlet contrast = Math.pow(deltaPhiStar, (1 / phi)) * Math.SQRT2 - 40;\n\n\treturn (contrast < 7.5) ? 0.0 : contrast ;\n}\n\nvar contrastMethods = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tcontrastAPCA: contrastAPCA,\n\tcontrastDeltaPhi: contrastDeltaPhi,\n\tcontrastLstar: contrastLstar,\n\tcontrastMichelson: contrastMichelson,\n\tcontrastWCAG21: contrastWCAG21,\n\tcontrastWeber: contrastWeber\n});\n\nfunction contrast (background, foreground, o = {}) {\n\tif (isString(o)) {\n\t\to = {algorithm: o};\n\t}\n\n\tlet {algorithm, ...rest} = o;\n\n\tif (!algorithm) {\n\t\tlet algorithms = Object.keys(contrastMethods).map(a => a.replace(/^contrast/, \"\")).join(\", \");\n\t\tthrow new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);\n\t}\n\n\tbackground = getColor(background);\n\tforeground = getColor(foreground);\n\n\tfor (let a in contrastMethods) {\n\t\tif (\"contrast\" + algorithm.toLowerCase() === a.toLowerCase()) {\n\t\t\treturn contrastMethods[a](background, foreground, rest);\n\t\t}\n\t}\n\n\tthrow new TypeError(`Unknown contrast algorithm: ${algorithm}`);\n}\n\n// Chromaticity coordinates\nfunction uv (color) {\n\tlet [X, Y, Z] = getAll(color, XYZ_D65);\n\tlet denom = X + 15 * Y + 3 * Z;\n\treturn [4 * X / denom, 9 * Y / denom];\n}\n\nfunction xy (color) {\n\tlet [X, Y, Z] = getAll(color, XYZ_D65);\n\tlet  sum = X + Y + Z;\n\treturn [X / sum, Y / sum];\n}\n\nfunction register$1 (Color) {\n\t// no setters, as lightness information is lost\n\t// when converting color to chromaticity\n\tObject.defineProperty(Color.prototype, \"uv\", {\n\t\tget () {\n\t\t\treturn uv(this);\n\t\t}\n\t});\n\n\tObject.defineProperty(Color.prototype, \"xy\", {\n\t\tget () {\n\t\t\treturn xy(this);\n\t\t}\n\t});\n}\n\nvar chromaticity = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tregister: register$1,\n\tuv: uv,\n\txy: xy\n});\n\nfunction deltaE76 (color, sample) {\n\treturn distance(color, sample, \"lab\");\n}\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// CMC by the Color Measurement Committee of the\n// Bradford Society of Dyeists and Colorsts, 1994.\n// Uses LCH rather than Lab,\n// with different weights for L, C and H differences\n// A nice increase in accuracy for modest increase in complexity\nconst π = Math.PI;\nconst d2r = π / 180;\n\nfunction deltaECMC (color, sample, {l = 2, c = 1} = {}) {\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE CMC.\n\n\t// This implementation assumes the parametric\n\t// weighting factors l:c are 2:1\n\t// which is typical for non-textile uses.\n\n\tlet [L1, a1, b1] = lab.from(color);\n\tlet [, C1, H1] = lch.from(lab, [L1, a1, b1]);\n\tlet [L2, a2, b2] = lab.from(sample);\n\tlet C2 = lch.from(lab, [L2, a2, b2])[1];\n\n\t// let [L1, a1, b1] = color.getAll(lab);\n\t// let C1 = color.get(\"lch.c\");\n\t// let H1 = color.get(\"lch.h\");\n\t// let [L2, a2, b2] = sample.getAll(lab);\n\t// let C2 = sample.get(\"lch.c\");\n\n\t// Check for negative Chroma,\n\t// which might happen through\n\t// direct user input of LCH values\n\n\tif (C1 < 0) {\n\t\tC1 = 0;\n\t}\n\tif (C2 < 0) {\n\t\tC2 = 0;\n\t}\n\n\t// we don't need H2 as ΔH is calculated from Δa, Δb and ΔC\n\n\t// Lightness and Chroma differences\n\t// These are (color - sample), unlike deltaE2000\n\tlet ΔL = L1 - L2;\n\tlet ΔC = C1 - C2;\n\n\tlet Δa = a1 - a2;\n\tlet Δb = b1 - b2;\n\n\t// weighted Hue difference, less for larger Chroma difference\n\n\tlet H2 = (Δa ** 2) + (Δb ** 2) - (ΔC ** 2);\n\t// due to roundoff error it is possible that, for zero a and b,\n\t// ΔC > Δa + Δb is 0, resulting in attempting\n\t// to take the square root of a negative number\n\n\t// trying instead the equation from Industrial Color Physics\n\t// By Georg A. Klein\n\n\t// let ΔH = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));\n\t// console.log({ΔH});\n\t// This gives the same result to 12 decimal places\n\t// except it sometimes NaNs when trying to root a negative number\n\n\t// let ΔH = Math.sqrt(H2); we never actually use the root, it gets squared again!!\n\n\t// positional corrections to the lack of uniformity of CIELAB\n\t// These are all trying to make JND ellipsoids more like spheres\n\n\t// SL Lightness crispening factor, depends entirely on L1 not L2\n\tlet SL = 0.511;\t// linear portion of the Y to L transfer function\n\tif (L1 >= 16) {\t// cubic portion\n\t\tSL = (0.040975 * L1) / (1 + 0.01765 * L1);\n\t}\n\n\t// SC Chroma factor\n\tlet SC = ((0.0638 * C1) / (1 + 0.0131 * C1)) + 0.638;\n\n\t// Cross term T for blue non-linearity\n\tlet T;\n\tif ( Number.isNaN(H1)) {\n\t\tH1 = 0;\n\t}\n\n\tif (H1 >= 164 && H1 <= 345) {\n\t\tT = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));\n\t}\n\telse {\n\t\tT = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));\n\t}\n\t// console.log({T});\n\n\t// SH Hue factor also depends on C1,\n\tlet C4 = Math.pow(C1, 4);\n\tlet F = Math.sqrt(C4 / (C4 + 1900));\n\tlet SH = SC * ((F * T) + 1 - F);\n\n\t// Finally calculate the deltaE, term by term as root sume of squares\n\tlet dE = (ΔL / (l * SL)) ** 2;\n\tdE += (ΔC / (c * SC)) ** 2;\n\tdE += (H2 / (SH ** 2));\n\t// dE += (ΔH / SH)  ** 2;\n\treturn Math.sqrt(dE);\n\t// Yay!!!\n}\n\nconst Yw$1 = 203;\t// absolute luminance of media white\n\nvar XYZ_Abs_D65 = new ColorSpace({\n// Absolute CIE XYZ, with a D65 whitepoint,\n// as used in most HDR colorspaces as a starting point.\n// SDR spaces are converted per BT.2048\n// so that diffuse, media white is 203 cd/m²\n\tid: \"xyz-abs-d65\",\n\tname: \"Absolute XYZ D65\",\n\tcoords: {\n\t\tx: {\n\t\t\trefRange: [0, 9504.7],\n\t\t\tname: \"Xa\",\n\t\t},\n\t\ty: {\n\t\t\trefRange: [0, 10000],\n\t\t\tname: \"Ya\",\n\t\t},\n\t\tz: {\n\t\t\trefRange: [0, 10888.3],\n\t\t\tname: \"Za\",\n\t\t}\n\t},\n\n\tbase: XYZ_D65,\n\tfromBase (XYZ) {\n\t\t// Make XYZ absolute, not relative to media white\n\t\t// Maximum luminance in PQ is 10,000 cd/m²\n\t\t// Relative XYZ has Y=1 for media white\n\t\treturn XYZ.map (v => Math.max(v * Yw$1, 0));\n\t},\n\ttoBase (AbsXYZ) {\n\t\t// Convert to media-white relative XYZ\n\t\treturn AbsXYZ.map(v => Math.max(v / Yw$1, 0));\n\t}\n});\n\nconst b$1 = 1.15;\nconst g = 0.66;\nconst n$1 = 2610 / (2 ** 14);\nconst ninv$1 = (2 ** 14) / 2610;\nconst c1$2 = 3424 / (2 ** 12);\nconst c2$2 = 2413 / (2 ** 7);\nconst c3$2 = 2392 / (2 ** 7);\nconst p = 1.7 * 2523 / (2 ** 5);\nconst pinv = (2 ** 5) / (1.7 * 2523);\nconst d = -0.56;\nconst d0 = 1.6295499532821566E-11;\n\nconst XYZtoCone_M = [\n\t[  0.41478972, 0.579999,  0.0146480 ],\n\t[ -0.2015100,  1.120649,  0.0531008 ],\n\t[ -0.0166008,  0.264800,  0.6684799 ]\n];\n// XYZtoCone_M inverted\nconst ConetoXYZ_M = [\n\t[  1.9242264357876067,  -1.0047923125953657,  0.037651404030618   ],\n\t[  0.35031676209499907,  0.7264811939316552, -0.06538442294808501 ],\n\t[ -0.09098281098284752, -0.3127282905230739,  1.5227665613052603  ]\n];\nconst ConetoIab_M = [\n\t[  0.5,       0.5,       0        ],\n\t[  3.524000, -4.066708,  0.542708 ],\n\t[  0.199076,  1.096799, -1.295875 ]\n];\n// ConetoIab_M inverted\nconst IabtoCone_M = [\n\t[ 1,                   0.1386050432715393,   0.05804731615611886 ],\n\t[ 0.9999999999999999, -0.1386050432715393,  -0.05804731615611886 ],\n\t[ 0.9999999999999998, -0.09601924202631895, -0.8118918960560388  ]\n];\n\nvar Jzazbz = new ColorSpace({\n\tid: \"jzazbz\",\n\tname: \"Jzazbz\",\n\tcoords: {\n\t\tjz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Jz\",\n\t\t},\n\t\taz: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t},\n\t\tbz: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t}\n\t},\n\n\tbase: XYZ_Abs_D65,\n\tfromBase (XYZ) {\n\t\t// First make XYZ absolute, not relative to media white\n\t\t// Maximum luminance in PQ is 10,000 cd/m²\n\t\t// Relative XYZ has Y=1 for media white\n\t\t// BT.2048 says media white Y=203 at PQ 58\n\n\t\tlet [ Xa, Ya, Za ] = XYZ;\n\n\t\t// modify X and Y\n\t\tlet Xm = (b$1 * Xa) - ((b$1 - 1) * Za);\n\t\tlet Ym = (g * Ya) - ((g - 1) * Xa);\n\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoCone_M, [ Xm, Ym, Za ]);\n\n\t\t// PQ-encode LMS\n\t\tlet PQLMS = LMS.map (function (val) {\n\t\t\tlet num = c1$2 + (c2$2 * ((val / 10000) ** n$1));\n\t\t\tlet denom = 1 + (c3$2 * ((val / 10000) ** n$1));\n\n\t\t\treturn (num / denom)  ** p;\n\t\t});\n\n\t\t// almost there, calculate Iz az bz\n\t\tlet [ Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);\n\t\t// console.log({Iz, az, bz});\n\n\t\tlet Jz = ((1 + d) * Iz) / (1 + (d * Iz)) - d0;\n\t\treturn [Jz, az, bz];\n\t},\n\ttoBase (Jzazbz) {\n\t\tlet [Jz, az, bz] = Jzazbz;\n\t\tlet Iz = (Jz + d0) / (1 + d - d * (Jz + d0));\n\n\t\t// bring into LMS cone domain\n\t\tlet PQLMS = multiplyMatrices(IabtoCone_M, [ Iz, az, bz ]);\n\n\t\t// convert from PQ-coded to linear-light\n\t\tlet LMS = PQLMS.map(function (val) {\n\t\t\tlet num = (c1$2 - (val ** pinv));\n\t\t\tlet denom = (c3$2 * (val ** pinv)) - c2$2;\n\t\t\tlet x = 10000 * ((num / denom) ** ninv$1);\n\n\t\t\treturn (x); \t// luminance relative to diffuse white, [0, 70 or so].\n\t\t});\n\n\t\t// modified abs XYZ\n\t\tlet [ Xm, Ym, Za ] = multiplyMatrices(ConetoXYZ_M, LMS);\n\n\t\t// restore standard D50 relative XYZ, relative to media white\n\t\tlet Xa = (Xm + ((b$1 -1) * Za)) / b$1;\n\t\tlet Ya = (Ym + ((g -1) * Xa)) / g;\n\t\treturn [ Xa, Ya, Za ];\n\t},\n\n\tformats: {\n\t\t// https://drafts.csswg.org/css-color-hdr/#Jzazbz\n\t\t\"color\": {}\n\t}\n});\n\nvar jzczhz = new ColorSpace({\n\tid: \"jzczhz\",\n\tname: \"JzCzHz\",\n\tcoords: {\n\t\tjz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Jz\",\n\t\t},\n\t\tcz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\thz: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t}\n\t},\n\n\tbase: Jzazbz,\n\tfromBase (jzazbz) {\n\t\t// Convert to polar form\n\t\tlet [Jz, az, bz] = jzazbz;\n\t\tlet hue;\n\t\tconst ε = 0.0002; // chromatic components much smaller than a,b\n\n\t\tif (Math.abs(az) < ε && Math.abs(bz) < ε) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(bz, az) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tJz, // Jz is still Jz\n\t\t\tMath.sqrt(az ** 2 + bz ** 2), // Chroma\n\t\t\tconstrain(hue) // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (jzczhz) {\n\t\t// Convert from polar form\n\t\t// debugger;\n\t\treturn [\n\t\t\tjzczhz[0], // Jz is still Jz\n\t\t\tjzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180), // az\n\t\t\tjzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180)  // bz\n\t\t];\n\t},\n\tformats: {\n\t\tcolor: {}\n\t},\n});\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// Uses JzCzHz, which has improved perceptual uniformity\n// and thus a simple Euclidean root-sum of ΔL² ΔC² ΔH²\n// gives good results.\n\nfunction deltaEJz (color, sample) {\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE in JzCzHz.\n\tlet [Jz1, Cz1, Hz1] = jzczhz.from(color);\n\tlet [Jz2, Cz2, Hz2] = jzczhz.from(sample);\n\n\t// Lightness and Chroma differences\n\t// sign does not matter as they are squared.\n\tlet ΔJ = Jz1 - Jz2;\n\tlet ΔC = Cz1 - Cz2;\n\n\t// length of chord for ΔH\n\tif ((Number.isNaN(Hz1)) && (Number.isNaN(Hz2))) {\n\t\t// both undefined hues\n\t\tHz1 = 0;\n\t\tHz2 = 0;\n\t}\n\telse if (Number.isNaN(Hz1)) {\n\t\t// one undefined, set to the defined hue\n\t\tHz1 = Hz2;\n\t}\n\telse if (Number.isNaN(Hz2)) {\n\t\tHz2 = Hz1;\n\t}\n\n\tlet Δh = Hz1 - Hz2;\n\tlet ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin((Δh / 2) * (Math.PI / 180));\n\n\treturn Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);\n}\n\nconst c1$1 = 3424 / 4096;\nconst c2$1 = 2413 / 128;\nconst c3$1 = 2392 / 128;\nconst m1 = 2610 / 16384;\nconst m2 = 2523 / 32;\nconst im1 = 16384 / 2610;\nconst im2 = 32 / 2523;\n\n// The matrix below includes the 4% crosstalk components\n// and is from the Dolby \"What is ICtCp\" paper\"\nconst XYZtoLMS_M$1 = [\n\t[ 0.3592,  0.6976, -0.0358],\n\t[-0.1922,  1.1004,  0.0755],\n\t[ 0.0070,  0.0749,  0.8434]\n];\n// linear-light Rec.2020 to LMS, again with crosstalk\n// rational terms from Jan Fröhlich,\n// Encoding High Dynamic Range andWide Color Gamut Imagery, p.97\n// and ITU-R BT.2124-0 p.2\n/*\nconst Rec2020toLMS_M = [\n\t[ 1688 / 4096,  2146 / 4096,   262 / 4096 ],\n\t[  683 / 4096,  2951 / 4096,   462 / 4096 ],\n\t[   99 / 4096,   309 / 4096,  3688 / 4096 ]\n];\n*/\n// this includes the Ebner LMS coefficients,\n// the rotation, and the scaling to [-0.5,0.5] range\n// rational terms from Fröhlich p.97\n// and ITU-R BT.2124-0 pp.2-3\nconst LMStoIPT_M = [\n\t[  2048 / 4096,   2048 / 4096,       0      ],\n\t[  6610 / 4096, -13613 / 4096,  7003 / 4096 ],\n\t[ 17933 / 4096, -17390 / 4096,  -543 / 4096 ]\n];\n\n// inverted matrices, calculated from the above\nconst IPTtoLMS_M = [\n\t[0.99998889656284013833, 0.00860505014728705821,  0.1110343715986164786 ],\n\t[1.0000111034371598616, -0.00860505014728705821, -0.1110343715986164786 ],\n\t[1.000032063391005412,   0.56004913547279000113, -0.32063391005412026469],\n];\n/*\nconst LMStoRec2020_M = [\n\t[ 3.4375568932814012112,   -2.5072112125095058195,   0.069654319228104608382],\n\t[-0.79142868665644156125,   1.9838372198740089874,  -0.19240853321756742626 ],\n\t[-0.025646662911506476363, -0.099240248643945566751, 1.1248869115554520431  ]\n];\n*/\nconst LMStoXYZ_M$1 = [\n\t[ 2.0701800566956135096,   -1.3264568761030210255,    0.20661600684785517081 ],\n\t[ 0.36498825003265747974,   0.68046736285223514102,  -0.045421753075853231409],\n\t[-0.049595542238932107896, -0.049421161186757487412,  1.1879959417328034394  ]\n];\n\n// Only the PQ form of ICtCp is implemented here. There is also an HLG form.\n// from Dolby, \"WHAT IS ICTCP?\"\n// https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf\n// and\n// Dolby, \"Perceptual Color Volume\n// Measuring the Distinguishable Colors of HDR and WCG Displays\"\n// https://professional.dolby.com/siteassets/pdfs/dolby-vision-measuring-perceptual-color-volume-v7.1.pdf\nvar ictcp = new ColorSpace({\n\tid: \"ictcp\",\n\tname: \"ICTCP\",\n\t// From BT.2100-2 page 7:\n\t// During production, signal values are expected to exceed the\n\t// range E′ = [0.0 : 1.0]. This provides processing headroom and avoids\n\t// signal degradation during cascaded processing. Such values of E′,\n\t// below 0.0 or exceeding 1.0, should not be clipped during production\n\t// and exchange.\n\t// Values below 0.0 should not be clipped in reference displays (even\n\t// though they represent “negative” light) to allow the black level of\n\t// the signal (LB) to be properly set using test signals known as “PLUGE”\n\tcoords: {\n\t\ti: {\n\t\t\trefRange: [0, 1],\t// Constant luminance,\n\t\t\tname: \"I\"\n\t\t},\n\t\tct: {\n\t\t\trefRange: [-0.5, 0.5],\t// Full BT.2020 gamut in range [-0.5, 0.5]\n\t\t\tname: \"CT\"\n\t\t},\n\t\tcp: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t\tname: \"CP\"\n\t\t}\n\t},\n\n\tbase: XYZ_Abs_D65,\n\tfromBase (XYZ) {\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);\n\n\t\treturn LMStoICtCp(LMS);\n\t},\n\ttoBase (ICtCp) {\n\t\tlet LMS = ICtCptoLMS(ICtCp);\n\n\t\treturn multiplyMatrices(LMStoXYZ_M$1, LMS);\n\t},\n\tformats: {\n\t\tcolor: {}\n\t},\n});\n\nfunction LMStoICtCp (LMS) {\n\t// apply the PQ EOTF\n\t// we can't ever be dividing by zero because of the \"1 +\" in the denominator\n\tlet PQLMS = LMS.map (function (val) {\n\t\tlet num = c1$1 + (c2$1 * ((val / 10000) ** m1));\n\t\tlet denom = 1 + (c3$1 * ((val / 10000) ** m1));\n\n\t\treturn (num / denom)  ** m2;\n\t});\n\n\t// LMS to IPT, with rotation for Y'C'bC'r compatibility\n\treturn multiplyMatrices(LMStoIPT_M, PQLMS);\n}\n\nfunction ICtCptoLMS (ICtCp) {\n\tlet PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);\n\n\t// From BT.2124-0 Annex 2 Conversion 3\n\tlet LMS = PQLMS.map (function (val) {\n\t\tlet num  = Math.max((val ** im2) - c1$1, 0);\n\t\tlet denom = (c2$1 - (c3$1 * (val ** im2)));\n\t\treturn 10000 * ((num / denom) ** im1);\n\t});\n\n\treturn LMS;\n}\n\n// Delta E in ICtCp space,\n// which the ITU calls Delta E ITP, which is shorter\n// formulae from ITU Rec. ITU-R BT.2124-0\n\nfunction deltaEITP (color, sample) {\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE in ICtCp\n\t// which is simply the Euclidean distance\n\n\tlet [ I1, T1, P1 ] = ictcp.from(color);\n\tlet [ I2, T2, P2 ] = ictcp.from(sample);\n\n\t// the 0.25 factor is to undo the encoding scaling in Ct\n\t// the 720 is so that 1 deltaE = 1 JND\n\t// per  ITU-R BT.2124-0 p.3\n\n\treturn 720 * Math.sqrt((I1 - I2) ** 2 + (0.25 * (T1 -T2) ** 2) + (P1 - P2) ** 2);\n}\n\n// Recalculated for consistent reference white\n// see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484\nconst XYZtoLMS_M = [\n\t[ 0.8190224432164319,    0.3619062562801221,   -0.12887378261216414 ],\n\t[ 0.0329836671980271,    0.9292868468965546,     0.03614466816999844 ],\n\t[ 0.048177199566046255,  0.26423952494422764,    0.6335478258136937  ]\n];\n// inverse of XYZtoLMS_M\nconst LMStoXYZ_M = [\n\t[  1.2268798733741557,  -0.5578149965554813,   0.28139105017721583],\n\t[ -0.04057576262431372,  1.1122868293970594,  -0.07171106666151701],\n\t[ -0.07637294974672142, -0.4214933239627914,   1.5869240244272418 ]\n];\nconst LMStoLab_M = [\n\t[  0.2104542553,   0.7936177850,  -0.0040720468 ],\n\t[  1.9779984951,  -2.4285922050,   0.4505937099 ],\n\t[  0.0259040371,   0.7827717662,  -0.8086757660 ]\n];\n// LMStoIab_M inverted\nconst LabtoLMS_M = [\n\t[ 0.99999999845051981432,  0.39633779217376785678,   0.21580375806075880339  ],\n\t[ 1.0000000088817607767,  -0.1055613423236563494,   -0.063854174771705903402 ],\n\t[ 1.0000000546724109177,  -0.089484182094965759684, -1.2914855378640917399   ]\n];\n\nvar OKLab = new ColorSpace({\n\tid: \"oklab\",\n    name: \"Oklab\",\n    coords: {\n\t\tl: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"L\"\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-0.4, 0.4]\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-0.4, 0.4]\n\t\t}\n    },\n\n\t// Note that XYZ is relative to D65\n  white: \"D65\",\n\tbase: XYZ_D65,\n\tfromBase (XYZ) {\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoLMS_M, XYZ);\n\n\t\t// non-linearity\n\t\tlet LMSg = LMS.map(val => Math.cbrt(val));\n\n\t\treturn multiplyMatrices(LMStoLab_M, LMSg);\n\n\t},\n\ttoBase (OKLab) {\n\t\t// move to LMS cone domain\n\t\tlet LMSg = multiplyMatrices(LabtoLMS_M, OKLab);\n\n\t\t// restore linearity\n\t\tlet LMS = LMSg.map(val => val ** 3);\n\n\t\treturn multiplyMatrices(LMStoXYZ_M, LMS);\n\t},\n\n\tformats: {\n\t\t\"oklab\": {\n\t\t\tcoords: [\"<percentage> | <number>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t}\n\t}\n});\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in CIE Lab\n\n\nfunction deltaEOK (color, sample) {\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaEOK, term by term as root sum of squares\n\tlet [L1, a1, b1] = OKLab.from(color);\n\tlet [L2, a2, b2] = OKLab.from(sample);\n\tlet ΔL = L1 - L2;\n\tlet Δa = a1 - a2;\n\tlet Δb = b1 - b2;\n\treturn Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);\n}\n\nvar deltaEMethods = {\n\tdeltaE76,\n\tdeltaECMC,\n\tdeltaE2000,\n\tdeltaEJz,\n\tdeltaEITP,\n\tdeltaEOK,\n};\n\nfunction deltaE (c1, c2, o = {}) {\n\tif (isString(o)) {\n\t\to = {method: o};\n\t}\n\n\tlet {method = defaults.deltaE, ...rest} = o;\n\n\tc1 = getColor(c1);\n\tc2 = getColor(c2);\n\n\tfor (let m in deltaEMethods) {\n\t\tif (\"deltae\" + method.toLowerCase() === m.toLowerCase()) {\n\t\t\treturn deltaEMethods[m](c1, c2, rest);\n\t\t}\n\t}\n\n\tthrow new TypeError(`Unknown deltaE method: ${method}`);\n}\n\nfunction lighten (color, amount = .25) {\n\tlet space = ColorSpace.get(\"oklch\", \"lch\");\n\tlet lightness = [space, \"l\"];\n\treturn set(color, lightness, l => l * (1 + amount));\n}\n\nfunction darken (color, amount = .25) {\n\tlet space = ColorSpace.get(\"oklch\", \"lch\");\n\tlet lightness = [space, \"l\"];\n\treturn set(color, lightness, l => l * (1 - amount));\n}\n\nvar variations = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdarken: darken,\n\tlighten: lighten\n});\n\n/**\n * Functions related to color interpolation\n */\n\n/**\n * Return an intermediate color between two colors\n * Signatures: mix(c1, c2, p, options)\n *             mix(c1, c2, options)\n *             mix(color)\n * @param {Color | string} c1 The first color\n * @param {Color | string} [c2] The second color\n * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2\n * @param {Object} [o={}]\n * @return {Color}\n */\nfunction mix (c1, c2, p = .5, o = {}) {\n\t[c1, c2] = [getColor(c1), getColor(c2)];\n\n\tif (type(p) === \"object\") {\n\t\t[p, o] = [.5, p];\n\t}\n\n\tlet {space, outputSpace, premultiplied} = o;\n\n\tlet r = range(c1, c2, {space, outputSpace, premultiplied});\n\treturn r(p);\n}\n\n/**\n *\n * @param {Color | string | Function} c1 The first color or a range\n * @param {Color | string} [c2] The second color if c1 is not a range\n * @param {Object} [options={}]\n * @return {Color[]}\n */\nfunction steps (c1, c2, options = {}) {\n\tlet colorRange;\n\n\tif (isRange(c1)) {\n\t\t// Tweaking existing range\n\t\t[colorRange, options] = [c1, c2];\n\t\t[c1, c2] = colorRange.rangeArgs.colors;\n\t}\n\n\tlet {\n\t\tmaxDeltaE, deltaEMethod,\n\t\tsteps = 2, maxSteps = 1000,\n\t\t...rangeOptions\n\t} = options;\n\n\tif (!colorRange) {\n\t\t[c1, c2] = [getColor(c1), getColor(c2)];\n\t\tcolorRange = range(c1, c2, rangeOptions);\n\t}\n\n\tlet totalDelta = deltaE(c1, c2);\n\tlet actualSteps = maxDeltaE > 0? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;\n\tlet ret = [];\n\n\tif (maxSteps !== undefined) {\n\t\tactualSteps = Math.min(actualSteps, maxSteps);\n\t}\n\n\tif (actualSteps === 1) {\n\t\tret = [{p: .5, color: colorRange(.5)}];\n\t}\n\telse {\n\t\tlet step = 1 / (actualSteps - 1);\n\t\tret = Array.from({length: actualSteps}, (_, i) => {\n\t\t\tlet p = i * step;\n\t\t\treturn {p, color: colorRange(p)};\n\t\t});\n\t}\n\n\tif (maxDeltaE > 0) {\n\t\t// Iterate over all stops and find max deltaE\n\t\tlet maxDelta = ret.reduce((acc, cur, i) => {\n\t\t\tif (i === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlet ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);\n\t\t\treturn Math.max(acc, ΔΕ);\n\t\t}, 0);\n\n\t\twhile (maxDelta > maxDeltaE) {\n\t\t\t// Insert intermediate stops and measure maxDelta again\n\t\t\t// We need to do this for all pairs, otherwise the midpoint shifts\n\t\t\tmaxDelta = 0;\n\n\t\t\tfor (let i = 1; (i < ret.length) && (ret.length < maxSteps); i++) {\n\t\t\t\tlet prev = ret[i - 1];\n\t\t\t\tlet cur = ret[i];\n\n\t\t\t\tlet p = (cur.p + prev.p) / 2;\n\t\t\t\tlet color = colorRange(p);\n\t\t\t\tmaxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));\n\t\t\t\tret.splice(i, 0, {p, color: colorRange(p)});\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ret.map(a => a.color);\n\n\treturn ret;\n}\n/**\n * Interpolate to color2 and return a function that takes a 0-1 percentage\n * @param {Color | string | Function} color1 The first color or an existing range\n * @param {Color | string} [color2] If color1 is a color, this is the second color\n * @param {Object} [options={}]\n * @returns {Function} A function that takes a 0-1 percentage and returns a color\n */\nfunction range (color1, color2, options = {}) {\n\tif (isRange(color1)) {\n\t\t// Tweaking existing range\n\t\tlet [r, options] = [color1, color2];\n\n\t\treturn range(...r.rangeArgs.colors, {...r.rangeArgs.options, ...options});\n\t}\n\n\tlet {space, outputSpace, progression, premultiplied} = options;\n\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\t// Make sure we're working on copies of these colors\n\tcolor1 = clone(color1);\n\tcolor2 = clone(color2);\n\n\tlet rangeArgs = {colors: [color1, color2], options};\n\n\tif (space) {\n\t\tspace = ColorSpace.get(space);\n\t}\n\telse {\n\t\tspace = ColorSpace.registry[defaults.interpolationSpace] || color1.space;\n\t}\n\n\toutputSpace = outputSpace? ColorSpace.get(outputSpace) : space;\n\n\tcolor1 = to(color1, space);\n\tcolor2 = to(color2, space);\n\n\t// Gamut map to avoid areas of flat color\n\tcolor1 = toGamut(color1);\n\tcolor2 = toGamut(color2);\n\n\t// Handle hue interpolation\n\t// See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840\n\tif (space.coords.h && space.coords.h.type === \"angle\") {\n\t\tlet arc = options.hue = options.hue || \"shorter\";\n\n\t\tlet hue = [space, \"h\"];\n\t\tlet [θ1, θ2] = [get(color1, hue), get(color2, hue)];\n\t\t[θ1, θ2] = adjust(arc, [θ1, θ2]);\n\t\tset(color1, hue, θ1);\n\t\tset(color2, hue, θ2);\n\t}\n\n\tif (premultiplied) {\n\t\t// not coping with polar spaces yet\n\t\tcolor1.coords = color1.coords.map(c => c * color1.alpha);\n\t\tcolor2.coords = color2.coords.map(c => c * color2.alpha);\n\t}\n\n\treturn Object.assign(p => {\n\t\tp = progression? progression(p) : p;\n\t\tlet coords = color1.coords.map((start, i) => {\n\t\t\tlet end = color2.coords[i];\n\t\t\treturn interpolate(start, end, p);\n\t\t});\n\n\t\tlet alpha = interpolate(color1.alpha, color2.alpha, p);\n\t\tlet ret = {space, coords, alpha};\n\n\t\tif (premultiplied) {\n\t\t\t// undo premultiplication\n\t\t\tret.coords = ret.coords.map(c => c / alpha);\n\t\t}\n\n\t\tif (outputSpace !== space) {\n\t\t\tret = to(ret, outputSpace);\n\t\t}\n\n\t\treturn ret;\n\t}, {\n\t\trangeArgs\n\t});\n}\nfunction isRange (val) {\n\treturn type(val) === \"function\" && !!val.rangeArgs;\n}\ndefaults.interpolationSpace = \"lab\";\n\nfunction register (Color) {\n\tColor.defineFunction(\"mix\", mix, {returns: \"color\"});\n\tColor.defineFunction(\"range\", range, {returns: \"function<color>\"});\n\tColor.defineFunction(\"steps\", steps, {returns: \"array<color>\"});\n}\n\nvar interpolation = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tisRange: isRange,\n\tmix: mix,\n\trange: range,\n\tregister: register,\n\tsteps: steps\n});\n\nvar HSL = new ColorSpace({\n\tid: \"hsl\",\n\tname: \"HSL\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\"\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\"\n\t\t},\n\t\tl: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Lightness\"\n\t\t}\n\t},\n\n\tbase: sRGB,\n\n\t// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB\n\tfromBase: rgb => {\n\t\tlet max = Math.max(...rgb);\n\t\tlet min = Math.min(...rgb);\n\t\tlet [r, g, b] = rgb;\n\t\tlet [h, s, l] = [NaN, 0, (min + max)/2];\n\t\tlet d = max - min;\n\n\t\tif (d !== 0) {\n\t\t\ts = (l === 0 || l === 1) ? 0 : (max - l) / Math.min(l, 1 - l);\n\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4;\n\t\t\t}\n\n\t\t\th = h * 60;\n\t\t}\n\n\t\treturn [h, s * 100, l * 100];\n\t},\n\n\t// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative\n\ttoBase: hsl => {\n\t\tlet [h, s, l] = hsl;\n\t\th = h % 360;\n\n\t\tif (h < 0) {\n\t\t\th += 360;\n\t\t}\n\n\t\ts /= 100;\n\t\tl /= 100;\n\n\t\tfunction f (n) {\n\t\t\tlet k = (n + h/30) % 12;\n\t\t\tlet a = s * Math.min(l, 1 - l);\n\t\t\treturn l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));\n\t\t}\n\n\t\treturn [f(0), f(8), f(4)];\n\t},\n\n\tformats: {\n\t\t\"hsl\": {\n\t\t\ttoGamut: true,\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage>\", \"<percentage>\"],\n\t\t},\n\t\t\"hsla\": {\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage>\", \"<percentage>\"],\n\t\t\tcommas: true,\n\t\t\tlastAlpha: true,\n\t\t}\n\t},\n});\n\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\n\nvar HSV = new ColorSpace({\n\tid: \"hsv\",\n\tname: \"HSV\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\"\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\"\n\t\t},\n\t\tv: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Value\"\n\t\t}\n\t},\n\n\tbase: HSL,\n\t// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n\tfromBase (hsl) {\n\t\tlet [h, s, l] = hsl;\n\t\ts /= 100;\n\t\tl /= 100;\n\n\t\tlet v = l + s * Math.min(l, 1 - l);\n\n\t\treturn [\n\t\t\th, // h is the same\n\t\t\tv === 0? 0 : 200 * (1 - l / v), // s\n\t\t\t100 * v\n\t\t];\n\t},\n\t// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n\ttoBase (hsv) {\n\t\tlet [h, s, v] = hsv;\n\n\t\ts /= 100;\n\t\tv /= 100;\n\n\t\tlet l = v * (1 - s/2);\n\n\t\treturn [\n\t\t\th, // h is the same\n\t\t\t(l === 0 || l === 1)? 0 : ((v - l) / Math.min(l, 1 - l)) * 100,\n\t\t\tl * 100\n\t\t];\n\t},\n\tformats: {\n\t\tcolor: {\n\t\t\ttoGamut: true,\n\t\t}\n\t}\n});\n\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\n\nvar hwb = new ColorSpace({\n\tid: \"hwb\",\n\tname: \"HWB\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\"\n\t\t},\n\t\tw: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Whiteness\"\n\t\t},\n\t\tb: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Blackness\"\n\t\t}\n\t},\n\n\tbase: HSV,\n\tfromBase (hsv) {\n\t\tlet [h, s, v] = hsv;\n\n\t\treturn [h, v * (100 - s) / 100, 100 - v];\n\t},\n\ttoBase (hwb) {\n\t\tlet [h, w, b] = hwb;\n\n\t\t// Now convert percentages to [0..1]\n\t\tw /= 100;\n\t\tb /= 100;\n\n\t\t// Achromatic check (white plus black >= 1)\n\t\tlet sum = w + b;\n\t\tif (sum >= 1) {\n\t\t\t let gray = w / sum;\n\t\t\t return [h, 0, gray * 100];\n\t\t}\n\n\t\tlet v = (1 - b);\n\t\tlet s = (v === 0) ? 0 : 1 - w / v;\n\t\treturn [h, s * 100, v * 100];\n\t},\n\n\tformats: {\n\t\t\"hwb\": {\n\t\t\ttoGamut: true,\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage>\", \"<percentage>\"],\n\t\t}\n\t}\n});\n\n// convert an array of linear-light a98-rgb values to CIE XYZ\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// has greater numerical precision than section 4.3.5.3 of\n// https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf\n// but the values below were calculated from first principles\n// from the chromaticity coordinates of R G B W\nconst toXYZ_M$2 = [\n\t[ 0.5766690429101305,   0.1855582379065463,   0.1882286462349947  ],\n\t[ 0.29734497525053605,  0.6273635662554661,   0.07529145849399788 ],\n\t[ 0.02703136138641234,  0.07068885253582723,  0.9913375368376388  ]\n];\n\nconst fromXYZ_M$2 = [\n\t[  2.0415879038107465,    -0.5650069742788596,   -0.34473135077832956 ],\n\t[ -0.9692436362808795,     1.8759675015077202,    0.04155505740717557 ],\n\t[  0.013444280632031142,  -0.11836239223101838,   1.0151749943912054  ]\n];\n\nvar A98Linear = new RGBColorSpace({\n\tid: \"a98rgb-linear\",\n\tname: \"Linear Adobe® 98 RGB compatible\",\n\twhite: \"D65\",\n\ttoXYZ_M: toXYZ_M$2,\n\tfromXYZ_M: fromXYZ_M$2\n});\n\nvar a98rgb = new RGBColorSpace({\n\tid: \"a98rgb\",\n\tname: \"Adobe® 98 RGB compatible\",\n\tbase: A98Linear,\n\ttoBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),\n\tfromBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"a98-rgb\"\n\t\t}\n\t},\n});\n\n// convert an array of  prophoto-rgb values to CIE XYZ\n// using  D50 (so no chromatic adaptation needed afterwards)\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\nconst toXYZ_M$1 = [\n\t[ 0.7977604896723027,  0.13518583717574031,  0.0313493495815248     ],\n\t[ 0.2880711282292934,  0.7118432178101014,   0.00008565396060525902 ],\n\t[ 0.0,                 0.0,                  0.8251046025104601     ]\n];\n\nconst fromXYZ_M$1 = [\n\t[  1.3457989731028281,  -0.25558010007997534,  -0.05110628506753401 ],\n\t[ -0.5446224939028347,   1.5082327413132781,    0.02053603239147973 ],\n\t[  0.0,                  0.0,                   1.2119675456389454  ]\n];\n\nvar ProPhotoLinear = new RGBColorSpace({\n\tid: \"prophoto-linear\",\n\tname: \"Linear ProPhoto\",\n\twhite: \"D50\",\n\tbase: XYZ_D50,\n\ttoXYZ_M: toXYZ_M$1,\n\tfromXYZ_M: fromXYZ_M$1\n});\n\nconst Et = 1/512;\nconst Et2 = 16/512;\n\nvar prophoto = new RGBColorSpace({\n\tid: \"prophoto\",\n\tname: \"ProPhoto\",\n\tbase: ProPhotoLinear,\n\ttoBase (RGB) {\n\t\t// Transfer curve is gamma 1.8 with a small linear portion\n\t\treturn RGB.map(v => v < Et2? v / 16 : v ** 1.8);\n\t},\n\tfromBase (RGB) {\n\t\treturn RGB.map(v => v >= Et? v ** (1/1.8) : 16 * v);\n\t},\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"prophoto-rgb\"\n\t\t}\n\t},\n});\n\nvar oklch = new ColorSpace({\n\tid: \"oklch\",\n\tname: \"Oklch\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Lightness\"\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 0.4],\n\t\t\tname: \"Chroma\"\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\"\n\t\t}\n\t},\n\twhite: \"D65\",\n\n\tbase: OKLab,\n\tfromBase (oklab) {\n\t\t// Convert to polar form\n\t\tlet [L, a, b] = oklab;\n\t\tlet h;\n\t\tconst ε = 0.0002; // chromatic components much smaller than a,b\n\n\t\tif (Math.abs(a) < ε && Math.abs(b) < ε) {\n\t\t\th = NaN;\n\t\t}\n\t\telse {\n\t\t\th = Math.atan2(b, a) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // OKLab L is still L\n\t\t\tMath.sqrt(a ** 2 + b ** 2), // Chroma\n\t\t\tconstrain(h) // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\t// Convert from polar form\n\ttoBase (oklch) {\n\t\tlet [L, C, h] = oklch;\n\t\tlet a, b;\n\n\t\t// check for NaN hue\n\t\tif (isNaN(h)) {\n\t\t\ta = 0;\n\t\t\tb = 0;\n\t\t}\n\t\telse {\n\t\t\ta = C * Math.cos(h * Math.PI / 180);\n\t\t\tb = C * Math.sin(h * Math.PI / 180);\n\t\t}\n\n\t\treturn [ L, a, b ];\n\t},\n\n\tformats: {\n\t\t\"oklch\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[0,1]\", \"<number> | <angle>\"],\n\t\t}\n\t}\n});\n\nconst Yw = 203;\t// absolute luminance of media white, cd/m²\nconst n = 2610 / (2 ** 14);\nconst ninv = (2 ** 14) / 2610;\nconst m = 2523 / (2 ** 5);\nconst minv = (2 ** 5) / 2523;\nconst c1 = 3424 / (2 ** 12);\nconst c2 = 2413 / (2 ** 7);\nconst c3 = 2392 / (2 ** 7);\n\nvar rec2100Pq = new RGBColorSpace({\n\tid: \"rec2100pq\",\n\tname: \"REC.2100-PQ\",\n\tbase: REC2020Linear,\n\ttoBase (RGB) {\n\t\t// given PQ encoded component in range [0, 1]\n\t\t// return media-white relative linear-light\n\t\treturn RGB.map(function (val) {\n\t\t\tlet x = ((Math.max(((val ** minv) - c1), 0) / (c2 - (c3 * (val ** minv)))) ** ninv);\n\t\t\treturn (x * 10000 / Yw); \t// luminance relative to diffuse white, [0, 70 or so].\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\t// given media-white relative linear-light\n\t\t// returnPQ encoded component in range [0, 1]\n\t\treturn RGB.map(function (val) {\n\t\t\tlet x = Math.max(val * Yw / 10000, 0); \t// absolute luminance of peak white is 10,000 cd/m².\n\t\t\tlet num = (c1 + (c2 * (x ** n)));\n\t\t\tlet denom = (1 + (c3 * (x ** n)));\n\n\t\t\treturn ((num / denom)  ** m);\n\t\t});\n\t},\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"rec2100-pq\"\n\t\t},\n\t},\n});\n\n// FIXME see https://github.com/LeaVerou/color.js/issues/190\n\nconst a = 0.17883277;\nconst b = 0.28466892; // 1 - (4 * a)\nconst c = 0.55991073; // 0.5 - a * Math.log(4 *a)\n\nconst scale = 3.7743;\t// Place 18% grey at HLG 0.38, so media white at 0.75\n\nvar rec2100Hlg = new RGBColorSpace({\n\tid: \"rec2100hlg\",\n\tcssid: \"rec2100-hlg\",\n\tname: \"REC.2100-HLG\",\n\treferred: \"scene\",\n\n\tbase: REC2020Linear,\n\ttoBase (RGB) {\n\t\t// given HLG encoded component in range [0, 1]\n\t\t// return media-white relative linear-light\n\t\treturn RGB.map(function (val) {\n\t\t\t// first the HLG EOTF\n\t\t\t// ITU-R BT.2390-10 p.30 section\n\t\t\t// 6.3 The hybrid log-gamma electro-optical transfer function (EOTF)\n\t\t\t// Then scale by 3 so media white is 1.0\n\t\t\tif (val <= 0.5) {\n\t\t\t\treturn (val ** 2) / 3 * scale;\n\t\t\t}\n\t\t\treturn ((Math.exp((val - c) / a) + b) / 12) * scale;\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\t// given media-white relative linear-light\n\t\t// where diffuse white is 1.0,\n\t\t// return HLG encoded component in range [0, 1]\n\t\treturn RGB.map(function (val) {\n\t\t\t// first scale to put linear-light media white at 1/3\n\t\t\tval /= scale;\n\t\t\t// now the HLG OETF\n\t\t\t// ITU-R BT.2390-10 p.23\n\t\t\t// 6.1 The hybrid log-gamma opto-electronic transfer function (OETF)\n\t\t\tif (val <= 1/12) {\n\t\t\t\treturn Math.sqrt( 3 * val);\n\t\t\t}\n\t\t\treturn a * Math.log(12 * val - b) + c;\n\t\t});\n\t},\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"rec2100-hlg\"\n\t\t},\n\t},\n});\n\nconst CATs = {};\n\nhooks.add(\"chromatic-adaptation-start\", env => {\n\tif (env.options.method) {\n\t\tenv.M = adapt(env.W1, env.W2, env.options.method);\n\t}\n});\n\nhooks.add(\"chromatic-adaptation-end\", env => {\n\tif (!env.M) {\n\t\tenv.M = adapt(env.W1, env.W2, env.options.method);\n\t}\n});\n\nfunction defineCAT ({id, toCone_M, fromCone_M}) {\n\t// Use id, toCone_M, fromCone_M like variables\n\tCATs[id] = arguments[0];\n}\nfunction adapt (W1, W2, id = \"Bradford\") {\n\t// adapt from a source whitepoint or illuminant W1\n\t// to a destination whitepoint or illuminant W2,\n\t// using the given chromatic adaptation transform (CAT)\n\t// debugger;\n\tlet method = CATs[id];\n\n\tlet [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);\n\tlet [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);\n\n\t// all practical illuminants have non-zero XYZ so no division by zero can occur below\n\tlet scale = [\n\t\t[ρd/ρs,    0,      0      ],\n\t\t[0,        γd/γs,  0      ],\n\t\t[0,        0,      βd/βs  ]\n\t];\n\t// console.log({scale});\n\n\tlet scaled_cone_M = multiplyMatrices(scale, method.toCone_M);\n\tlet adapt_M\t= multiplyMatrices(method.fromCone_M, scaled_cone_M);\n\t// console.log({scaled_cone_M, adapt_M});\n\treturn adapt_M;\n}\ndefineCAT({\n\tid: \"von Kries\",\n\ttoCone_M: [\n\t\t[  0.4002400,  0.7076000, -0.0808100 ],\n\t\t[ -0.2263000,  1.1653200,  0.0457000 ],\n\t\t[  0.0000000,  0.0000000,  0.9182200 ]\n\t],\n\tfromCone_M: [\n\t\t[  1.8599364, -1.1293816,  0.2198974 ],\n\t\t[  0.3611914,  0.6388125, -0.0000064 ],\n\t\t[  0.0000000,  0.0000000,  1.0890636 ]\n\t]\n});\n\ndefineCAT({\n\tid: \"Bradford\",\n\t// Convert an array of XYZ values in the range 0.0 - 1.0\n\t// to cone fundamentals\n\ttoCone_M: [\n\t\t[  0.8951000,  0.2664000, -0.1614000 ],\n\t\t[ -0.7502000,  1.7135000,  0.0367000 ],\n\t\t[  0.0389000, -0.0685000,  1.0296000 ]\n\t],\n\t// and back\n\tfromCone_M: [\n\t\t[  0.9869929, -0.1470543,  0.1599627 ],\n\t\t[  0.4323053,  0.5183603,  0.0492912 ],\n\t\t[ -0.0085287,  0.0400428,  0.9684867 ]\n\t]\n});\n\ndefineCAT({\n\tid: \"CAT02\",\n\t// with complete chromatic adaptation to W2, so D = 1.0\n\ttoCone_M: [\n\t\t[  0.7328000,  0.4296000, -0.1624000 ],\n\t\t[ -0.7036000,  1.6975000,  0.0061000 ],\n\t\t[  0.0030000,  0.0136000,  0.9834000 ]\n\t],\n\tfromCone_M: [\n\t\t[  1.0961238, -0.2788690,  0.1827452 ],\n\t\t[  0.4543690,  0.4735332,  0.0720978 ],\n\t\t[ -0.0096276, -0.0056980,  1.0153256 ]\n\t]\n});\n\ndefineCAT({\n\tid: \"CAT16\",\n\ttoCone_M: [\n\t\t[  0.401288,  0.650173, -0.051461 ],\n\t\t[ -0.250268,  1.204414,  0.045854 ],\n\t\t[ -0.002079,  0.048952,  0.953127 ]\n\t],\n\t// the extra precision is needed to avoid roundtripping errors\n\tfromCone_M: [\n\t\t[  1.862067855087233e+0, -1.011254630531685e+0,   1.491867754444518e-1 ],\n\t\t[  3.875265432361372e-1,  6.214474419314753e-1,  -8.973985167612518e-3 ],\n\t\t[ -1.584149884933386e-2, -3.412293802851557e-2,   1.049964436877850e+0 ]\n\t]\n});\n\nObject.assign(WHITES, {\n\t// whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer\n\t// all normalized to Y (luminance) = 1.00000\n\t// Illuminant A is a tungsten electric light, giving a very warm, orange light.\n\tA:  [1.09850, 1.00000, 0.35585],\n\n\t// Illuminant C was an early approximation to daylight: illuminant A with a blue filter.\n\tC:   [0.98074, 1.000000, 1.18232],\n\n\t// The daylight series of illuminants simulate natural daylight.\n\t// The color temperature (in degrees Kelvin/100) ranges from\n\t// cool, overcast daylight (D50) to bright, direct sunlight (D65).\n\tD55: [0.95682, 1.00000, 0.92149],\n\tD75: [0.94972, 1.00000, 1.22638],\n\n\t// Equal-energy illuminant, used in two-stage CAT16\n\tE:   [1.00000, 1.00000, 1.00000],\n\n\t// The F series of illuminants represent fluorescent lights\n\tF2:  [0.99186, 1.00000, 0.67393],\n\tF7:  [0.95041, 1.00000, 1.08747],\n\tF11: [1.00962, 1.00000, 0.64350],\n});\n\n// The ACES whitepoint\n// see TB-2018-001 Derivation of the ACES White Point CIE Chromaticity Coordinates\n// also https://github.com/ampas/aces-dev/blob/master/documents/python/TB-2018-001/aces_wp.py\n// Similar to D60\nWHITES.ACES = [0.32168/0.33767, 1.00000, (1.00000 - 0.32168 - 0.33767)/0.33767];\n\n// convert an array of linear-light ACEScc values to CIE XYZ\nconst toXYZ_M = [\n\t[  0.6624541811085053,   0.13400420645643313,  0.1561876870049078  ],\n\t[  0.27222871678091454,  0.6740817658111484,   0.05368951740793705 ],\n\t[ -0.005574649490394108, 0.004060733528982826, 1.0103391003129971  ]\n];\nconst fromXYZ_M = [\n\t[  1.6410233796943257,   -0.32480329418479,    -0.23642469523761225  ],\n\t[ -0.6636628587229829,    1.6153315916573379,   0.016756347685530137 ],\n\t[  0.011721894328375376, -0.008284441996237409, 0.9883948585390215   ]\n];\n\nvar ACEScg = new RGBColorSpace({\n\tid: \"acescg\",\n\tname: \"ACEScg\",\n\n\t// ACEScg – A scene-referred, linear-light encoding of ACES Data\n\t// https://docs.acescentral.com/specifications/acescg/\n\t// uses the AP1 primaries, see section 4.3.1 Color primaries\n\tcoords: {\n\t\tr: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Red\"\n\t\t},\n\t\tg: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Green\"\n\t\t},\n\t\tb: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Blue\"\n\t\t}\n\t},\n\n\treferred: \"scene\",\n\n\twhite: WHITES.ACES,\n\n\ttoXYZ_M,\n\tfromXYZ_M,\n\n\tformats: {\n\t\tcolor: {}\n\t},\n});\n\n// export default Color;\n\nconst ε = 2 ** -16;\n\n// the smallest value which, in the 32bit IEEE 754 float encoding,\n// decodes as a non-negative value\nconst ACES_min_nonzero = -0.35828683;\n\n// brightest encoded value, decodes to 65504\nconst ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52; // 1.468\n\nvar acescc = new RGBColorSpace({\n\tid: \"acescc\",\n\tname: \"ACEScc\",\n\t// see S-2014-003 ACEScc – A Logarithmic Encoding of ACES Data\n\t// https://docs.acescentral.com/specifications/acescc/\n\t// uses the AP1 primaries, see section 4.3.1 Color primaries\n\n\t// Appendix A: \"Very small ACES scene referred values below 7 1/4 stops\n\t// below 18% middle gray are encoded as negative ACEScc values.\n\t// These values should be preserved per the encoding in Section 4.4\n\t// so that all positive ACES values are maintained.\"\n\tcoords: {\n\t\tr: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Red\"\n\t\t},\n\t\tg: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Green\"\n\t\t},\n\t\tb: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Blue\"\n\t\t}\n\t},\n\treferred: \"scene\",\n\n\tbase: ACEScg,\n\t// from section 4.4.2 Decoding Function\n\ttoBase (RGB) {\n\t\tconst low = (9.72 - 15) / 17.52; // -0.3014\n\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val <= low) {\n\t\t\t\treturn (2 ** ((val * 17.52) - 9.72) - ε) * 2; // very low values, below -0.3014\n\t\t\t}\n\t\t\telse if (val < ACES_cc_max) {\n\t\t\t\treturn 2 ** ((val * 17.52) - 9.72);\n\t\t\t}\n\t\t\telse { // val >= ACES_cc_max\n\t\t\t\treturn 65504;\n\t\t\t}\n\t\t});\n\t},\n\n\t// Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function\n\tfromBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val <= 0) {\n\t\t\t\treturn (Math.log2(ε) + 9.72) / 17.52; // -0.3584\n\t\t\t}\n\t\t\telse if (val < ε) {\n\t\t\t\treturn  (Math.log2(ε + val * 0.5) + 9.72) / 17.52;\n\t\t\t}\n\t\t\telse { // val >= ε\n\t\t\t\treturn  (Math.log2(val) + 9.72) / 17.52;\n\t\t\t}\n\t\t});\n\t},\n\t// encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]\n\t// encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]\n\tformats: {\n\t\tcolor: {}\n\t}\n});\n\nvar spaces = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tA98RGB: a98rgb,\n\tA98RGB_Linear: A98Linear,\n\tACEScc: acescc,\n\tACEScg: ACEScg,\n\tHSL: HSL,\n\tHSV: HSV,\n\tHWB: hwb,\n\tICTCP: ictcp,\n\tJzCzHz: jzczhz,\n\tJzazbz: Jzazbz,\n\tLCH: lch,\n\tLab: lab,\n\tLab_D65: lab_d65,\n\tOKLCH: oklch,\n\tOKLab: OKLab,\n\tP3: P3,\n\tP3_Linear: P3Linear,\n\tProPhoto: prophoto,\n\tProPhoto_Linear: ProPhotoLinear,\n\tREC_2020: REC2020,\n\tREC_2020_Linear: REC2020Linear,\n\tREC_2100_HLG: rec2100Hlg,\n\tREC_2100_PQ: rec2100Pq,\n\tXYZ_ABS_D65: XYZ_Abs_D65,\n\tXYZ_D50: XYZ_D50,\n\tXYZ_D65: XYZ_D65,\n\tsRGB: sRGB,\n\tsRGB_Linear: sRGBLinear\n});\n\n/**\n * Class that represents a color\n */\nclass Color {\n\t/**\n\t * Creates an instance of Color.\n\t * Signatures:\n\t * - `new Color(stringToParse)`\n\t * - `new Color(otherColor)`\n\t * - `new Color({space, coords, alpha})`\n\t * - `new Color(space, coords, alpha)`\n\t * - `new Color(spaceId, coords, alpha)`\n\t */\n\tconstructor (...args) {\n\t\tlet color;\n\n\t\tif (args.length === 1) {\n\t\t\tcolor = getColor(args[0]);\n\t\t}\n\n\t\tlet space, coords, alpha;\n\n\t\tif (color) {\n\t\t\tspace = color.space || color.spaceId;\n\t\t\tcoords = color.coords;\n\t\t\talpha = color.alpha;\n\t\t}\n\t\telse {\n\t\t\t// default signature new Color(ColorSpace, array [, alpha])\n\t\t\t[space, coords, alpha] = args;\n\t\t}\n\n\t\tObject.defineProperty(this, \"space\", {\n\t\t\tvalue: ColorSpace.get(space),\n\t\t\twritable: false,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true, // see note in https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver\n\t\t});\n\t\tthis.coords = coords? coords.slice() : [0, 0, 0];\n\t\tthis.alpha = alpha < 1? alpha : 1; // this also deals with NaN etc\n\n\t\t// Convert \"NaN\" to NaN\n\t\tfor (let i = 0; i < this.coords.length; i++) {\n\t\t\tif (this.coords[i] === \"NaN\") {\n\t\t\t\tthis.coords[i] = NaN;\n\t\t\t}\n\t\t}\n\n\t\t// Define getters and setters for each coordinate\n\t\tfor (let id in this.space.coords) {\n\t\t\tObject.defineProperty(this, id, {\n\t\t\t\tget: () => this.get(id),\n\t\t\t\tset: value => this.set(id, value)\n\t\t\t});\n\t\t}\n\t}\n\n\tget spaceId () {\n\t\treturn this.space.id;\n\t}\n\n\tclone () {\n\t\treturn new Color(this.space, this.coords, this.alpha);\n\t}\n\n\ttoJSON () {\n\t\treturn {\n\t\t\tspaceId: this.spaceId,\n\t\t\tcoords: this.coords,\n\t\t\talpha: this.alpha\n\t\t};\n\t}\n\n\tdisplay (...args) {\n\t\tlet ret = display(this, ...args);\n\n\t\t// Convert color object to Color instance\n\t\tret.color = new Color(ret.color);\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Get a color from the argument passed\n\t * Basically gets us the same result as new Color(color) but doesn't clone an existing color object\n\t */\n\tstatic get (color, ...args) {\n\t\tif (color instanceof Color) {\n\t\t\treturn color;\n\t\t}\n\n\t\treturn new Color(color, ...args);\n\t}\n\n\tstatic defineFunction (name, code, o = code) {\n\t\tlet {instance = true, returns} = o;\n\n\t\tlet func = function (...args) {\n\t\t\tlet ret = code(...args);\n\n\t\t\tif (returns === \"color\") {\n\t\t\t\tret = Color.get(ret);\n\t\t\t}\n\t\t\telse if (returns === \"function<color>\") {\n\t\t\t\tlet f = ret;\n\t\t\t\tret = function (...args) {\n\t\t\t\t\tlet ret = f(...args);\n\t\t\t\t\treturn Color.get(ret);\n\t\t\t\t};\n\t\t\t\t// Copy any function metadata\n\t\t\t\tObject.assign(ret, f);\n\t\t\t}\n\t\t\telse if (returns === \"array<color>\") {\n\t\t\t\tret = ret.map(c => Color.get(c));\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t};\n\n\t\tif (!(name in Color)) {\n\t\t\tColor[name] = func;\n\t\t}\n\n\t\tif (instance) {\n\t\t\tColor.prototype[name] = function (...args) {\n\t\t\t\treturn func(this, ...args);\n\t\t\t};\n\t\t}\n\t}\n\n\tstatic defineFunctions (o) {\n\t\tfor (let name in o) {\n\t\t\tColor.defineFunction(name, o[name], o[name]);\n\t\t}\n\t}\n\n\tstatic extend (exports) {\n\t\tif (exports.register) {\n\t\t\texports.register(Color);\n\t\t}\n\t\telse {\n\t\t\t// No register method, just add the module's functions\n\t\t\tfor (let name in exports) {\n\t\t\t\tColor.defineFunction(name, exports[name]);\n\t\t\t}\n\t\t}\n\t}\n}\nColor.defineFunctions({\n\tget,\n\tgetAll,\n\tset,\n\tsetAll,\n\tto,\n\tequals,\n\tinGamut,\n\ttoGamut,\n\tdistance,\n\ttoString: serialize,\n});\n\nObject.assign(Color, {\n\tutil,\n\thooks,\n\tWHITES,\n\tSpace: ColorSpace,\n\tspaces: ColorSpace.registry,\n\tparse,\n\n\t// Global defaults one may want to configure\n\tdefaults\n});\n\nfor (let key of Object.keys(spaces)) {\n\tColorSpace.register(spaces[key]);\n}\n\n/**\n * This plugin defines getters and setters for color[spaceId]\n * e.g. color.lch on *any* color gives us the lch coords\n */\n\n// Add space accessors to existing color spaces\nfor (let id in ColorSpace.registry) {\n\taddSpaceAccessors(id, ColorSpace.registry[id]);\n}\n\n// Add space accessors to color spaces not yet created\nhooks.add(\"colorspace-init-end\", space => {\n\taddSpaceAccessors(space.id, space);\n\tspace.aliases?.forEach(alias => {\n\t\taddSpaceAccessors(alias, space);\n\t});\n});\n\nfunction addSpaceAccessors (id, space) {\n\t// Coordinates can be looked up by both id and name\n\tObject.keys(space.coords);\n\tObject.values(space.coords).map(c => c.name);\n\n\n\tlet propId = id.replace(/-/g, \"_\");\n\n\tObject.defineProperty(Color.prototype, propId, {\n\t\t// Convert coords to coords in another colorspace and return them\n\t\t// Source colorspace: this.spaceId\n\t\t// Target colorspace: id\n\t\tget () {\n\t\t\tlet ret = this.getAll(id);\n\n\t\t\tif (typeof Proxy === \"undefined\") {\n\t\t\t\t// If proxies are not supported, just return a static array\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Enable color.spaceId.coordName syntax\n\t\t\treturn new Proxy(ret, {\n\t\t\t\thas: (obj, property) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tColorSpace.resolveCoord([space, property]);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {}\n\n\t\t\t\t\treturn Reflect.has(obj, property);\n\t\t\t\t},\n\t\t\t\tget: (obj, property, receiver) => {\n\t\t\t\t\tif (property && typeof property !== \"symbol\" && !(property in obj)) {\n\t\t\t\t\t\tlet {index} = ColorSpace.resolveCoord([space, property]);\n\n\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\treturn obj[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.get(obj, property, receiver);\n\t\t\t\t},\n\t\t\t\tset: (obj, property, value, receiver) => {\n\t\t\t\t\tif (property && typeof property !== \"symbol\" && !(property in obj) || property >= 0) {\n\t\t\t\t\t\tlet {index} = ColorSpace.resolveCoord([space, property]);\n\n\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\tobj[index] = value;\n\n\t\t\t\t\t\t\t// Update color.coords\n\t\t\t\t\t\t\tthis.setAll(id, obj);\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.set(obj, property, value, receiver);\n\t\t\t\t},\n\t\t\t});\n\t\t},\n\t\t// Convert coords in another colorspace to internal coords and set them\n\t\t// Target colorspace: this.spaceId\n\t\t// Source colorspace: id\n\t\tset (coords) {\n\t\t\tthis.setAll(id, coords);\n\t\t},\n\t\tconfigurable: true,\n\t\tenumerable: true\n\t});\n}\n\n// Import all modules of Color.js\n\nColor.extend(deltaEMethods);\nColor.extend({deltaE});\nObject.assign(Color, {deltaEMethods});\nColor.extend(variations);\nColor.extend({contrast});\nColor.extend(chromaticity);\nColor.extend(luminance);\nColor.extend(interpolation);\nColor.extend(contrastMethods);\n\n\n//# sourceMappingURL=color.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29sb3Jqcy5pby9kaXN0L2NvbG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsaUJBQWlCLEVBQUUsbUJBQW1CLEVBQUUsZUFBZTtBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQix5Q0FBeUMscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG1CQUFtQixlQUFlLElBQUk7QUFDdEM7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxRQUFRO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELE1BQU0sTUFBTSxNQUFNO0FBQzVFOztBQUVBO0FBQ0Esa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVyxHQUFHLFFBQVE7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLHFCQUFxQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCxJQUFJO0FBQ2xFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QixNQUFNLHdCQUF3QixXQUFXLHlCQUF5QixxQ0FBcUM7QUFDcEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsUUFBUSxJQUFJO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFNBQVMsNEJBQTRCOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVTtBQUNoQixNQUFNLFVBQVU7QUFDaEIsTUFBTSxVQUFVO0FBQ2hCLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHLDJCQUEyQixrQkFBa0I7QUFDNUQsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsY0FBYztBQUNkO0FBQ0Esc0JBQXNCLE1BQU0sSUFBSTtBQUNoQyxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTs7QUFFQSw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWMsa0JBQWtCLFdBQVcsS0FBSyxLQUFLO0FBQ3BGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTLHNCQUFzQixVQUFVO0FBQ3BELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxjQUFjO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sY0FBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyx3QkFBd0IsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsK0NBQStDLGVBQWUsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLDBCQUEwQixzREFBc0QsSUFBSTtBQUNwRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0EsNEJBQTRCLFNBQVMsSUFBSTtBQUN6QztBQUNBOztBQUVBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsMkJBQTJCLEVBQUUsTUFBTTtBQUMzRixXQUFXLEtBQUssR0FBRyxxQ0FBcUMsRUFBRSxTQUFTO0FBQ25FOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQSxXQUFXO0FBQ1g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELCtCQUErQixNQUFNLGtIQUFrSDtBQUNyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxFQUFFLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZSxrQkFBa0I7QUFDN0MsV0FBVyxHQUFHLFdBQVc7QUFDekIsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsMEJBQTBCLDRDQUE0QyxJQUFJO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGlEQUFpRDtBQUNqRDtBQUNBLE9BQU87QUFDUDs7QUFFQSxNQUFNLG9CQUFvQjs7QUFFMUI7QUFDQTtBQUNBLGdHQUFnRyxXQUFXO0FBQzNHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsVUFBVTtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLGNBQWMsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVzs7QUFFN0I7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBLE9BQU87QUFDUDs7QUFFQSxNQUFNLG1DQUFtQzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxPQUFPO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLEtBQUs7QUFDeEIsWUFBWTtBQUNaO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLG1DQUFtQzs7QUFFekMsd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVEsV0FBVztBQUM5QixZQUFZO0FBQ1o7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSxXQUFXO0FBQ1gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUSxXQUFXO0FBQzlCLGFBQWEsVUFBVTtBQUN2QjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLG1DQUFtQztBQUMxRTs7QUFFQSxNQUFNLGdEQUFnRDs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRCx1Q0FBdUMsMkJBQTJCO0FBQ2xFLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRixDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTs7QUFFdkI7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU8sMEJBQTBCOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxPQUFPOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxPQUFPOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUU0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Rhbi1ibG9nLy4vbm9kZV9tb2R1bGVzL2NvbG9yanMuaW8vZGlzdC9jb2xvci5qcz83OTgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgaXMgbSB4IG4uIEIgaXMgbiB4IHAuIHByb2R1Y3QgaXMgbSB4IHAuXG5mdW5jdGlvbiBtdWx0aXBseU1hdHJpY2VzIChBLCBCKSB7XG5cdGxldCBtID0gQS5sZW5ndGg7XG5cblx0aWYgKCFBcnJheS5pc0FycmF5KEFbMF0pKSB7XG5cdFx0Ly8gQSBpcyB2ZWN0b3IsIGNvbnZlcnQgdG8gW1thLCBiLCBjLCAuLi5dXVxuXHRcdEEgPSBbQV07XG5cdH1cblxuXHRpZiAoIUFycmF5LmlzQXJyYXkoQlswXSkpIHtcblx0XHQvLyBCIGlzIHZlY3RvciwgY29udmVydCB0byBbW2FdLCBbYl0sIFtjXSwgLi4uXV1cblx0XHRCID0gQi5tYXAoeCA9PiBbeF0pO1xuXHR9XG5cblx0bGV0IHAgPSBCWzBdLmxlbmd0aDtcblx0bGV0IEJfY29scyA9IEJbMF0ubWFwKChfLCBpKSA9PiBCLm1hcCh4ID0+IHhbaV0pKTsgLy8gdHJhbnNwb3NlIEJcblx0bGV0IHByb2R1Y3QgPSBBLm1hcChyb3cgPT4gQl9jb2xzLm1hcChjb2wgPT4ge1xuXHRcdGxldCByZXQgPSAwO1xuXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHJvdykpIHtcblx0XHRcdGZvciAobGV0IGMgb2YgY29sKSB7XG5cdFx0XHRcdHJldCArPSByb3cgKiBjO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGk9MDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmV0ICs9IHJvd1tpXSAqIChjb2xbaV0gfHwgMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSkpO1xuXG5cdGlmIChtID09PSAxKSB7XG5cdFx0cHJvZHVjdCA9IHByb2R1Y3RbMF07IC8vIEF2b2lkIFtbYSwgYiwgYywgLi4uXV1cblx0fVxuXG5cdGlmIChwID09PSAxKSB7XG5cdFx0cmV0dXJuIHByb2R1Y3QubWFwKHggPT4geFswXSk7IC8vIEF2b2lkIFtbYV0sIFtiXSwgW2NdLCAuLi5dXVxuXHR9XG5cblx0cmV0dXJuIHByb2R1Y3Q7XG59XG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9uc1xuICovXG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIChpbmNsdWRpbmcgYSBTdHJpbmcgb2JqZWN0KVxuICogQHBhcmFtIHsqfSBzdHIgLSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nIChzdHIpIHtcblx0cmV0dXJuIHR5cGUoc3RyKSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGludGVybmFsIEphdmFTY3JpcHQgW1tDbGFzc11dIG9mIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gbyAtIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0eXBlIChvKSB7XG5cdGxldCBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG5cblx0cmV0dXJuIChzdHIubWF0Y2goL15cXFtvYmplY3RcXHMrKC4qPylcXF0kLylbMV0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBSb3VuZCBhIG51bWJlciB0byBhIGNlcnRhaW4gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xuICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gcHJlY2lzaW9uIC0gTnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xuICovXG5mdW5jdGlvbiB0b1ByZWNpc2lvbiAobiwgcHJlY2lzaW9uKSB7XG5cdG4gPSArbjtcblx0cHJlY2lzaW9uID0gK3ByZWNpc2lvbjtcblx0bGV0IGludGVnZXJMZW5ndGggPSAoTWF0aC5mbG9vcihuKSArIFwiXCIpLmxlbmd0aDtcblxuXHRpZiAocHJlY2lzaW9uID4gaW50ZWdlckxlbmd0aCkge1xuXHRcdHJldHVybiArbi50b0ZpeGVkKHByZWNpc2lvbiAtIGludGVnZXJMZW5ndGgpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGxldCBwMTAgPSAxMCAqKiAoaW50ZWdlckxlbmd0aCAtIHByZWNpc2lvbik7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQobiAvIHAxMCkgKiBwMTA7XG5cdH1cbn1cblxuLyoqXG4qIFBhcnNlIGEgQ1NTIGZ1bmN0aW9uLCByZWdhcmRsZXNzIG9mIGl0cyBuYW1lIGFuZCBhcmd1bWVudHNcbiogQHBhcmFtIFN0cmluZyBzdHIgU3RyaW5nIHRvIHBhcnNlXG4qIEByZXR1cm4ge3tuYW1lLCBhcmdzLCByYXdBcmdzfX1cbiovXG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpO1xuXG5cdGNvbnN0IGlzRnVuY3Rpb25SZWdleCA9IC9eKFthLXpdKylcXCgoLis/KVxcKSQvaTtcblx0Y29uc3QgaXNOdW1iZXJSZWdleCA9IC9eLT9bXFxkLl0rJC87XG5cdGxldCBwYXJ0cyA9IHN0ci5tYXRjaChpc0Z1bmN0aW9uUmVnZXgpO1xuXG5cdGlmIChwYXJ0cykge1xuXHRcdC8vIEl0IGlzIGEgZnVuY3Rpb24sIHBhcnNlIGFyZ3Ncblx0XHRsZXQgYXJncyA9IFtdO1xuXHRcdHBhcnRzWzJdLnJlcGxhY2UoL1xcLz9cXHMqKFstXFx3Ll0rKD86JXxkZWcpPykvZywgKCQwLCBhcmcpID0+IHtcblx0XHRcdGlmICgvJSQvLnRlc3QoYXJnKSkge1xuXHRcdFx0XHQvLyBDb252ZXJ0IHBlcmNlbnRhZ2VzIHRvIDAtMSBudW1iZXJzXG5cdFx0XHRcdGFyZyA9IG5ldyBOdW1iZXIoYXJnLnNsaWNlKDAsIC0xKSAvIDEwMCk7XG5cdFx0XHRcdGFyZy50eXBlID0gXCI8cGVyY2VudGFnZT5cIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKC9kZWckLy50ZXN0KGFyZykpIHtcblx0XHRcdFx0Ly8gRHJvcCBkZWcgZnJvbSBkZWdyZWVzIGFuZCBjb252ZXJ0IHRvIG51bWJlclxuXHRcdFx0XHQvLyBUT0RPIGhhbmRsZSBvdGhlciB1bml0cyB0b29cblx0XHRcdFx0YXJnID0gbmV3IE51bWJlcigrYXJnLnNsaWNlKDAsIC0zKSk7XG5cdFx0XHRcdGFyZy50eXBlID0gXCI8YW5nbGU+XCI7XG5cdFx0XHRcdGFyZy51bml0ID0gXCJkZWdcIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlzTnVtYmVyUmVnZXgudGVzdChhcmcpKSB7XG5cdFx0XHRcdC8vIENvbnZlcnQgbnVtZXJpY2FsIGFyZ3MgdG8gbnVtYmVyc1xuXHRcdFx0XHRhcmcgPSBuZXcgTnVtYmVyKGFyZyk7XG5cdFx0XHRcdGFyZy50eXBlID0gXCI8bnVtYmVyPlwiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJDAuc3RhcnRzV2l0aChcIi9cIikpIHtcblx0XHRcdFx0Ly8gSXQncyBhbHBoYVxuXHRcdFx0XHRhcmcgPSBhcmcgaW5zdGFuY2VvZiBOdW1iZXI/IGFyZyA6IG5ldyBOdW1iZXIoYXJnKTtcblx0XHRcdFx0YXJnLmFscGhhID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YXJncy5wdXNoKGFyZyk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogcGFydHNbMV0udG9Mb3dlckNhc2UoKSxcblx0XHRcdHJhd05hbWU6IHBhcnRzWzFdLFxuXHRcdFx0cmF3QXJnczogcGFydHNbMl0sXG5cdFx0XHQvLyBBbiBhcmd1bWVudCBjb3VsZCBiZSAoYXMgb2YgY3NzLWNvbG9yLTQpOlxuXHRcdFx0Ly8gYSBudW1iZXIsIHBlcmNlbnRhZ2UsIGRlZ3JlZXMgKGh1ZSksIGlkZW50IChpbiBjb2xvcigpKVxuXHRcdFx0YXJnc1xuXHRcdH07XG5cdH1cbn1cblxuZnVuY3Rpb24gbGFzdCAoYXJyKSB7XG5cdHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSAoc3RhcnQsIGVuZCwgcCkge1xuXHRpZiAoaXNOYU4oc3RhcnQpKSB7XG5cdFx0cmV0dXJuIGVuZDtcblx0fVxuXG5cdGlmIChpc05hTihlbmQpKSB7XG5cdFx0cmV0dXJuIHN0YXJ0O1xuXHR9XG5cblx0cmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHA7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlSW52IChzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRyZXR1cm4gKHZhbHVlIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KTtcbn1cblxuZnVuY3Rpb24gbWFwUmFuZ2UgKGZyb20sIHRvLCB2YWx1ZSkge1xuXHRyZXR1cm4gaW50ZXJwb2xhdGUodG9bMF0sIHRvWzFdLCBpbnRlcnBvbGF0ZUludihmcm9tWzBdLCBmcm9tWzFdLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvb3JkR3JhbW1hciAoY29vcmRHcmFtbWFycykge1xuXHRyZXR1cm4gY29vcmRHcmFtbWFycy5tYXAoY29vcmRHcmFtbWFyID0+IHtcblx0XHRyZXR1cm4gY29vcmRHcmFtbWFyLnNwbGl0KFwifFwiKS5tYXAodHlwZSA9PiB7XG5cdFx0XHR0eXBlID0gdHlwZS50cmltKCk7XG5cdFx0XHRsZXQgcmFuZ2UgPSB0eXBlLm1hdGNoKC9eKDxbYS16XSs+KVxcWygtP1suXFxkXSspLFxccyooLT9bLlxcZF0rKVxcXT8kLyk7XG5cblx0XHRcdGlmIChyYW5nZSkge1xuXHRcdFx0XHRsZXQgcmV0ID0gbmV3IFN0cmluZyhyYW5nZVsxXSk7XG5cdFx0XHRcdHJldC5yYW5nZSA9IFsrcmFuZ2VbMl0sICtyYW5nZVszXV07XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0eXBlO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxudmFyIHV0aWwgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0aW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuXHRpbnRlcnBvbGF0ZUludjogaW50ZXJwb2xhdGVJbnYsXG5cdGlzU3RyaW5nOiBpc1N0cmluZyxcblx0bGFzdDogbGFzdCxcblx0bWFwUmFuZ2U6IG1hcFJhbmdlLFxuXHRtdWx0aXBseU1hdHJpY2VzOiBtdWx0aXBseU1hdHJpY2VzLFxuXHRwYXJzZUNvb3JkR3JhbW1hcjogcGFyc2VDb29yZEdyYW1tYXIsXG5cdHBhcnNlRnVuY3Rpb246IHBhcnNlRnVuY3Rpb24sXG5cdHRvUHJlY2lzaW9uOiB0b1ByZWNpc2lvbixcblx0dHlwZTogdHlwZVxufSk7XG5cbi8qKlxuICogQSBjbGFzcyBmb3IgYWRkaW5nIGRlZXAgZXh0ZW5zaWJpbGl0eSB0byBhbnkgcGllY2Ugb2YgSlMgY29kZVxuICovXG5jbGFzcyBIb29rcyB7XG5cdGFkZCAobmFtZSwgY2FsbGJhY2ssIGZpcnN0KSB7XG5cdFx0aWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gIT0gXCJzdHJpbmdcIikge1xuXHRcdFx0Ly8gTXVsdGlwbGUgaG9va3Ncblx0XHRcdGZvciAodmFyIG5hbWUgaW4gYXJndW1lbnRzWzBdKSB7XG5cdFx0XHRcdHRoaXMuYWRkKG5hbWUsIGFyZ3VtZW50c1swXVtuYW1lXSwgYXJndW1lbnRzWzFdKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdChBcnJheS5pc0FycmF5KG5hbWUpPyBuYW1lIDogW25hbWVdKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHR0aGlzW25hbWVdID0gdGhpc1tuYW1lXSB8fCBbXTtcblxuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV1bZmlyc3Q/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKTtcblx0fVxuXG5cdHJ1biAobmFtZSwgZW52KSB7XG5cdFx0dGhpc1tuYW1lXSA9IHRoaXNbbmFtZV0gfHwgW107XG5cdFx0dGhpc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2suY2FsbChlbnYgJiYgZW52LmNvbnRleHQ/IGVudi5jb250ZXh0IDogZW52LCBlbnYpO1xuXHRcdH0pO1xuXHR9XG59XG4vKipcbiAqIFRoZSBpbnN0YW5jZSBvZiB7QGxpbmsgSG9va3N9IHVzZWQgdGhyb3VnaG91dCBDb2xvci5qc1xuICovXG5jb25zdCBob29rcyA9IG5ldyBIb29rcygpO1xuXG4vLyBHbG9iYWwgZGVmYXVsdHMgb25lIG1heSB3YW50IHRvIGNvbmZpZ3VyZVxuXG52YXIgZGVmYXVsdHMgPSB7XG5cdGdhbXV0X21hcHBpbmc6IFwibGNoLmNcIixcblx0cHJlY2lzaW9uOiA1LFxuXHRkZWx0YUU6IFwiNzZcIiwgLy8gRGVmYXVsdCBkZWx0YUUgbWV0aG9kXG59O1xuXG5jb25zdCBXSElURVMgPSB7XG5cdC8vIGZvciBjb21wYXRpYmlsaXR5LCB0aGUgZm91ci1kaWdpdCBjaHJvbWF0aWNpdHktZGVyaXZlZCBvbmVzIGV2ZXJ5b25lIGVsc2UgdXNlc1xuXHRENTA6IFswLjM0NTcgLyAwLjM1ODUsIDEuMDAwMDAsICgxLjAgLSAwLjM0NTcgLSAwLjM1ODUpIC8gMC4zNTg1XSxcblx0RDY1OiBbMC4zMTI3IC8gMC4zMjkwLCAxLjAwMDAwLCAoMS4wIC0gMC4zMTI3IC0gMC4zMjkwKSAvIDAuMzI5MF0sXG59O1xuXG5mdW5jdGlvbiBnZXRXaGl0ZSAobmFtZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0cmV0dXJuIFdISVRFU1tuYW1lXTtcbn1cblxuLy8gQWRhcHQgWFlaIGZyb20gd2hpdGUgcG9pbnQgVzEgdG8gVzJcbmZ1bmN0aW9uIGFkYXB0JDEgKFcxLCBXMiwgWFlaLCBvcHRpb25zID0ge30pIHtcblx0VzEgPSBnZXRXaGl0ZShXMSk7XG5cdFcyID0gZ2V0V2hpdGUoVzIpO1xuXG5cdGlmICghVzEgfHwgIVcyKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgTWlzc2luZyB3aGl0ZSBwb2ludCB0byBjb252ZXJ0ICR7IVcxPyBcImZyb21cIiA6IFwiXCJ9JHshVzEmJiFXMj8gXCIvXCIgOiBcIlwifSR7IVcyPyBcInRvXCIgOiBcIlwifWApO1xuXHR9XG5cblx0aWYgKFcxID09PSBXMikge1xuXHRcdC8vIFNhbWUgd2hpdGVwb2ludHMsIG5vIGNvbnZlcnNpb24gbmVlZGVkXG5cdFx0cmV0dXJuIFhZWjtcblx0fVxuXG5cdGxldCBlbnYgPSB7VzEsIFcyLCBYWVosIG9wdGlvbnN9O1xuXG5cdGhvb2tzLnJ1bihcImNocm9tYXRpYy1hZGFwdGF0aW9uLXN0YXJ0XCIsIGVudik7XG5cblx0aWYgKCFlbnYuTSkge1xuXHRcdGlmIChlbnYuVzEgPT09IFdISVRFUy5ENjUgJiYgZW52LlcyID09PSBXSElURVMuRDUwKSB7XG5cdFx0XHRlbnYuTSA9IFtcblx0XHRcdFx0WyAgMS4wNDc5Mjk4MjA4NDA1NDg4LCAgICAwLjAyMjk0Njc5MzM0MTAxOTA4OCwgIC0wLjA1MDE5MjIyOTU0MzEzNTU3IF0sXG5cdFx0XHRcdFsgIDAuMDI5NjI3ODE1Njg4MTU5MzQ0LCAgMC45OTA0MzQ0ODQ1NzMyNDksICAgICAtMC4wMTcwNzM4MjUwMjkzODUxNCBdLFxuXHRcdFx0XHRbIC0wLjAwOTI0MzA1ODE1MjU5MTE3OCwgIDAuMDE1MDU1MTQ0ODk2NTc3ODk1LCAgIDAuNzUxODc0Mjg5OTU4MDAwOCAgXVxuXHRcdFx0XTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZW52LlcxID09PSBXSElURVMuRDUwICYmIGVudi5XMiA9PT0gV0hJVEVTLkQ2NSkge1xuXG5cdFx0XHRlbnYuTSA9IFtcblx0XHRcdFx0WyAgMC45NTU0NzM0NTI3MDQyMTgyLCAgIC0wLjAyMzA5ODUzNjg3NDI2MTQyMywgIDAuMDYzMjU5MzA4NjYxMDIxNyAgIF0sXG5cdFx0XHRcdFsgLTAuMDI4MzY5NzA2OTYzMjA4MTM2LCAgMS4wMDk5OTU0NTgwMDU4MjI2LCAgICAwLjAyMTA0MTM5ODk2Njk0MzAwOCBdLFxuXHRcdFx0XHRbICAwLjAxMjMxNDAwMTY4ODMxOTg5OSwgLTAuMDIwNTA3Njk2NDMzNDc3OTEyLCAgMS4zMzAzNjU5MzY2MDgwNzUzICAgXVxuXHRcdFx0XTtcblx0XHR9XG5cdH1cblxuXHRob29rcy5ydW4oXCJjaHJvbWF0aWMtYWRhcHRhdGlvbi1lbmRcIiwgZW52KTtcblxuXHRpZiAoZW52Lk0pIHtcblx0XHRyZXR1cm4gbXVsdGlwbHlNYXRyaWNlcyhlbnYuTSwgZW52LlhZWik7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ubHkgQnJhZGZvcmQgQ0FUIHdpdGggd2hpdGUgcG9pbnRzIEQ1MCBhbmQgRDY1IHN1cHBvcnRlZCBmb3Igbm93LlwiKTtcblx0fVxufVxuXG5jb25zdCDOtSQ0ID0gLjAwMDA3NTtcblxuLyoqXG4gKiBDbGFzcyB0byByZXByZXNlbnQgYSBjb2xvciBzcGFjZVxuICovXG5jbGFzcyBDb2xvclNwYWNlIHtcblx0Y29uc3RydWN0b3IgKG9wdGlvbnMpIHtcblx0XHR0aGlzLmlkID0gb3B0aW9ucy5pZDtcblx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG5cdFx0dGhpcy5iYXNlID0gb3B0aW9ucy5iYXNlID8gQ29sb3JTcGFjZS5nZXQob3B0aW9ucy5iYXNlKSA6IG51bGw7XG5cdFx0dGhpcy5hbGlhc2VzID0gb3B0aW9ucy5hbGlhc2VzO1xuXG5cdFx0aWYgKHRoaXMuYmFzZSkge1xuXHRcdFx0dGhpcy5mcm9tQmFzZSA9IG9wdGlvbnMuZnJvbUJhc2U7XG5cdFx0XHR0aGlzLnRvQmFzZSA9IG9wdGlvbnMudG9CYXNlO1xuXHRcdH1cblxuXHRcdC8vIENvb3JkaW5hdGUgbWV0YWRhdGFcblxuXHRcdGxldCBjb29yZHMgPSBvcHRpb25zLmNvb3JkcyA/PyB0aGlzLmJhc2UuY29vcmRzO1xuXG5cdFx0Zm9yIChsZXQgbmFtZSBpbiBjb29yZHMpIHtcblx0XHRcdGlmICghKFwibmFtZVwiIGluIGNvb3Jkc1tuYW1lXSkpIHtcblx0XHRcdFx0Y29vcmRzW25hbWVdLm5hbWUgPSBuYW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmNvb3JkcyA9IGNvb3JkcztcblxuXHRcdC8vIFdoaXRlIHBvaW50XG5cblx0XHRsZXQgd2hpdGUgPSBvcHRpb25zLndoaXRlID8/IHRoaXMuYmFzZS53aGl0ZSA/PyBcIkQ2NVwiO1xuXHRcdHRoaXMud2hpdGUgPSBnZXRXaGl0ZSh3aGl0ZSk7XG5cblx0XHQvLyBTb3J0IG91dCBmb3JtYXRzXG5cblx0XHR0aGlzLmZvcm1hdHMgPSBvcHRpb25zLmZvcm1hdHMgPz8ge307XG5cblx0XHRmb3IgKGxldCBuYW1lIGluIHRoaXMuZm9ybWF0cykge1xuXHRcdFx0bGV0IGZvcm1hdCA9IHRoaXMuZm9ybWF0c1tuYW1lXTtcblx0XHRcdGZvcm1hdC50eXBlIHx8PSBcImZ1bmN0aW9uXCI7XG5cdFx0XHRmb3JtYXQubmFtZSB8fD0gbmFtZTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5jc3NJZCAmJiAhdGhpcy5mb3JtYXRzLmZ1bmN0aW9ucz8uY29sb3IpIHtcblx0XHRcdHRoaXMuZm9ybWF0cy5jb2xvciA9IHsgaWQ6IG9wdGlvbnMuY3NzSWQgfTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNzc0lkXCIsIHt2YWx1ZTogb3B0aW9ucy5jc3NJZH0pO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmZvcm1hdHM/LmNvbG9yICYmICF0aGlzLmZvcm1hdHM/LmNvbG9yLmlkKSB7XG5cdFx0XHR0aGlzLmZvcm1hdHMuY29sb3IuaWQgPSB0aGlzLmlkO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHN0dWZmXG5cdFx0dGhpcy5yZWZlcnJlZCA9IG9wdGlvbnMucmVmZXJyZWQ7XG5cblx0XHQvLyBDb21wdXRlIGFuY2VzdG9ycyBhbmQgc3RvcmUgdGhlbSwgc2luY2UgdGhleSB3aWxsIG5ldmVyIGNoYW5nZVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhdGhcIiwge1xuXHRcdFx0dmFsdWU6IGdldFBhdGgodGhpcykucmV2ZXJzZSgpLFxuXHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHR9KTtcblxuXHRcdGhvb2tzLnJ1bihcImNvbG9yc3BhY2UtaW5pdC1lbmRcIiwgdGhpcyk7XG5cdH1cblxuXHRpbkdhbXV0IChjb29yZHMsIHtlcHNpbG9uID0gzrUkNH0gPSB7fSkge1xuXHRcdGlmICh0aGlzLmlzUG9sYXIpIHtcblx0XHRcdC8vIERvIG5vdCBjaGVjayBnYW11dCB0aHJvdWdoIHBvbGFyIGNvb3JkaW5hdGVzXG5cdFx0XHRjb29yZHMgPSB0aGlzLnRvQmFzZShjb29yZHMpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5iYXNlLmluR2FtdXQoY29vcmRzLCB7ZXBzaWxvbn0pO1xuXHRcdH1cblxuXHRcdGxldCBjb29yZE1ldGEgPSBPYmplY3QudmFsdWVzKHRoaXMuY29vcmRzKTtcblxuXHRcdHJldHVybiBjb29yZHMuZXZlcnkoKGMsIGkpID0+IHtcblx0XHRcdGxldCBtZXRhID0gY29vcmRNZXRhW2ldO1xuXG5cdFx0XHRpZiAobWV0YS50eXBlICE9PSBcImFuZ2xlXCIgJiYgbWV0YS5yYW5nZSkge1xuXHRcdFx0XHRpZiAoTnVtYmVyLmlzTmFOKGMpKSB7XG5cdFx0XHRcdFx0Ly8gTmFOIGlzIGFsd2F5cyBpbiBnYW11dFxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IFttaW4sIG1heF0gPSBtZXRhLnJhbmdlO1xuXHRcdFx0XHRyZXR1cm4gKG1pbiA9PT0gdW5kZWZpbmVkIHx8IGMgPj0gbWluIC0gZXBzaWxvbilcblx0XHRcdFx0ICAgICYmIChtYXggPT09IHVuZGVmaW5lZCB8fCBjIDw9IG1heCArIGVwc2lsb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0fVxuXG5cdGdldCBjc3NJZCAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZm9ybWF0cy5mdW5jdGlvbnM/LmNvbG9yPy5pZCB8fCB0aGlzLmlkO1xuXHR9XG5cblx0Z2V0IGlzUG9sYXIgKCkge1xuXHRcdGZvciAobGV0IGlkIGluIHRoaXMuY29vcmRzKSB7XG5cdFx0XHRpZiAodGhpcy5jb29yZHNbaWRdLnR5cGUgPT09IFwiYW5nbGVcIikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRnZXRGb3JtYXQgKGZvcm1hdCkge1xuXHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRmb3JtYXQgPSBwcm9jZXNzRm9ybWF0KGZvcm1hdCwgdGhpcyk7XG5cdFx0XHRyZXR1cm4gZm9ybWF0O1xuXHRcdH1cblxuXHRcdGxldCByZXQ7XG5cdFx0aWYgKGZvcm1hdCA9PT0gXCJkZWZhdWx0XCIpIHtcblx0XHRcdC8vIEdldCBmaXJzdCBmb3JtYXRcblx0XHRcdHJldCA9IE9iamVjdC52YWx1ZXModGhpcy5mb3JtYXRzKVswXTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXQgPSB0aGlzLmZvcm1hdHNbZm9ybWF0XTtcblx0XHR9XG5cblx0XHRpZiAocmV0KSB7XG5cdFx0XHRyZXQgPSBwcm9jZXNzRm9ybWF0KHJldCwgdGhpcyk7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gV2UgY2Fubm90IHJlbHkgb24gc2ltcGxlID09PSBiZWNhdXNlIHRoZW4gQ29sb3JTcGFjZSBvYmplY3RzIGNhbm5vdCBiZSBwcm94aWVkXG5cdGVxdWFscyAoc3BhY2UpIHtcblx0XHRpZiAoIXNwYWNlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMgPT09IHNwYWNlIHx8IHRoaXMuaWQgPT09IHNwYWNlLmlkO1xuXHR9XG5cblx0dG8gKHNwYWNlLCBjb29yZHMpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0W3NwYWNlLCBjb29yZHNdID0gW3NwYWNlLnNwYWNlLCBzcGFjZS5jb29yZHNdO1xuXHRcdH1cblxuXHRcdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXG5cdFx0aWYgKHRoaXMuZXF1YWxzKHNwYWNlKSkge1xuXHRcdFx0Ly8gU2FtZSBzcGFjZSwgbm8gY2hhbmdlIG5lZWRlZFxuXHRcdFx0cmV0dXJuIGNvb3Jkcztcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IE5hTiB0byAwLCB3aGljaCBzZWVtcyB0byBiZSB2YWxpZCBpbiBldmVyeSBjb29yZGluYXRlIG9mIGV2ZXJ5IGNvbG9yIHNwYWNlXG5cdFx0Y29vcmRzID0gY29vcmRzLm1hcChjID0+IE51bWJlci5pc05hTihjKT8gMCA6IGMpO1xuXG5cdFx0Ly8gRmluZCBjb25uZWN0aW9uIHNwYWNlID0gbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBpbiB0aGUgYmFzZSB0cmVlXG5cdFx0bGV0IG15UGF0aCA9IHRoaXMucGF0aDtcblx0XHRsZXQgb3RoZXJQYXRoID0gc3BhY2UucGF0aDtcblxuXHRcdGxldCBjb25uZWN0aW9uU3BhY2UsIGNvbm5lY3Rpb25TcGFjZUluZGV4O1xuXG5cdFx0Zm9yIChsZXQgaT0wOyBpIDwgbXlQYXRoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAobXlQYXRoW2ldLmVxdWFscyhvdGhlclBhdGhbaV0pKSB7XG5cdFx0XHRcdGNvbm5lY3Rpb25TcGFjZSA9IG15UGF0aFtpXTtcblx0XHRcdFx0Y29ubmVjdGlvblNwYWNlSW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghY29ubmVjdGlvblNwYWNlKSB7XG5cdFx0XHQvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW5cblx0XHRcdHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgYmV0d2VlbiBjb2xvciBzcGFjZXMgJHt0aGlzfSBhbmQgJHtzcGFjZX06IG5vIGNvbm5lY3Rpb24gc3BhY2Ugd2FzIGZvdW5kYCk7XG5cdFx0fVxuXG5cdFx0Ly8gR28gdXAgZnJvbSBjdXJyZW50IHNwYWNlIHRvIGNvbm5lY3Rpb24gc3BhY2Vcblx0XHRmb3IgKGxldCBpID0gbXlQYXRoLmxlbmd0aCAtIDE7IGkgPiBjb25uZWN0aW9uU3BhY2VJbmRleDsgaS0tKSB7XG5cdFx0XHRjb29yZHMgPSBteVBhdGhbaV0udG9CYXNlKGNvb3Jkcyk7XG5cdFx0fVxuXG5cdFx0Ly8gR28gZG93biBmcm9tIGNvbm5lY3Rpb24gc3BhY2UgdG8gdGFyZ2V0IHNwYWNlXG5cdFx0Zm9yIChsZXQgaSA9IGNvbm5lY3Rpb25TcGFjZUluZGV4ICsgMTsgaSA8IG90aGVyUGF0aC5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29vcmRzID0gb3RoZXJQYXRoW2ldLmZyb21CYXNlKGNvb3Jkcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fVxuXG5cdGZyb20gKHNwYWNlLCBjb29yZHMpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0W3NwYWNlLCBjb29yZHNdID0gW3NwYWNlLnNwYWNlLCBzcGFjZS5jb29yZHNdO1xuXHRcdH1cblxuXHRcdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXG5cdFx0cmV0dXJuIHNwYWNlLnRvKHRoaXMsIGNvb3Jkcyk7XG5cdH1cblxuXHR0b1N0cmluZyAoKSB7XG5cdFx0cmV0dXJuIGAke3RoaXMubmFtZX0gKCR7dGhpcy5pZH0pYDtcblx0fVxuXG5cdGdldE1pbkNvb3JkcyAoKSB7XG5cdFx0bGV0IHJldCA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgaWQgaW4gdGhpcy5jb29yZHMpIHtcblx0XHRcdGxldCBtZXRhID0gdGhpcy5jb29yZHNbaWRdO1xuXHRcdFx0bGV0IHJhbmdlID0gbWV0YS5yYW5nZSB8fCBtZXRhLnJlZlJhbmdlO1xuXHRcdFx0cmV0LnB1c2gocmFuZ2U/Lm1pbiA/PyAwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0c3RhdGljIHJlZ2lzdHJ5ID0ge307XG5cblx0Ly8gUmV0dXJucyBhcnJheSBvZiB1bmlxdWUgY29sb3Igc3BhY2VzXG5cdHN0YXRpYyBnZXQgYWxsICgpIHtcblx0XHRyZXR1cm4gWy4uLm5ldyBTZXQoT2JqZWN0LnZhbHVlcyhDb2xvclNwYWNlLnJlZ2lzdHJ5KSldO1xuXHR9XG5cblx0c3RhdGljIHJlZ2lzdGVyIChpZCwgc3BhY2UpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0c3BhY2UgPSBhcmd1bWVudHNbMF07XG5cdFx0XHRpZCA9IHNwYWNlLmlkO1xuXHRcdH1cblxuXHRcdHNwYWNlID0gdGhpcy5nZXQoc3BhY2UpO1xuXG5cdFx0aWYgKHRoaXMucmVnaXN0cnlbaWRdICYmIHRoaXMucmVnaXN0cnlbaWRdICE9PSBzcGFjZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgY29sb3Igc3BhY2UgcmVnaXN0cmF0aW9uOiAnJHtpZH0nYCk7XG5cdFx0fVxuXHRcdHRoaXMucmVnaXN0cnlbaWRdID0gc3BhY2U7XG5cblx0XHQvLyBSZWdpc3RlciBhbGlhc2VzIHdoZW4gY2FsbGVkIHdpdGhvdXQgYW4gZXhwbGljaXQgSUQuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgc3BhY2UuYWxpYXNlcykge1xuXHRcdFx0Zm9yIChsZXQgYWxpYXMgb2Ygc3BhY2UuYWxpYXNlcykge1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyKGFsaWFzLCBzcGFjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwYWNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvb2t1cCBDb2xvclNwYWNlIG9iamVjdCBieSBuYW1lXG5cdCAqIEBwYXJhbSB7Q29sb3JTcGFjZSB8IHN0cmluZ30gbmFtZVxuXHQgKi9cblx0c3RhdGljIGdldCAoc3BhY2UsIC4uLmFsdGVybmF0aXZlcykge1xuXHRcdGlmICghc3BhY2UgfHwgc3BhY2UgaW5zdGFuY2VvZiBDb2xvclNwYWNlKSB7XG5cdFx0XHRyZXR1cm4gc3BhY2U7XG5cdFx0fVxuXG5cdFx0bGV0IGFyZ1R5cGUgPSB0eXBlKHNwYWNlKTtcblxuXHRcdGlmIChhcmdUeXBlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHQvLyBJdCdzIGEgY29sb3Igc3BhY2UgaWRcblx0XHRcdGxldCByZXQgPSBDb2xvclNwYWNlLnJlZ2lzdHJ5W3NwYWNlLnRvTG93ZXJDYXNlKCldO1xuXG5cdFx0XHRpZiAoIXJldCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBjb2xvciBzcGFjZSBmb3VuZCB3aXRoIGlkID0gXCIke3NwYWNlfVwiYCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0aWYgKGFsdGVybmF0aXZlcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBDb2xvclNwYWNlLmdldCguLi5hbHRlcm5hdGl2ZXMpO1xuXHRcdH1cblxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYCR7c3BhY2V9IGlzIG5vdCBhIHZhbGlkIGNvbG9yIHNwYWNlYCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IG1ldGFkYXRhIGFib3V0IGEgY29vcmRpbmF0ZSBvZiBhIGNvbG9yIHNwYWNlXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtBcnJheSB8IHN0cmluZ30gcmVmXG5cdCAqIEBwYXJhbSB7Q29sb3JTcGFjZSB8IHN0cmluZ30gW3dvcmtpbmdTcGFjZV1cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0c3RhdGljIHJlc29sdmVDb29yZCAocmVmLCB3b3JraW5nU3BhY2UpIHtcblx0XHRsZXQgY29vcmRUeXBlID0gdHlwZShyZWYpO1xuXHRcdGxldCBzcGFjZSwgY29vcmQ7XG5cblx0XHRpZiAoY29vcmRUeXBlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAocmVmLmluY2x1ZGVzKFwiLlwiKSkge1xuXHRcdFx0XHQvLyBBYnNvbHV0ZSBjb29yZGluYXRlXG5cdFx0XHRcdFtzcGFjZSwgY29vcmRdID0gcmVmLnNwbGl0KFwiLlwiKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBSZWxhdGl2ZSBjb29yZGluYXRlXG5cdFx0XHRcdFtzcGFjZSwgY29vcmRdID0gWywgcmVmXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZWYpKSB7XG5cdFx0XHRbc3BhY2UsIGNvb3JkXSA9IHJlZjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBPYmplY3Rcblx0XHRcdHNwYWNlID0gcmVmLnNwYWNlO1xuXHRcdFx0Y29vcmQgPSByZWYuY29vcmRJZDtcblx0XHR9XG5cblx0XHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblxuXHRcdGlmICghc3BhY2UpIHtcblx0XHRcdHNwYWNlID0gd29ya2luZ1NwYWNlO1xuXHRcdH1cblxuXHRcdGlmICghc3BhY2UpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCByZXNvbHZlIGNvb3JkaW5hdGUgcmVmZXJlbmNlICR7cmVmfTogTm8gY29sb3Igc3BhY2Ugc3BlY2lmaWVkIGFuZCByZWxhdGl2ZSByZWZlcmVuY2VzIGFyZSBub3QgYWxsb3dlZCBoZXJlYCk7XG5cdFx0fVxuXG5cdFx0Y29vcmRUeXBlID0gdHlwZShjb29yZCk7XG5cblx0XHRpZiAoY29vcmRUeXBlID09PSBcIm51bWJlclwiIHx8IGNvb3JkVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBjb29yZCA+PSAwKSB7XG5cdFx0XHQvLyBSZXNvbHZlIG51bWVyaWNhbCBjb29yZFxuXHRcdFx0bGV0IG1ldGEgPSBPYmplY3QuZW50cmllcyhzcGFjZS5jb29yZHMpW2Nvb3JkXTtcblxuXHRcdFx0aWYgKG1ldGEpIHtcblx0XHRcdFx0cmV0dXJuIHtzcGFjZSwgaWQ6IG1ldGFbMF0sIGluZGV4OiBjb29yZCwgLi4ubWV0YVsxXX07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3BhY2UgPSBDb2xvclNwYWNlLmdldChzcGFjZSk7XG5cblx0XHRsZXQgbm9ybWFsaXplZENvb3JkID0gY29vcmQudG9Mb3dlckNhc2UoKTtcblxuXHRcdGxldCBpID0gMDtcblx0XHRmb3IgKGxldCBpZCBpbiBzcGFjZS5jb29yZHMpIHtcblx0XHRcdGxldCBtZXRhID0gc3BhY2UuY29vcmRzW2lkXTtcblxuXHRcdFx0aWYgKGlkLnRvTG93ZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWRDb29yZCB8fCBtZXRhLm5hbWU/LnRvTG93ZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWRDb29yZCkge1xuXHRcdFx0XHRyZXR1cm4ge3NwYWNlLCBpZCwgaW5kZXg6IGksIC4uLm1ldGF9O1xuXHRcdFx0fVxuXG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gXCIke2Nvb3JkfVwiIGNvb3JkaW5hdGUgZm91bmQgaW4gJHtzcGFjZS5uYW1lfS4gSXRzIGNvb3JkaW5hdGVzIGFyZTogJHtPYmplY3Qua2V5cyhzcGFjZS5jb29yZHMpLmpvaW4oXCIsIFwiKX1gKTtcblx0fVxuXG5cdHN0YXRpYyBERUZBVUxUX0ZPUk1BVCA9IHtcblx0XHR0eXBlOiBcImZ1bmN0aW9uc1wiLFxuXHRcdG5hbWU6IFwiY29sb3JcIixcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0aCAoc3BhY2UpIHtcblx0bGV0IHJldCA9IFtzcGFjZV07XG5cblx0Zm9yIChsZXQgcyA9IHNwYWNlOyBzID0gcy5iYXNlOykge1xuXHRcdHJldC5wdXNoKHMpO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Zvcm1hdCAoZm9ybWF0LCB7Y29vcmRzfSA9IHt9KSB7XG5cdGlmIChmb3JtYXQuY29vcmRzICYmICFmb3JtYXQuY29vcmRHcmFtbWFyKSB7XG5cdFx0Zm9ybWF0LnR5cGUgfHw9IFwiZnVuY3Rpb25cIjtcblx0XHRmb3JtYXQubmFtZSB8fD0gXCJjb2xvclwiO1xuXG5cdFx0Ly8gRm9ybWF0IGhhcyBub3QgYmVlbiBwcm9jZXNzZWRcblx0XHRmb3JtYXQuY29vcmRHcmFtbWFyID0gcGFyc2VDb29yZEdyYW1tYXIoZm9ybWF0LmNvb3Jkcyk7XG5cblx0XHRsZXQgY29vcmRGb3JtYXRzID0gT2JqZWN0LmVudHJpZXMoY29vcmRzKS5tYXAoKFtpZCwgY29vcmRNZXRhXSwgaSkgPT4ge1xuXHRcdFx0Ly8gUHJlZmVycmVkIGZvcm1hdCBmb3IgZWFjaCBjb29yZCBpcyB0aGUgZmlyc3Qgb25lXG5cdFx0XHRsZXQgb3V0cHV0VHlwZSA9IGZvcm1hdC5jb29yZEdyYW1tYXJbaV1bMF07XG5cblx0XHRcdGxldCBmcm9tUmFuZ2UgPSBjb29yZE1ldGEucmFuZ2UgfHwgY29vcmRNZXRhLnJlZlJhbmdlO1xuXHRcdFx0bGV0IHRvUmFuZ2UgPSBvdXRwdXRUeXBlLnJhbmdlLCBzdWZmaXggPSBcIlwiO1xuXG5cdFx0XHQvLyBOb24tc3RyaWN0IGVxdWFscyBpbnRlbnRpb25hbCBzaW5jZSBvdXRwdXRUeXBlIGNvdWxkIGJlIGEgc3RyaW5nIG9iamVjdFxuXHRcdFx0aWYgKG91dHB1dFR5cGUgPT0gXCI8cGVyY2VudGFnZT5cIikge1xuXHRcdFx0XHR0b1JhbmdlID0gWzAsIDEwMF07XG5cdFx0XHRcdHN1ZmZpeCA9IFwiJVwiO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob3V0cHV0VHlwZSA9PSBcIjxhbmdsZT5cIikge1xuXHRcdFx0XHRzdWZmaXggPSBcImRlZ1wiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gIHtmcm9tUmFuZ2UsIHRvUmFuZ2UsIHN1ZmZpeH07XG5cdFx0fSk7XG5cblx0XHRmb3JtYXQuc2VyaWFsaXplQ29vcmRzID0gKGNvb3JkcywgcHJlY2lzaW9uKSA9PiB7XG5cdFx0XHRyZXR1cm4gY29vcmRzLm1hcCgoYywgaSkgPT4ge1xuXHRcdFx0XHRsZXQge2Zyb21SYW5nZSwgdG9SYW5nZSwgc3VmZml4fSA9IGNvb3JkRm9ybWF0c1tpXTtcblxuXHRcdFx0XHRpZiAoZnJvbVJhbmdlICYmIHRvUmFuZ2UpIHtcblx0XHRcdFx0XHRjID0gbWFwUmFuZ2UoZnJvbVJhbmdlLCB0b1JhbmdlLCBjKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGMgPSB0b1ByZWNpc2lvbihjLCBwcmVjaXNpb24pO1xuXG5cdFx0XHRcdGlmIChzdWZmaXgpIHtcblx0XHRcdFx0XHRjICs9IHN1ZmZpeDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBmb3JtYXQ7XG59XG5cbnZhciBYWVpfRDY1ID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJ4eXotZDY1XCIsXG5cdG5hbWU6IFwiWFlaIEQ2NVwiLFxuXHRjb29yZHM6IHtcblx0XHR4OiB7bmFtZTogXCJYXCJ9LFxuXHRcdHk6IHtuYW1lOiBcIllcIn0sXG5cdFx0ejoge25hbWU6IFwiWlwifSxcblx0fSxcblx0d2hpdGU6IFwiRDY1XCIsXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge1xuXHRcdFx0aWRzOiBbXCJ4eXotZDY1XCIsIFwieHl6XCJdLFxuXHRcdH1cblx0fSxcblx0YWxpYXNlczogW1wieHl6XCJdLFxufSk7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgZm9yIFJHQiBjb2xvciBzcGFjZXNcbiAqIEBleHRlbmRzIHtDb2xvclNwYWNlfVxuICovXG5jbGFzcyBSR0JDb2xvclNwYWNlIGV4dGVuZHMgQ29sb3JTcGFjZSB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFJHQiBDb2xvclNwYWNlLlxuXHQgKiBJZiBjb29yZHMgYXJlIG5vdCBzcGVjaWZpZWQsIHRoZXkgd2lsbCB1c2UgdGhlIGRlZmF1bHQgUkdCIGNvb3Jkcy5cblx0ICogSW5zdGVhZCBvZiBgZnJvbUJhc2UoKWAgYW5kIGB0b0Jhc2UoKWAgZnVuY3Rpb25zLFxuXHQgKiB5b3UgY2FuIHNwZWNpZnkgdG8vZnJvbSBYWVogbWF0cmljZXMgYW5kIGhhdmUgYHRvQmFzZSgpYCBhbmQgYGZyb21CYXNlKClgIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuXHQgKiBAcGFyYW0geyp9IG9wdGlvbnMgLSBTYW1lIG9wdGlvbnMgYXMge0BsaW5rIENvbG9yU3BhY2V9IHBsdXM6XG5cdCAqIEBwYXJhbSB7bnVtYmVyW11bXX0gb3B0aW9ucy50b1hZWl9NIC0gTWF0cml4IHRvIGNvbnZlcnQgdG8gWFlaXG5cdCAqIEBwYXJhbSB7bnVtYmVyW11bXX0gb3B0aW9ucy5mcm9tWFlaX00gLSBNYXRyaXggdG8gY29udmVydCBmcm9tIFhZWlxuXHQgKi9cblx0Y29uc3RydWN0b3IgKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMuY29vcmRzKSB7XG5cdFx0XHRvcHRpb25zLmNvb3JkcyA9IHtcblx0XHRcdFx0cjoge1xuXHRcdFx0XHRcdHJhbmdlOiBbMCwgMV0sXG5cdFx0XHRcdFx0bmFtZTogXCJSZWRcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnOiB7XG5cdFx0XHRcdFx0cmFuZ2U6IFswLCAxXSxcblx0XHRcdFx0XHRuYW1lOiBcIkdyZWVuXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Yjoge1xuXHRcdFx0XHRcdHJhbmdlOiBbMCwgMV0sXG5cdFx0XHRcdFx0bmFtZTogXCJCbHVlXCJcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoIW9wdGlvbnMuYmFzZSkge1xuXHRcdFx0b3B0aW9ucy5iYXNlID0gWFlaX0Q2NTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy50b1hZWl9NICYmIG9wdGlvbnMuZnJvbVhZWl9NKSB7XG5cdFx0XHRvcHRpb25zLnRvQmFzZSA/Pz0gcmdiID0+IHtcblx0XHRcdFx0bGV0IHh5eiA9IG11bHRpcGx5TWF0cmljZXMob3B0aW9ucy50b1hZWl9NLCByZ2IpO1xuXG5cdFx0XHRcdGlmICh0aGlzLndoaXRlICE9PSB0aGlzLmJhc2Uud2hpdGUpIHtcblx0XHRcdFx0XHQvLyBQZXJmb3JtIGNocm9tYXRpYyBhZGFwdGF0aW9uXG5cdFx0XHRcdFx0eHl6ID0gYWRhcHQkMSh0aGlzLndoaXRlLCB0aGlzLmJhc2Uud2hpdGUsIHh5eik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4geHl6O1xuXHRcdFx0fTtcblxuXHRcdFx0b3B0aW9ucy5mcm9tQmFzZSA/Pz0geHl6ID0+IHtcblx0XHRcdFx0eHl6ID0gYWRhcHQkMSh0aGlzLmJhc2Uud2hpdGUsIHRoaXMud2hpdGUsIHh5eik7XG5cdFx0XHRcdHJldHVybiBtdWx0aXBseU1hdHJpY2VzKG9wdGlvbnMuZnJvbVhZWl9NLCB4eXopO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRvcHRpb25zLnJlZmVycmVkID8/PSBcImRpc3BsYXlcIjtcblxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHR9XG59XG5cbi8qKlxuICogQ29udmVydCBhIENTUyBDb2xvciBzdHJpbmcgdG8gYSBjb2xvciBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tZXRhXSAtIE9iamVjdCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyc2luZ1xuICogQHJldHVybnMgeyBDb2xvciB9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIHttZXRhfSA9IHt9KSB7XG5cdGxldCBlbnYgPSB7XCJzdHJcIjogU3RyaW5nKHN0cik/LnRyaW0oKX07XG5cdGhvb2tzLnJ1bihcInBhcnNlLXN0YXJ0XCIsIGVudik7XG5cblx0aWYgKGVudi5jb2xvcikge1xuXHRcdHJldHVybiBlbnYuY29sb3I7XG5cdH1cblxuXHRlbnYucGFyc2VkID0gcGFyc2VGdW5jdGlvbihlbnYuc3RyKTtcblxuXHRpZiAoZW52LnBhcnNlZCkge1xuXHRcdC8vIElzIGEgZnVuY3Rpb25hbCBzeW50YXhcblx0XHRsZXQgbmFtZSA9IGVudi5wYXJzZWQubmFtZTtcblxuXHRcdGlmIChuYW1lID09PSBcImNvbG9yXCIpIHtcblx0XHRcdC8vIGNvbG9yKCkgZnVuY3Rpb25cblx0XHRcdGxldCBpZCA9IGVudi5wYXJzZWQuYXJncy5zaGlmdCgpO1xuXHRcdFx0bGV0IGFscGhhID0gZW52LnBhcnNlZC5yYXdBcmdzLmluZGV4T2YoXCIvXCIpID4gMD8gZW52LnBhcnNlZC5hcmdzLnBvcCgpIDogMTtcblxuXHRcdFx0Zm9yIChsZXQgc3BhY2Ugb2YgQ29sb3JTcGFjZS5hbGwpIHtcblx0XHRcdFx0bGV0IGNvbG9yU3BlYyA9IHNwYWNlLmdldEZvcm1hdChcImNvbG9yXCIpO1xuXG5cdFx0XHRcdGlmIChjb2xvclNwZWMpIHtcblx0XHRcdFx0XHRpZiAoaWQgPT09IGNvbG9yU3BlYy5pZCB8fCBjb2xvclNwZWMuaWRzPy5pbmNsdWRlcyhpZCkpIHtcblx0XHRcdFx0XHRcdC8vIEZyb20gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci00LyNjb2xvci1mdW5jdGlvblxuXHRcdFx0XHRcdFx0Ly8gSWYgbW9yZSA8bnVtYmVyPnMgb3IgPHBlcmNlbnRhZ2U+cyBhcmUgcHJvdmlkZWQgdGhhbiBwYXJhbWV0ZXJzIHRoYXQgdGhlIGNvbG9yc3BhY2UgdGFrZXMsIHRoZSBleGNlc3MgPG51bWJlcj5zIGF0IHRoZSBlbmQgYXJlIGlnbm9yZWQuXG5cdFx0XHRcdFx0XHQvLyBJZiBsZXNzIDxudW1iZXI+cyBvciA8cGVyY2VudGFnZT5zIGFyZSBwcm92aWRlZCB0aGFuIHBhcmFtZXRlcnMgdGhhdCB0aGUgY29sb3JzcGFjZSB0YWtlcywgdGhlIG1pc3NpbmcgcGFyYW1ldGVycyBkZWZhdWx0IHRvIDAuIChUaGlzIGlzIHBhcnRpY3VsYXJseSBjb252ZW5pZW50IGZvciBtdWx0aWNoYW5uZWwgcHJpbnRlcnMgd2hlcmUgdGhlIGFkZGl0aW9uYWwgaW5rcyBhcmUgc3BvdCBjb2xvcnMgb3IgdmFybmlzaGVzIHRoYXQgbW9zdCBjb2xvcnMgb24gdGhlIHBhZ2Ugd29u4oCZdCB1c2UuKVxuXHRcdFx0XHRcdFx0Y29uc3QgY29vcmRzID0gT2JqZWN0LmtleXMoc3BhY2UuY29vcmRzKS5tYXAoKF8sIGkpID0+IGVudi5wYXJzZWQuYXJnc1tpXSB8fCAwKTtcblxuXHRcdFx0XHRcdFx0aWYgKG1ldGEpIHtcblx0XHRcdFx0XHRcdFx0bWV0YS5mb3JtYXRJZCA9IFwiY29sb3JcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtzcGFjZUlkOiBzcGFjZS5pZCwgY29vcmRzLCBhbHBoYX07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vdCBmb3VuZFxuXHRcdFx0bGV0IGRpZFlvdU1lYW4gPSBcIlwiO1xuXHRcdFx0aWYgKGlkIGluIENvbG9yU3BhY2UucmVnaXN0cnkpIHtcblx0XHRcdFx0Ly8gVXNlZCBjb2xvciBzcGFjZSBpZCBpbnN0ZWFkIG9mIGNvbG9yKCkgaWQsIHRoZXNlIGFyZSBvZnRlbiBkaWZmZXJlbnRcblx0XHRcdFx0bGV0IGNzc0lkID0gQ29sb3JTcGFjZS5yZWdpc3RyeVtpZF0uZm9ybWF0cz8uZnVuY3Rpb25zPy5jb2xvcj8uaWQ7XG5cblx0XHRcdFx0aWYgKGNzc0lkKSB7XG5cdFx0XHRcdFx0ZGlkWW91TWVhbiA9IGBEaWQgeW91IG1lYW4gY29sb3IoJHtjc3NJZH0pP2A7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IHBhcnNlIGNvbG9yKCR7aWR9KS4gYCArIChkaWRZb3VNZWFuIHx8IFwiTWlzc2luZyBhIHBsdWdpbj9cIikpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvciAobGV0IHNwYWNlIG9mIENvbG9yU3BhY2UuYWxsKSB7XG5cdFx0XHRcdC8vIGNvbG9yIHNwYWNlIHNwZWNpZmljIGZ1bmN0aW9uXG5cdFx0XHRcdGxldCBmb3JtYXQgPSBzcGFjZS5nZXRGb3JtYXQobmFtZSk7XG5cdFx0XHRcdGlmIChmb3JtYXQgJiYgZm9ybWF0LnR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxldCBhbHBoYSA9IDE7XG5cblx0XHRcdFx0XHRpZiAoZm9ybWF0Lmxhc3RBbHBoYSB8fCBsYXN0KGVudi5wYXJzZWQuYXJncykuYWxwaGEpIHtcblx0XHRcdFx0XHRcdGFscGhhID0gZW52LnBhcnNlZC5hcmdzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBjb29yZHMgPSBlbnYucGFyc2VkLmFyZ3M7XG5cblx0XHRcdFx0XHRsZXQgdHlwZXM7XG5cblx0XHRcdFx0XHRpZiAoZm9ybWF0LmNvb3JkR3JhbW1hcikge1xuXHRcdFx0XHRcdFx0dHlwZXMgPSBPYmplY3QuZW50cmllcyhzcGFjZS5jb29yZHMpLm1hcCgoW2lkLCBjb29yZE1ldGFdLCBpKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGxldCBjb29yZEdyYW1tYXIgPSBmb3JtYXQuY29vcmRHcmFtbWFyW2ldO1xuXHRcdFx0XHRcdFx0XHRsZXQgcHJvdmlkZWRUeXBlID0gY29vcmRzW2ldPy50eXBlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEZpbmQgZ3JhbW1hciBhbHRlcm5hdGl2ZSB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIHR5cGVcblx0XHRcdFx0XHRcdFx0Ly8gTm9uLXN0cmljdCBlcXVhbHMgaXMgaW50ZW50aW9uYWwgYmVjYXVzZSB3ZSBhcmUgY29tcGFyaW5nIHcvIHN0cmluZyBvYmplY3RzXG5cdFx0XHRcdFx0XHRcdGxldCB0eXBlID0gY29vcmRHcmFtbWFyLmZpbmQoYyA9PiBjID09IHByb3ZpZGVkVHlwZSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCBlYWNoIGNvb3JkIGNvbmZvcm1zIHRvIGl0cyBncmFtbWFyXG5cdFx0XHRcdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFR5cGUgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGdyYW1tYXIsIHRocm93XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGNvb3JkTmFtZSA9IGNvb3JkTWV0YS5uYW1lIHx8IGlkO1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYCR7cHJvdmlkZWRUeXBlfSBub3QgYWxsb3dlZCBmb3IgJHtjb29yZE5hbWV9IGluICR7bmFtZX0oKWApO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0bGV0IGZyb21SYW5nZSA9IHR5cGUucmFuZ2U7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHByb3ZpZGVkVHlwZSA9PT0gXCI8cGVyY2VudGFnZT5cIikge1xuXHRcdFx0XHRcdFx0XHRcdGZyb21SYW5nZSB8fD0gWzAsIDFdO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0bGV0IHRvUmFuZ2UgPSBjb29yZE1ldGEucmFuZ2UgfHwgY29vcmRNZXRhLnJlZlJhbmdlO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tUmFuZ2UgJiYgdG9SYW5nZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvb3Jkc1tpXSA9IG1hcFJhbmdlKGZyb21SYW5nZSwgdG9SYW5nZSwgY29vcmRzW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0eXBlO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG1ldGEpIHtcblx0XHRcdFx0XHRcdE9iamVjdC5hc3NpZ24obWV0YSwge2Zvcm1hdElkOiBmb3JtYXQubmFtZSwgdHlwZXN9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0c3BhY2VJZDogc3BhY2UuaWQsXG5cdFx0XHRcdFx0XHRjb29yZHMsIGFscGhhXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHQvLyBDdXN0b20sIGNvbG9yc3BhY2Utc3BlY2lmaWMgZm9ybWF0XG5cdFx0Zm9yIChsZXQgc3BhY2Ugb2YgQ29sb3JTcGFjZS5hbGwpIHtcblx0XHRcdGZvciAobGV0IGZvcm1hdElkIGluIHNwYWNlLmZvcm1hdHMpIHtcblx0XHRcdFx0bGV0IGZvcm1hdCA9IHNwYWNlLmZvcm1hdHNbZm9ybWF0SWRdO1xuXG5cdFx0XHRcdGlmIChmb3JtYXQudHlwZSAhPT0gXCJjdXN0b21cIikge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGZvcm1hdC50ZXN0ICYmICFmb3JtYXQudGVzdChlbnYuc3RyKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IGNvbG9yID0gZm9ybWF0LnBhcnNlKGVudi5zdHIpO1xuXG5cdFx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRcdGNvbG9yLmFscGhhID8/PSAxO1xuXG5cdFx0XHRcdFx0aWYgKG1ldGEpIHtcblx0XHRcdFx0XHRcdG1ldGEuZm9ybWF0SWQgPSBmb3JtYXRJZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gY29sb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8vIElmIHdlJ3JlIGhlcmUsIHdlIGNvdWxkbid0IHBhcnNlXG5cdHRocm93IG5ldyBUeXBlRXJyb3IoYENvdWxkIG5vdCBwYXJzZSAke3N0cn0gYXMgYSBjb2xvci4gTWlzc2luZyBhIHBsdWdpbj9gKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIGNvbG9yIHJlZmVyZW5jZSAob2JqZWN0IG9yIHN0cmluZykgdG8gYSBwbGFpbiBjb2xvciBvYmplY3RcbiAqIEBwYXJhbSB7Q29sb3IgfCB7c3BhY2UsIGNvb3JkcywgYWxwaGF9IHwgc3RyaW5nfSBjb2xvclxuICogQHJldHVybnMge3tzcGFjZSwgY29vcmRzLCBhbHBoYX19XG4gKi9cbmZ1bmN0aW9uIGdldENvbG9yIChjb2xvcikge1xuXHRpZiAoIWNvbG9yKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkVtcHR5IGNvbG9yIHJlZmVyZW5jZVwiKTtcblx0fVxuXG5cdGlmIChpc1N0cmluZyhjb2xvcikpIHtcblx0XHRjb2xvciA9IHBhcnNlKGNvbG9yKTtcblx0fVxuXG5cdC8vIE9iamVjdCBmaXh1cFxuXHRsZXQgc3BhY2UgPSBjb2xvci5zcGFjZSB8fCBjb2xvci5zcGFjZUlkO1xuXG5cdGlmICghKHNwYWNlIGluc3RhbmNlb2YgQ29sb3JTcGFjZSkpIHtcblx0XHQvLyBDb252ZXJ0IHN0cmluZyBpZCB0byBjb2xvciBzcGFjZSBvYmplY3Rcblx0XHRjb2xvci5zcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblx0fVxuXG5cdGlmIChjb2xvci5hbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29sb3IuYWxwaGEgPSAxO1xuXHR9XG5cblx0cmV0dXJuIGNvbG9yO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYSBjb2xvciBpbiBhbm90aGVyIGNvbG9yIHNwYWNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBDb2xvclNwYWNlfSBzcGFjZVxuICogQHJldHVybnMge251bWJlcltdfVxuICovXG5mdW5jdGlvbiBnZXRBbGwgKGNvbG9yLCBzcGFjZSkge1xuXHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblx0cmV0dXJuIHNwYWNlLmZyb20oY29sb3IpO1xufVxuXG5mdW5jdGlvbiBnZXQgKGNvbG9yLCBwcm9wKSB7XG5cdGxldCB7c3BhY2UsIGluZGV4fSA9IENvbG9yU3BhY2UucmVzb2x2ZUNvb3JkKHByb3AsIGNvbG9yLnNwYWNlKTtcblx0bGV0IGNvb3JkcyA9IGdldEFsbChjb2xvciwgc3BhY2UpO1xuXHRyZXR1cm4gY29vcmRzW2luZGV4XTtcbn1cblxuZnVuY3Rpb24gc2V0QWxsIChjb2xvciwgc3BhY2UsIGNvb3Jkcykge1xuXHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblx0Y29sb3IuY29vcmRzID0gc3BhY2UudG8oY29sb3Iuc3BhY2UsIGNvb3Jkcyk7XG5cdHJldHVybiBjb2xvcjtcbn1cblxuLy8gU2V0IHByb3BlcnRpZXMgYW5kIHJldHVybiBjdXJyZW50IGluc3RhbmNlXG5mdW5jdGlvbiBzZXQgKGNvbG9yLCBwcm9wLCB2YWx1ZSkge1xuXHRjb2xvciA9IGdldENvbG9yKGNvbG9yKTtcblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlKGFyZ3VtZW50c1sxXSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBBcmd1bWVudCBpcyBhbiBvYmplY3QgbGl0ZXJhbFxuXHRcdGxldCBvYmplY3QgPSBhcmd1bWVudHNbMV07XG5cdFx0Zm9yIChsZXQgcCBpbiBvYmplY3QpIHtcblx0XHRcdHNldChjb2xvciwgcCwgb2JqZWN0W3BdKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGdldChjb2xvciwgcHJvcCkpO1xuXHRcdH1cblxuXHRcdGxldCB7c3BhY2UsIGluZGV4fSA9IENvbG9yU3BhY2UucmVzb2x2ZUNvb3JkKHByb3AsIGNvbG9yLnNwYWNlKTtcblx0XHRsZXQgY29vcmRzID0gZ2V0QWxsKGNvbG9yLCBzcGFjZSk7XG5cdFx0Y29vcmRzW2luZGV4XSA9IHZhbHVlO1xuXHRcdHNldEFsbChjb2xvciwgc3BhY2UsIGNvb3Jkcyk7XG5cdH1cblxuXHRyZXR1cm4gY29sb3I7XG59XG5cbnZhciBYWVpfRDUwID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJ4eXotZDUwXCIsXG5cdG5hbWU6IFwiWFlaIEQ1MFwiLFxuXHR3aGl0ZTogXCJENTBcIixcblx0YmFzZTogWFlaX0Q2NSxcblx0ZnJvbUJhc2U6IGNvb3JkcyA9PiBhZGFwdCQxKFhZWl9ENjUud2hpdGUsIFwiRDUwXCIsIGNvb3JkcyksXG5cdHRvQmFzZTogY29vcmRzID0+IGFkYXB0JDEoXCJENTBcIiwgWFlaX0Q2NS53aGl0ZSwgY29vcmRzKSxcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7fVxuXHR9LFxufSk7XG5cbi8vIM66ICogzrUgID0gMl4zID0gOFxuY29uc3QgzrUkMyA9IDIxNi8yNDM4OTsgIC8vIDZeMy8yOV4zID09ICgyNC8xMTYpXjNcbmNvbnN0IM61MyQxID0gMjQvMTE2O1xuY29uc3QgzrokMSA9IDI0Mzg5LzI3OyAgIC8vIDI5XjMvM14zXG5cbmxldCB3aGl0ZSQxID0gV0hJVEVTLkQ1MDtcblxudmFyIGxhYiA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwibGFiXCIsXG5cdG5hbWU6IFwiTGFiXCIsXG5cdGNvb3Jkczoge1xuXHRcdGw6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMTAwXSxcblx0XHRcdG5hbWU6IFwiTFwiXG5cdFx0fSxcblx0XHRhOiB7XG5cdFx0XHRyZWZSYW5nZTogWy0xMjUsIDEyNV1cblx0XHR9LFxuXHRcdGI6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTEyNSwgMTI1XVxuXHRcdH1cblx0fSxcblxuXHQvLyBBc3N1bWluZyBYWVogaXMgcmVsYXRpdmUgdG8gRDUwLCBjb252ZXJ0IHRvIENJRSBMYWJcblx0Ly8gZnJvbSBDSUUgc3RhbmRhcmQsIHdoaWNoIG5vdyBkZWZpbmVzIHRoZXNlIGFzIGEgcmF0aW9uYWwgZnJhY3Rpb25cblx0d2hpdGU6IHdoaXRlJDEsXG5cblx0YmFzZTogWFlaX0Q1MCxcblx0Ly8gQ29udmVydCBENTAtYWRhcHRlZCBYWVggdG8gTGFiXG5cdC8vICBDSUUgMTUuMzoyMDA0IHNlY3Rpb24gOC4yLjEuMVxuXHRmcm9tQmFzZSAoWFlaKSB7XG5cdFx0Ly8gY29tcHV0ZSB4eXosIHdoaWNoIGlzIFhZWiBzY2FsZWQgcmVsYXRpdmUgdG8gcmVmZXJlbmNlIHdoaXRlXG5cdFx0bGV0IHh5eiA9IFhZWi5tYXAoKHZhbHVlLCBpKSA9PiB2YWx1ZSAvIHdoaXRlJDFbaV0pO1xuXG5cdFx0Ly8gbm93IGNvbXB1dGUgZlxuXHRcdGxldCBmID0geHl6Lm1hcCh2YWx1ZSA9PiB2YWx1ZSA+IM61JDMgPyBNYXRoLmNicnQodmFsdWUpIDogKM66JDEgKiB2YWx1ZSArIDE2KS8xMTYpO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdCgxMTYgKiBmWzFdKSAtIDE2LCBcdCAvLyBMXG5cdFx0XHQ1MDAgKiAoZlswXSAtIGZbMV0pLCAvLyBhXG5cdFx0XHQyMDAgKiAoZlsxXSAtIGZbMl0pICAvLyBiXG5cdFx0XTtcblx0fSxcblx0Ly8gQ29udmVydCBMYWIgdG8gRDUwLWFkYXB0ZWQgWFlaXG5cdC8vIFNhbWUgcmVzdWx0IGFzIENJRSAxNS4zOjIwMDQgQXBwZW5kaXggRCBhbHRob3VnaCB0aGUgZGVyaXZhdGlvbiBpcyBkaWZmZXJlbnRcblx0Ly8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuXHR0b0Jhc2UgKExhYikge1xuXHRcdC8vIGNvbXB1dGUgZiwgc3RhcnRpbmcgd2l0aCB0aGUgbHVtaW5hbmNlLXJlbGF0ZWQgdGVybVxuXHRcdGxldCBmID0gW107XG5cdFx0ZlsxXSA9IChMYWJbMF0gKyAxNikvMTE2O1xuXHRcdGZbMF0gPSBMYWJbMV0vNTAwICsgZlsxXTtcblx0XHRmWzJdID0gZlsxXSAtIExhYlsyXS8yMDA7XG5cblx0XHQvLyBjb21wdXRlIHh5elxuXHRcdGxldCB4eXogPSBbXG5cdFx0XHRmWzBdICAgPiDOtTMkMSAgPyAgTWF0aC5wb3coZlswXSwgMykgICAgICAgICAgICA6ICgxMTYqZlswXS0xNikvzrokMSxcblx0XHRcdExhYlswXSA+IDggICA/ICBNYXRoLnBvdygoTGFiWzBdKzE2KS8xMTYsIDMpIDogTGFiWzBdL866JDEsXG5cdFx0XHRmWzJdICAgPiDOtTMkMSAgPyAgTWF0aC5wb3coZlsyXSwgMykgICAgICAgICAgICA6ICgxMTYqZlsyXS0xNikvzrokMVxuXHRcdF07XG5cblx0XHQvLyBDb21wdXRlIFhZWiBieSBzY2FsaW5nIHh5eiBieSByZWZlcmVuY2Ugd2hpdGVcblx0XHRyZXR1cm4geHl6Lm1hcCgodmFsdWUsIGkpID0+IHZhbHVlICogd2hpdGUkMVtpXSk7XG5cdH0sXG5cblx0Zm9ybWF0czoge1xuXHRcdFwibGFiXCI6IHtcblx0XHRcdGNvb3JkczogW1wiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5cIiwgXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlstMSwxXVwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+Wy0xLDFdXCJdLFxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNvbnN0cmFpbiAoYW5nbGUpIHtcblx0cmV0dXJuICgoYW5nbGUgJSAzNjApICsgMzYwKSAlIDM2MDtcbn1cblxuZnVuY3Rpb24gYWRqdXN0IChhcmMsIGFuZ2xlcykge1xuXHRpZiAoYXJjID09PSBcInJhd1wiKSB7XG5cdFx0cmV0dXJuIGFuZ2xlcztcblx0fVxuXG5cdGxldCBbYTEsIGEyXSA9IGFuZ2xlcy5tYXAoY29uc3RyYWluKTtcblxuXHRsZXQgYW5nbGVEaWZmID0gYTIgLSBhMTtcblxuXHRpZiAoYXJjID09PSBcImluY3JlYXNpbmdcIikge1xuXHRcdGlmIChhbmdsZURpZmYgPCAwKSB7XG5cdFx0XHRhMiArPSAzNjA7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKGFyYyA9PT0gXCJkZWNyZWFzaW5nXCIpIHtcblx0XHRpZiAoYW5nbGVEaWZmID4gMCkge1xuXHRcdFx0YTEgKz0gMzYwO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmIChhcmMgPT09IFwibG9uZ2VyXCIpIHtcblx0XHRpZiAoLTE4MCA8IGFuZ2xlRGlmZiAmJiBhbmdsZURpZmYgPCAxODApIHtcblx0XHRcdGlmIChhbmdsZURpZmYgPiAwKSB7XG5cdFx0XHRcdGExICs9IDM2MDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhMiArPSAzNjA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKGFyYyA9PT0gXCJzaG9ydGVyXCIpIHtcblx0XHRpZiAoYW5nbGVEaWZmID4gMTgwKSB7XG5cdFx0XHRhMSArPSAzNjA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGFuZ2xlRGlmZiA8IC0xODApIHtcblx0XHRcdGEyICs9IDM2MDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gW2ExLCBhMl07XG59XG5cbnZhciBsY2ggPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcImxjaFwiLFxuXHRuYW1lOiBcIkxDSFwiLFxuXHRjb29yZHM6IHtcblx0XHRsOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDEwMF0sXG5cdFx0XHRuYW1lOiBcIkxpZ2h0bmVzc1wiXG5cdFx0fSxcblx0XHRjOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDE1MF0sXG5cdFx0XHRuYW1lOiBcIkNocm9tYVwiXG5cdFx0fSxcblx0XHRoOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDM2MF0sXG5cdFx0XHR0eXBlOiBcImFuZ2xlXCIsXG5cdFx0XHRuYW1lOiBcIkh1ZVwiXG5cdFx0fVxuXHR9LFxuXG5cdGJhc2U6IGxhYixcblx0ZnJvbUJhc2UgKExhYikge1xuXHRcdC8vIENvbnZlcnQgdG8gcG9sYXIgZm9ybVxuXHRcdGxldCBbTCwgYSwgYl0gPSBMYWI7XG5cdFx0bGV0IGh1ZTtcblx0XHRjb25zdCDOtSA9IDAuMDI7XG5cblx0XHRpZiAoTWF0aC5hYnMoYSkgPCDOtSAmJiBNYXRoLmFicyhiKSA8IM61KSB7XG5cdFx0XHRodWUgPSBOYU47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aHVlID0gTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtcblx0XHRcdEwsIC8vIEwgaXMgc3RpbGwgTFxuXHRcdFx0TWF0aC5zcXJ0KGEgKiogMiArIGIgKiogMiksIC8vIENocm9tYVxuXHRcdFx0Y29uc3RyYWluKGh1ZSkgLy8gSHVlLCBpbiBkZWdyZWVzIFswIHRvIDM2MClcblx0XHRdO1xuXHR9LFxuXHR0b0Jhc2UgKExDSCkge1xuXHRcdC8vIENvbnZlcnQgZnJvbSBwb2xhciBmb3JtXG5cdFx0bGV0IFtMaWdodG5lc3MsIENocm9tYSwgSHVlXSA9IExDSDtcblx0XHQvLyBDbGFtcCBhbnkgbmVnYXRpdmUgQ2hyb21hXG5cdFx0aWYgKENocm9tYSA8IDApIHtcblx0XHRcdENocm9tYSA9IDA7XG5cdFx0fVx0XHQvLyBEZWFsIHdpdGggTmFOIEh1ZVxuXHRcdGlmIChpc05hTihIdWUpKSB7XG5cdFx0XHRIdWUgPSAwO1xuXHRcdH1cblx0XHRyZXR1cm4gW1xuXHRcdFx0TGlnaHRuZXNzLCAvLyBMIGlzIHN0aWxsIExcblx0XHRcdENocm9tYSAqIE1hdGguY29zKEh1ZSAqIE1hdGguUEkgLyAxODApLCAvLyBhXG5cdFx0XHRDaHJvbWEgKiBNYXRoLnNpbihIdWUgKiBNYXRoLlBJIC8gMTgwKSAgLy8gYlxuXHRcdF07XG5cdH0sXG5cblx0Zm9ybWF0czoge1xuXHRcdFwibGNoXCI6IHtcblx0XHRcdGNvb3JkczogW1wiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5cIiwgXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlwiLCBcIjxudW1iZXI+IHwgPGFuZ2xlPlwiXSxcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBkZWx0YUUyMDAwIGlzIGEgc3RhdGlzdGljYWxseSBzaWduaWZpY2FudCBpbXByb3ZlbWVudFxuLy8gYW5kIGlzIHJlY29tbWVuZGVkIGJ5IHRoZSBDSUUgYW5kIElkZWFsbGlhbmNlXG4vLyBlc3BlY2lhbGx5IGZvciBjb2xvciBkaWZmZXJlbmNlcyBsZXNzIHRoYW4gMTAgZGVsdGFFNzZcbi8vIGJ1dCBpcyB3aWNrZWQgY29tcGxpY2F0ZWRcbi8vIGFuZCBtYW55IGltcGxlbWVudGF0aW9ucyBoYXZlIHNtYWxsIGVycm9ycyFcbi8vIERlbHRhRTIwMDAgaXMgYWxzbyBkaXNjb250aW51b3VzOyBpbiBjYXNlIHRoaXNcbi8vIG1hdHRlcnMgdG8geW91LCB1c2UgZGVsdGFFQ01DIGluc3RlYWQuXG5cbmNvbnN0IEdmYWN0b3IgPSAyNSAqKiA3O1xuY29uc3Qgz4AkMSA9IE1hdGguUEk7XG5jb25zdCByMmQgPSAxODAgLyDPgCQxO1xuY29uc3QgZDJyJDEgPSDPgCQxIC8gMTgwO1xuXG5mdW5jdGlvbiBkZWx0YUUyMDAwIChjb2xvciwgc2FtcGxlLCB7a0wgPSAxLCBrQyA9IDEsIGtIID0gMX0gPSB7fSkge1xuXHQvLyBHaXZlbiB0aGlzIGNvbG9yIGFzIHRoZSByZWZlcmVuY2Vcblx0Ly8gYW5kIHRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIgYXMgdGhlIHNhbXBsZSxcblx0Ly8gY2FsY3VsYXRlIGRlbHRhRSAyMDAwLlxuXG5cdC8vIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGUgcGFyYW1ldHJpY1xuXHQvLyB3ZWlnaHRpbmcgZmFjdG9ycyBrTCwga0MgYW5kIGtIXG5cdC8vIGZvciB0aGUgaW5mbHVlbmNlIG9mIHZpZXdpbmcgY29uZGl0aW9uc1xuXHQvLyBhcmUgYWxsIDEsIGFzIHNhZGx5IHNlZW1zIHR5cGljYWwuXG5cdC8vIGtMIHNob3VsZCBiZSBpbmNyZWFzZWQgZm9yIGxpZ2h0bmVzcyB0ZXh0dXJlIG9yIG5vaXNlXG5cdC8vIGFuZCBrQyBpbmNyZWFzZWQgZm9yIGNocm9tYSBub2lzZVxuXG5cdGxldCBbTDEsIGExLCBiMV0gPSBsYWIuZnJvbShjb2xvcik7XG5cdGxldCBDMSA9IGxjaC5mcm9tKGxhYiwgW0wxLCBhMSwgYjFdKVsxXTtcblx0bGV0IFtMMiwgYTIsIGIyXSA9IGxhYi5mcm9tKHNhbXBsZSk7XG5cdGxldCBDMiA9IGxjaC5mcm9tKGxhYiwgW0wyLCBhMiwgYjJdKVsxXTtcblxuXHQvLyBDaGVjayBmb3IgbmVnYXRpdmUgQ2hyb21hLFxuXHQvLyB3aGljaCBtaWdodCBoYXBwZW4gdGhyb3VnaFxuXHQvLyBkaXJlY3QgdXNlciBpbnB1dCBvZiBMQ0ggdmFsdWVzXG5cblx0aWYgKEMxIDwgMCkge1xuXHRcdEMxID0gMDtcblx0fVxuXHRpZiAoQzIgPCAwKSB7XG5cdFx0QzIgPSAwO1xuXHR9XG5cblx0bGV0IENiYXIgPSAoQzEgKyBDMikvMjsgLy8gbWVhbiBDaHJvbWFcblxuXHQvLyBjYWxjdWxhdGUgYS1heGlzIGFzeW1tZXRyeSBmYWN0b3IgZnJvbSBtZWFuIENocm9tYVxuXHQvLyB0aGlzIHR1cm5zIEpORCBlbGxpcHNlcyBmb3IgbmVhci1uZXV0cmFsIGNvbG9ycyBiYWNrIGludG8gY2lyY2xlc1xuXHRsZXQgQzcgPSBDYmFyICoqIDc7XG5cblx0bGV0IEcgPSAwLjUgKiAoMSAtIE1hdGguc3FydChDNy8oQzcgKyBHZmFjdG9yKSkpO1xuXG5cdC8vIHNjYWxlIGEgYXhlcyBieSBhc3ltbWV0cnkgZmFjdG9yXG5cdC8vIHRoaXMgYnkgdGhlIHdheSBpcyB3aHkgdGhlcmUgaXMgbm8gTGFiMjAwMCBjb2xvcnNwYWNlXG5cdGxldCBhZGFzaDEgPSAoMSArIEcpICogYTE7XG5cdGxldCBhZGFzaDIgPSAoMSArIEcpICogYTI7XG5cblx0Ly8gY2FsY3VsYXRlIG5ldyBDaHJvbWEgZnJvbSBzY2FsZWQgYSBhbmQgb3JpZ2luYWwgYiBheGVzXG5cdGxldCBDZGFzaDEgPSBNYXRoLnNxcnQoYWRhc2gxICoqIDIgKyBiMSAqKiAyKTtcblx0bGV0IENkYXNoMiA9IE1hdGguc3FydChhZGFzaDIgKiogMiArIGIyICoqIDIpO1xuXG5cdC8vIGNhbGN1bGF0ZSBuZXcgaHVlcywgd2l0aCB6ZXJvIGh1ZSBmb3IgdHJ1ZSBuZXV0cmFsc1xuXHQvLyBhbmQgaW4gZGVncmVlcywgbm90IHJhZGlhbnNcblxuXHRsZXQgaDEgPSAoYWRhc2gxID09PSAwICYmIGIxID09PSAwKT8gMDogTWF0aC5hdGFuMihiMSwgYWRhc2gxKTtcblx0bGV0IGgyID0gKGFkYXNoMiA9PT0gMCAmJiBiMiA9PT0gMCk/IDA6IE1hdGguYXRhbjIoYjIsIGFkYXNoMik7XG5cblx0aWYgKGgxIDwgMCkge1xuXHRcdGgxICs9IDIgKiDPgCQxO1xuXHR9XG5cdGlmIChoMiA8IDApIHtcblx0XHRoMiArPSAyICogz4AkMTtcblx0fVxuXG5cdGgxICo9IHIyZDtcblx0aDIgKj0gcjJkO1xuXG5cdC8vIExpZ2h0bmVzcyBhbmQgQ2hyb21hIGRpZmZlcmVuY2VzOyBzaWduIG1hdHRlcnNcblx0bGV0IM6UTCA9IEwyIC0gTDE7XG5cdGxldCDOlEMgPSBDZGFzaDIgLSBDZGFzaDE7XG5cblx0Ly8gSHVlIGRpZmZlcmVuY2UsIGdldHRpbmcgdGhlIHNpZ24gY29ycmVjdFxuXHRsZXQgaGRpZmYgPSBoMiAtIGgxO1xuXHRsZXQgaHN1bSA9IGgxICsgaDI7XG5cdGxldCBoYWJzID0gTWF0aC5hYnMoaGRpZmYpO1xuXHRsZXQgzpRoO1xuXG5cdGlmIChDZGFzaDEgKiBDZGFzaDIgPT09IDApIHtcblx0XHTOlGggPSAwO1xuXHR9XG5cdGVsc2UgaWYgKGhhYnMgPD0gMTgwKSB7XG5cdFx0zpRoID0gaGRpZmY7XG5cdH1cblx0ZWxzZSBpZiAoaGRpZmYgPiAxODApIHtcblx0XHTOlGggPSBoZGlmZiAtIDM2MDtcblx0fVxuXHRlbHNlIGlmIChoZGlmZiA8IC0xODApIHtcblx0XHTOlGggPSBoZGlmZiArIDM2MDtcblx0fVxuXHRlbHNlIHtcblx0XHRjb25zb2xlLmxvZyhcInRoZSB1bnRoaW5rYWJsZSBoYXMgaGFwcGVuZWRcIik7XG5cdH1cblxuXHQvLyB3ZWlnaHRlZCBIdWUgZGlmZmVyZW5jZSwgbW9yZSBmb3IgbGFyZ2VyIENocm9tYVxuXHRsZXQgzpRIID0gMiAqIE1hdGguc3FydChDZGFzaDIgKiBDZGFzaDEpICogTWF0aC5zaW4ozpRoICogZDJyJDEgLyAyKTtcblxuXHQvLyBjYWxjdWxhdGUgbWVhbiBMaWdodG5lc3MgYW5kIENocm9tYVxuXHRsZXQgTGRhc2ggPSAoTDEgKyBMMikvMjtcblx0bGV0IENkYXNoID0gKENkYXNoMSArIENkYXNoMikvMjtcblx0bGV0IENkYXNoNyA9IE1hdGgucG93KENkYXNoLCA3KTtcblxuXHQvLyBDb21wZW5zYXRlIGZvciBub24tbGluZWFyaXR5IGluIHRoZSBibHVlIHJlZ2lvbiBvZiBMYWIuXG5cdC8vIEZvdXIgcG9zc2liaWxpdGllcyBmb3IgaHVlIHdlaWdodGluZyBmYWN0b3IsXG5cdC8vIGRlcGVuZGluZyBvbiB0aGUgYW5nbGVzLCB0byBnZXQgdGhlIGNvcnJlY3Qgc2lnblxuXHRsZXQgaGRhc2g7XG5cdGlmIChDZGFzaDEgKiBDZGFzaDIgPT09IDApIHtcblx0XHRoZGFzaCA9IGhzdW07ICAgLy8gd2hpY2ggc2hvdWxkIGJlIHplcm9cblx0fVxuXHRlbHNlIGlmIChoYWJzIDw9IDE4MCkge1xuXHRcdGhkYXNoID0gaHN1bSAvIDI7XG5cdH1cblx0ZWxzZSBpZiAoaHN1bSA8IDM2MCkge1xuXHRcdGhkYXNoID0gKGhzdW0gKyAzNjApIC8gMjtcblx0fVxuXHRlbHNlIHtcblx0XHRoZGFzaCA9IChoc3VtIC0gMzYwKSAvIDI7XG5cdH1cblxuXHQvLyBwb3NpdGlvbmFsIGNvcnJlY3Rpb25zIHRvIHRoZSBsYWNrIG9mIHVuaWZvcm1pdHkgb2YgQ0lFTEFCXG5cdC8vIFRoZXNlIGFyZSBhbGwgdHJ5aW5nIHRvIG1ha2UgSk5EIGVsbGlwc29pZHMgbW9yZSBsaWtlIHNwaGVyZXNcblxuXHQvLyBTTCBMaWdodG5lc3MgY3Jpc3BlbmluZyBmYWN0b3Jcblx0Ly8gYSBiYWNrZ3JvdW5kIHdpdGggTD01MCBpcyBhc3N1bWVkXG5cdGxldCBsc3EgPSAoTGRhc2ggLSA1MCkgKiogMjtcblx0bGV0IFNMID0gMSArICgoMC4wMTUgKiBsc3EpIC8gTWF0aC5zcXJ0KDIwICsgbHNxKSk7XG5cblx0Ly8gU0MgQ2hyb21hIGZhY3Rvciwgc2ltaWxhciB0byB0aG9zZSBpbiBDTUMgYW5kIGRlbHRhRSA5NCBmb3JtdWxhZVxuXHRsZXQgU0MgPSAxICsgMC4wNDUgKiBDZGFzaDtcblxuXHQvLyBDcm9zcyB0ZXJtIFQgZm9yIGJsdWUgbm9uLWxpbmVhcml0eVxuXHRsZXQgVCA9IDE7XG5cdFQgLT0gKDAuMTcgKiBNYXRoLmNvcygoICAgICBoZGFzaCAtIDMwKSAgKiBkMnIkMSkpO1xuXHRUICs9ICgwLjI0ICogTWF0aC5jb3MoICAyICogaGRhc2ggICAgICAgICogZDJyJDEpKTtcblx0VCArPSAoMC4zMiAqIE1hdGguY29zKCgoMyAqIGhkYXNoKSArIDYpICAqIGQyciQxKSk7XG5cdFQgLT0gKDAuMjAgKiBNYXRoLmNvcygoKDQgKiBoZGFzaCkgLSA2MykgKiBkMnIkMSkpO1xuXG5cdC8vIFNIIEh1ZSBmYWN0b3IgZGVwZW5kcyBvbiBDaHJvbWEsXG5cdC8vIGFzIHdlbGwgYXMgYWRqdXN0ZWQgaHVlIGFuZ2xlIGxpa2UgZGVsdGFFOTQuXG5cdGxldCBTSCA9IDEgKyAwLjAxNSAqIENkYXNoICogVDtcblxuXHQvLyBSVCBIdWUgcm90YXRpb24gdGVybSBjb21wZW5zYXRlcyBmb3Igcm90YXRpb24gb2YgSk5EIGVsbGlwc2VzXG5cdC8vIGFuZCBNdW5zZWxsIGNvbnN0YW50IGh1ZSBsaW5lc1xuXHQvLyBpbiB0aGUgbWVkaXVtLWhpZ2ggQ2hyb21hIGJsdWUgcmVnaW9uXG5cdC8vIChIdWUgMjI1IHRvIDMxNSlcblx0bGV0IM6UzrggPSAzMCAqIE1hdGguZXhwKC0xICogKCgoaGRhc2ggLSAyNzUpLzI1KSAqKiAyKSk7XG5cdGxldCBSQyA9IDIgKiBNYXRoLnNxcnQoQ2Rhc2g3LyhDZGFzaDcgKyBHZmFjdG9yKSk7XG5cdGxldCBSVCA9IC0xICogTWF0aC5zaW4oMiAqIM6UzrggKiBkMnIkMSkgKiBSQztcblxuXHQvLyBGaW5hbGx5IGNhbGN1bGF0ZSB0aGUgZGVsdGFFLCB0ZXJtIGJ5IHRlcm0gYXMgcm9vdCBzdW1lIG9mIHNxdWFyZXNcblx0bGV0IGRFID0gKM6UTCAvIChrTCAqIFNMKSkgKiogMjtcblx0ZEUgKz0gKM6UQyAvIChrQyAqIFNDKSkgKiogMjtcblx0ZEUgKz0gKM6USCAvIChrSCAqIFNIKSkgKiogMjtcblx0ZEUgKz0gUlQgKiAozpRDIC8gKGtDICogU0MpKSAqICjOlEggLyAoa0ggKiBTSCkpO1xuXHRyZXR1cm4gTWF0aC5zcXJ0KGRFKTtcblx0Ly8gWWF5ISEhXG59XG5cbmNvbnN0IM61JDIgPSAuMDAwMDc1O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY29sb3IgaXMgaW4gZ2FtdXQgb2YgZWl0aGVyIGl0cyBvd24gb3IgYW5vdGhlciBjb2xvciBzcGFjZVxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgdGhlIGNvbG9yIGluIGdhbXV0P1xuICovXG5mdW5jdGlvbiBpbkdhbXV0IChjb2xvciwgc3BhY2UgPSBjb2xvci5zcGFjZSwge2Vwc2lsb24gPSDOtSQyfSA9IHt9KSB7XG5cdGNvbG9yID0gZ2V0Q29sb3IoY29sb3IpO1xuXHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblx0bGV0IGNvb3JkcyA9IGNvbG9yLmNvb3JkcztcblxuXHRpZiAoc3BhY2UgIT09IGNvbG9yLnNwYWNlKSB7XG5cdFx0Y29vcmRzID0gc3BhY2UuZnJvbShjb2xvcik7XG5cdH1cblxuXHRyZXR1cm4gc3BhY2UuaW5HYW11dChjb29yZHMsIHtlcHNpbG9ufSk7XG59XG5cbmZ1bmN0aW9uIGNsb25lIChjb2xvcikge1xuXHRyZXR1cm4ge1xuXHRcdHNwYWNlOiBjb2xvci5zcGFjZSxcblx0XHRjb29yZHM6IGNvbG9yLmNvb3Jkcy5zbGljZSgpLFxuXHRcdGFscGhhOiBjb2xvci5hbHBoYVxuXHR9O1xufVxuXG4vKipcbiAqIEZvcmNlIGNvb3JkaW5hdGVzIHRvIGJlIGluIGdhbXV0IG9mIGEgY2VydGFpbiBjb2xvciBzcGFjZS5cbiAqIE11dGF0ZXMgdGhlIGNvbG9yIGl0IGlzIHBhc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZXRob2QgLSBIb3cgdG8gZm9yY2UgaW50byBnYW11dC5cbiAqICAgICAgICBJZiBcImNsaXBcIiwgY29vcmRpbmF0ZXMgYXJlIGp1c3QgY2xpcHBlZCB0byB0aGVpciByZWZlcmVuY2UgcmFuZ2UuXG4gKiAgICAgICAgSWYgaW4gdGhlIGZvcm0gW2NvbG9yU3BhY2VJZF0uW2Nvb3JkTmFtZV0sIHRoYXQgY29vcmRpbmF0ZSBpcyByZWR1Y2VkXG4gKiAgICAgICAgdW50aWwgdGhlIGNvbG9yIGlzIGluIGdhbXV0LiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgbWF5IHByb2R1Y2Ugbm9uc2Vuc2ljYWxcbiAqICAgICAgICByZXN1bHRzIGZvciBjZXJ0YWluIGNvb3JkaW5hdGVzIChlLmcuIGh1ZSkgb3IgaW5maW5pdGUgbG9vcHMgaWYgcmVkdWNpbmcgdGhlIGNvb3JkaW5hdGUgbmV2ZXIgYnJpbmdzIHRoZSBjb2xvciBpbiBnYW11dC5cbiAqIEBwYXJhbSB7Q29sb3JTcGFjZXxzdHJpbmd9IG9wdGlvbnMuc3BhY2UgLSBUaGUgc3BhY2Ugd2hvc2UgZ2FtdXQgd2Ugd2FudCB0byBtYXAgdG9cbiAqL1xuZnVuY3Rpb24gdG9HYW11dCAoY29sb3IsIHttZXRob2QgPSBkZWZhdWx0cy5nYW11dF9tYXBwaW5nLCBzcGFjZSA9IGNvbG9yLnNwYWNlfSA9IHt9KSB7XG5cdGlmIChpc1N0cmluZyhhcmd1bWVudHNbMV0pKSB7XG5cdFx0c3BhY2UgPSBhcmd1bWVudHNbMV07XG5cdH1cblxuXHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblxuXHRpZiAoaW5HYW11dChjb2xvciwgc3BhY2UsIHtlcHNpbG9uOiAwfSkpIHtcblx0XHRyZXR1cm4gZ2V0Q29sb3IoY29sb3IpO1xuXHR9XG5cblx0Ly8gMyBzcGFjZXM6XG5cdC8vIGNvbG9yLnNwYWNlOiBjdXJyZW50IGNvbG9yIHNwYWNlXG5cdC8vIHNwYWNlOiBzcGFjZSB3aG9zZSBnYW11dCB3ZSBhcmUgbWFwcGluZyB0b1xuXHQvLyBtYXBTcGFjZTogc3BhY2Ugd2l0aCB0aGUgY29vcmQgd2UncmUgcmVkdWNpbmdcblx0bGV0IHNwYWNlQ29sb3IgPSB0byhjb2xvciwgc3BhY2UpO1xuXG5cdGlmIChtZXRob2QgIT09IFwiY2xpcFwiICYmICFpbkdhbXV0KGNvbG9yLCBzcGFjZSkpIHtcblx0XHRsZXQgY2xpcHBlZCA9IHRvR2FtdXQoY2xvbmUoc3BhY2VDb2xvciksIHttZXRob2Q6IFwiY2xpcFwiLCBzcGFjZX0pO1xuXHRcdGlmIChkZWx0YUUyMDAwKGNvbG9yLCBjbGlwcGVkKSA+IDIpIHtcblx0XHRcdC8vIFJlZHVjZSBhIGNvb3JkaW5hdGUgb2YgYSBjZXJ0YWluIGNvbG9yIHNwYWNlIHVudGlsIHRoZSBjb2xvciBpcyBpbiBnYW11dFxuXHRcdFx0bGV0IGNvb3JkTWV0YSA9IENvbG9yU3BhY2UucmVzb2x2ZUNvb3JkKG1ldGhvZCk7XG5cdFx0XHRsZXQgbWFwU3BhY2UgPSBjb29yZE1ldGEuc3BhY2U7XG5cdFx0XHRsZXQgY29vcmRJZCA9IGNvb3JkTWV0YS5pZDtcblxuXHRcdFx0bGV0IG1hcHBlZENvbG9yID0gdG8oc3BhY2VDb2xvciwgbWFwU3BhY2UpO1xuXHRcdFx0bGV0IGJvdW5kcyA9IGNvb3JkTWV0YS5yYW5nZSB8fCBjb29yZE1ldGEucmVmUmFuZ2U7XG5cdFx0XHRsZXQgbWluID0gYm91bmRzWzBdO1xuXHRcdFx0bGV0IM61ID0gLjAxOyAvLyBmb3IgZGVsdGFFXG5cdFx0XHRsZXQgbG93ID0gbWluO1xuXHRcdFx0bGV0IGhpZ2ggPSBnZXQobWFwcGVkQ29sb3IsIGNvb3JkSWQpO1xuXG5cdFx0XHR3aGlsZSAoaGlnaCAtIGxvdyA+IM61KSB7XG5cdFx0XHRcdGxldCBjbGlwcGVkID0gY2xvbmUobWFwcGVkQ29sb3IpO1xuXHRcdFx0XHRjbGlwcGVkID0gdG9HYW11dChjbGlwcGVkLCB7c3BhY2UsIG1ldGhvZDogXCJjbGlwXCJ9KTtcblx0XHRcdFx0bGV0IGRlbHRhRSA9IGRlbHRhRTIwMDAobWFwcGVkQ29sb3IsIGNsaXBwZWQpO1xuXG5cdFx0XHRcdGlmIChkZWx0YUUgLSAyIDwgzrUpIHtcblx0XHRcdFx0XHRsb3cgPSBnZXQobWFwcGVkQ29sb3IsIGNvb3JkSWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGhpZ2ggPSBnZXQobWFwcGVkQ29sb3IsIGNvb3JkSWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0KG1hcHBlZENvbG9yLCBjb29yZElkLCAobG93ICsgaGlnaCkgLyAyKTtcblx0XHRcdH1cblxuXHRcdFx0c3BhY2VDb2xvciA9IHRvKG1hcHBlZENvbG9yLCBzcGFjZSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c3BhY2VDb2xvciA9IGNsaXBwZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG1ldGhvZCA9PT0gXCJjbGlwXCIgLy8gRHVtYiBjb29yZCBjbGlwcGluZ1xuXHRcdC8vIGZpbmlzaCBvZmYgc21hcnRlciBnYW11dCBtYXBwaW5nIHdpdGggY2xpcCB0byBnZXQgcmlkIG9mIM61LCBzZWUgIzE3XG5cdFx0fHwgIWluR2FtdXQoc3BhY2VDb2xvciwgc3BhY2UsIHtlcHNpbG9uOiAwfSlcblx0KSB7XG5cdFx0bGV0IGJvdW5kcyA9IE9iamVjdC52YWx1ZXMoc3BhY2UuY29vcmRzKS5tYXAoYyA9PiBjLnJhbmdlIHx8IFtdKTtcblxuXHRcdHNwYWNlQ29sb3IuY29vcmRzID0gc3BhY2VDb2xvci5jb29yZHMubWFwKChjLCBpKSA9PiB7XG5cdFx0XHRsZXQgW21pbiwgbWF4XSA9IGJvdW5kc1tpXTtcblxuXHRcdFx0aWYgKG1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGMgPSBNYXRoLm1heChtaW4sIGMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YyA9IE1hdGgubWluKGMsIG1heCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKHNwYWNlICE9PSBjb2xvci5zcGFjZSkge1xuXHRcdHNwYWNlQ29sb3IgPSB0byhzcGFjZUNvbG9yLCBjb2xvci5zcGFjZSk7XG5cdH1cblxuXHRjb2xvci5jb29yZHMgPSBzcGFjZUNvbG9yLmNvb3Jkcztcblx0cmV0dXJuIGNvbG9yO1xufVxuXG50b0dhbXV0LnJldHVybnMgPSBcImNvbG9yXCI7XG5cbi8qKlxuICogQ29udmVydCB0byBjb2xvciBzcGFjZSBhbmQgcmV0dXJuIGEgbmV3IGNvbG9yXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHNwYWNlIC0gQ29sb3Igc3BhY2Ugb2JqZWN0IG9yIGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmluR2FtdXQgLSBXaGV0aGVyIHRvIGZvcmNlIHJlc3VsdGluZyBjb2xvciBpbiBnYW11dFxuICogQHJldHVybnMge0NvbG9yfVxuICovXG5mdW5jdGlvbiB0byAoY29sb3IsIHNwYWNlLCB7aW5HYW11dH0gPSB7fSkge1xuXHRjb2xvciA9IGdldENvbG9yKGNvbG9yKTtcblx0c3BhY2UgPSBDb2xvclNwYWNlLmdldChzcGFjZSk7XG5cblx0bGV0IGNvb3JkcyA9IHNwYWNlLmZyb20oY29sb3IpO1xuXHRsZXQgcmV0ID0ge3NwYWNlLCBjb29yZHMsIGFscGhhOiBjb2xvci5hbHBoYX07XG5cblx0aWYgKGluR2FtdXQpIHtcblx0XHRyZXQgPSB0b0dhbXV0KHJldCk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG50by5yZXR1cm5zID0gXCJjb2xvclwiO1xuXG4vKipcbiAqIEdlbmVyaWMgdG9TdHJpbmcoKSBtZXRob2QsIG91dHB1dHMgYSBjb2xvcihzcGFjZUlkIC4uLmNvb3JkcykgZnVuY3Rpb24sIGEgZnVuY3Rpb25hbCBzeW50YXgsIG9yIGN1c3RvbSBmb3JtYXRzIGRlZmluZWQgYnkgdGhlIGNvbG9yIHNwYWNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucHJlY2lzaW9uIC0gU2lnbmlmaWNhbnQgZGlnaXRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaW5HYW11dCAtIEFkanVzdCBjb29yZGluYXRlcyB0byBmaXQgaW4gZ2FtdXQgZmlyc3Q/IFtkZWZhdWx0OiBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplIChjb2xvciwge1xuXHRwcmVjaXNpb24gPSBkZWZhdWx0cy5wcmVjaXNpb24sXG5cdGZvcm1hdCA9IFwiZGVmYXVsdFwiLFxuXHRpbkdhbXV0OiBpbkdhbXV0JDEgPSB0cnVlLFxuXHQuLi5jdXN0b21PcHRpb25zXG59ID0ge30pIHtcblx0bGV0IHJldDtcblxuXHRjb2xvciA9IGdldENvbG9yKGNvbG9yKTtcblxuXHRsZXQgZm9ybWF0SWQgPSBmb3JtYXQ7XG5cdGZvcm1hdCA9IGNvbG9yLnNwYWNlLmdldEZvcm1hdChmb3JtYXQpXG5cdFx0ICAgPz8gY29sb3Iuc3BhY2UuZ2V0Rm9ybWF0KFwiZGVmYXVsdFwiKVxuXHRcdCAgID8/IENvbG9yU3BhY2UuREVGQVVMVF9GT1JNQVQ7XG5cblx0aW5HYW11dCQxIHx8PSBmb3JtYXQudG9HYW11dDtcblxuXHRsZXQgY29vcmRzID0gY29sb3IuY29vcmRzO1xuXG5cdC8vIENvbnZlcnQgTmFOIHRvIHplcm9zIHRvIGhhdmUgYSBjaGFuY2UgYXQgYSB2YWxpZCBDU1MgY29sb3Jcblx0Ly8gQWxzbyBjb252ZXJ0IC0wIHRvIDBcblx0Ly8gVGhpcyBhbHNvIGNsb25lcyBpdCBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSBpdFxuXHRjb29yZHMgPSBjb29yZHMubWFwKGMgPT4gYz8gYyA6IDApO1xuXG5cdGlmIChpbkdhbXV0JDEgJiYgIWluR2FtdXQoY29sb3IpKSB7XG5cdFx0Y29vcmRzID0gdG9HYW11dChjbG9uZShjb2xvciksIGluR2FtdXQkMSA9PT0gdHJ1ZT8gdW5kZWZpbmVkIDogaW5HYW11dCQxKS5jb29yZHM7XG5cdH1cblxuXHRpZiAoZm9ybWF0LnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcblx0XHRjdXN0b21PcHRpb25zLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcblxuXHRcdGlmIChmb3JtYXQuc2VyaWFsaXplKSB7XG5cdFx0XHRyZXQgPSBmb3JtYXQuc2VyaWFsaXplKGNvb3JkcywgY29sb3IuYWxwaGEsIGN1c3RvbU9wdGlvbnMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYGZvcm1hdCAke2Zvcm1hdElkfSBjYW4gb25seSBiZSB1c2VkIHRvIHBhcnNlIGNvbG9ycywgbm90IGZvciBzZXJpYWxpemF0aW9uYCk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEZ1bmN0aW9uYWwgc3ludGF4XG5cdFx0bGV0IG5hbWUgPSBmb3JtYXQubmFtZSB8fCBcImNvbG9yXCI7XG5cblx0XHRpZiAoZm9ybWF0LnNlcmlhbGl6ZUNvb3Jkcykge1xuXHRcdFx0Y29vcmRzID0gZm9ybWF0LnNlcmlhbGl6ZUNvb3Jkcyhjb29yZHMsIHByZWNpc2lvbik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHByZWNpc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRjb29yZHMgPSBjb29yZHMubWFwKGMgPT4gdG9QcmVjaXNpb24oYywgcHJlY2lzaW9uKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGFyZ3MgPSBbLi4uY29vcmRzXTtcblxuXHRcdGlmIChuYW1lID09PSBcImNvbG9yXCIpIHtcblx0XHRcdC8vIElmIG91dHB1dCBpcyBhIGNvbG9yKCkgZnVuY3Rpb24sIGFkZCBjb2xvcnNwYWNlIGlkIGFzIGZpcnN0IGFyZ3VtZW50XG5cdFx0XHRsZXQgY3NzSWQgPSBmb3JtYXQuaWQgfHwgZm9ybWF0Lmlkcz8uWzBdIHx8IGNvbG9yLnNwYWNlLmlkO1xuXHRcdFx0YXJncy51bnNoaWZ0KGNzc0lkKTtcblx0XHR9XG5cblx0XHRsZXQgYWxwaGEgPSBjb2xvci5hbHBoYTtcblx0XHRpZiAocHJlY2lzaW9uICE9PSBudWxsKSB7XG5cdFx0XHRhbHBoYSA9IHRvUHJlY2lzaW9uKGFscGhhLCBwcmVjaXNpb24pO1xuXHRcdH1cblxuXHRcdGxldCBzdHJBbHBoYSA9IGNvbG9yLmFscGhhIDwgMSAmJiAhZm9ybWF0Lm5vQWxwaGE/IGAke2Zvcm1hdC5jb21tYXM/IFwiLFwiIDogXCIgL1wifSAke2FscGhhfWAgOiBcIlwiO1xuXHRcdHJldCA9IGAke25hbWV9KCR7YXJncy5qb2luKGZvcm1hdC5jb21tYXM/IFwiLCBcIiA6IFwiIFwiKX0ke3N0ckFscGhhfSlgO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuLy8gY29udmVydCBhbiBhcnJheSBvZiBsaW5lYXItbGlnaHQgcmVjMjAyMCB2YWx1ZXMgdG8gQ0lFIFhZWlxuLy8gdXNpbmcgIEQ2NSAobm8gY2hyb21hdGljIGFkYXB0YXRpb24pXG4vLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9SR0JfWFlaX01hdHJpeC5odG1sXG4vLyAwIGlzIGFjdHVhbGx5IGNhbGN1bGF0ZWQgYXMgIDQuOTk0MTA2NTc0NDY2MDc2ZS0xN1xuY29uc3QgdG9YWVpfTSQ1ID0gW1xuXHRbIDAuNjM2OTU4MDQ4MzAxMjkxNCwgMC4xNDQ2MTY5MDM1ODYyMDgzMiwgIDAuMTY4ODgwOTc1MTY0MTcyMSAgXSxcblx0WyAwLjI2MjcwMDIxMjAxMTI2NzEsIDAuNjc3OTk4MDcxNTE4ODcwOCwgICAwLjA1OTMwMTcxNjQ2OTg2MTk2IF0sXG5cdFsgMC4wMDAwMDAwMDAwMDAwMDAsICAwLjAyODA3MjY5MzA0OTA4NzQyOCwgMS4wNjA5ODUwNTc3MTA3OTEgICBdXG5dO1xuXG4vLyBmcm9tIElUVS1SIEJULjIxMjQtMCBBbm5leCAyIHAuM1xuY29uc3QgZnJvbVhZWl9NJDUgPSBbXG5cdFsgIDEuNzE2NjUxMTg3OTcxMjY4LCAgLTAuMzU1NjcwNzgzNzc2MzkyLCAtMC4yNTMzNjYyODEzNzM2NjAgIF0sXG5cdFsgLTAuNjY2Njg0MzUxODMyNDg5LCAgIDEuNjE2NDgxMjM2NjM0OTM5LCAgMC4wMTU3Njg1NDU4MTM5MTExIF0sXG5cdFsgIDAuMDE3NjM5ODU3NDQ1MzExLCAgLTAuMDQyNzcwNjEzMjU3ODA5LCAgMC45NDIxMDMxMjEyMzU0NzQgIF1cbl07XG5cbnZhciBSRUMyMDIwTGluZWFyID0gbmV3IFJHQkNvbG9yU3BhY2Uoe1xuXHRpZDogXCJyZWMyMDIwLWxpbmVhclwiLFxuXHRuYW1lOiBcIkxpbmVhciBSRUMuMjAyMFwiLFxuXHR3aGl0ZTogXCJENjVcIixcblx0dG9YWVpfTTogdG9YWVpfTSQ1LFxuXHRmcm9tWFlaX006IGZyb21YWVpfTSQ1LFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHt9LFxuXHR9XG59KTtcblxuLy8gaW1wb3J0IHNSR0IgZnJvbSBcIi4vc3JnYi5qc1wiO1xuXG5jb25zdCDOsSA9IDEuMDk5Mjk2ODI2ODA5NDQ7XG5jb25zdCDOsiA9IDAuMDE4MDUzOTY4NTEwODA3O1xuXG52YXIgUkVDMjAyMCA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwicmVjMjAyMFwiLFxuXHRuYW1lOiBcIlJFQy4yMDIwXCIsXG5cdGJhc2U6IFJFQzIwMjBMaW5lYXIsXG5cdC8vIE5vbi1saW5lYXIgdHJhbnNmZXIgZnVuY3Rpb24gZnJvbSBSZWMuIElUVS1SIEJULjIwMjAtMiB0YWJsZSA0XG5cdHRvQmFzZSAoUkdCKSB7XG5cdFx0cmV0dXJuIFJHQi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0aWYgKHZhbCA8IM6yICogNC41ICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsIC8gNC41O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coKHZhbCArIM6xIC0xICkgLyDOsSwgMS8wLjQ1KTtcblx0XHR9KTtcblx0fSxcblx0ZnJvbUJhc2UgKFJHQikge1xuXHRcdHJldHVybiBSR0IubWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdGlmICh2YWwgPj0gzrIgKSB7XG5cdFx0XHRcdHJldHVybiDOsSAqIE1hdGgucG93KHZhbCwgMC40NSkgLSAozrEgLSAxKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDQuNSAqIHZhbDtcblx0XHR9KTtcblx0fSxcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7fSxcblx0fVxufSk7XG5cbmNvbnN0IHRvWFlaX00kNCA9IFtcblx0WzAuNDg2NTcwOTQ4NjQ4MjE2MiwgMC4yNjU2Njc2OTMxNjkwOTMwNiwgMC4xOTgyMTcyODUyMzQzNjI1XSxcblx0WzAuMjI4OTc0NTY0MDY5NzQ4OCwgMC42OTE3Mzg1MjE4MzY1MDY0LCAgMC4wNzkyODY5MTQwOTM3NDVdLFxuXHRbMC4wMDAwMDAwMDAwMDAwMDAwLCAwLjA0NTExMzM4MTg1ODkwMjY0LCAxLjA0Mzk0NDM2ODkwMDk3Nl1cbl07XG5cbmNvbnN0IGZyb21YWVpfTSQ0ID0gW1xuXHRbIDIuNDkzNDk2OTExOTQxNDI1LCAgIC0wLjkzMTM4MzYxNzkxOTEyMzksIC0wLjQwMjcxMDc4NDQ1MDcxNjg0XSxcblx0Wy0wLjgyOTQ4ODk2OTU2MTU3NDcsICAgMS43NjI2NjQwNjAzMTgzNDYzLCAgMC4wMjM2MjQ2ODU4NDE5NDM1NzddLFxuXHRbIDAuMDM1ODQ1ODMwMjQzNzg0NDcsIC0wLjA3NjE3MjM4OTI2ODA0MTgyLCAwLjk1Njg4NDUyNDAwNzY4NzJdXG5dO1xuXG52YXIgUDNMaW5lYXIgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcInAzLWxpbmVhclwiLFxuXHRuYW1lOiBcIkxpbmVhciBQM1wiLFxuXHR3aGl0ZTogXCJENjVcIixcblx0dG9YWVpfTTogdG9YWVpfTSQ0LFxuXHRmcm9tWFlaX006IGZyb21YWVpfTSQ0XG59KTtcblxuLy8gVGhpcyBpcyB0aGUgbGluZWFyLWxpZ2h0IHZlcnNpb24gb2Ygc1JHQlxuLy8gYXMgdXNlZCBmb3IgZXhhbXBsZSBpbiBTVkcgZmlsdGVyc1xuLy8gb3IgaW4gQ2FudmFzXG5cbi8vIFRoaXMgbWF0cml4IHdhcyBjYWxjdWxhdGVkIGRpcmVjdGx5IGZyb20gdGhlIFJHQiBhbmQgd2hpdGUgY2hyb21hdGljaXRpZXNcbi8vIHdoZW4gcm91bmRlZCB0byA4IGRlY2ltYWwgcGxhY2VzLCBpdCBhZ3JlZXMgY29tcGxldGVseSB3aXRoIHRoZSBvZmZpY2lhbCBtYXRyaXhcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdzNjL2Nzc3dnLWRyYWZ0cy9pc3N1ZXMvNTkyMlxuY29uc3QgdG9YWVpfTSQzID0gW1xuXHRbIDAuNDEyMzkwNzk5MjY1OTU5MzQsIDAuMzU3NTg0MzM5MzgzODc4LCAgIDAuMTgwNDgwNzg4NDAxODM0MyAgXSxcblx0WyAwLjIxMjYzOTAwNTg3MTUxMDI3LCAwLjcxNTE2ODY3ODc2Nzc1NiwgICAwLjA3MjE5MjMxNTM2MDczMzcxIF0sXG5cdFsgMC4wMTkzMzA4MTg3MTU1OTE4MiwgMC4xMTkxOTQ3Nzk3OTQ2MjU5OCwgMC45NTA1MzIxNTIyNDk2NjA3ICBdXG5dO1xuXG4vLyBUaGlzIG1hdHJpeCBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgYWJvdmU7XG4vLyBhZ2FpbiBpdCBhZ3JlZXMgd2l0aCB0aGUgb2ZmaWNpYWwgZGVmaW5pdGlvbiB3aGVuIHJvdW5kZWQgdG8gOCBkZWNpbWFsIHBsYWNlc1xuY29uc3QgZnJvbVhZWl9NJDMgPSBbXG5cdFsgIDMuMjQwOTY5OTQxOTA0NTIyNiwgIC0xLjUzNzM4MzE3NzU3MDA5NCwgICAtMC40OTg2MTA3NjAyOTMwMDM0ICBdLFxuXHRbIC0wLjk2OTI0MzYzNjI4MDg3OTYsICAgMS44NzU5Njc1MDE1MDc3MjAyLCAgIDAuMDQxNTU1MDU3NDA3MTc1NTkgXSxcblx0WyAgMC4wNTU2MzAwNzk2OTY5OTM2NiwgLTAuMjAzOTc2OTU4ODg4OTc2NTIsICAxLjA1Njk3MTUxNDI0Mjg3ODYgIF1cbl07XG5cbnZhciBzUkdCTGluZWFyID0gbmV3IFJHQkNvbG9yU3BhY2Uoe1xuXHRpZDogXCJzcmdiLWxpbmVhclwiLFxuXHRuYW1lOiBcIkxpbmVhciBzUkdCXCIsXG5cdHdoaXRlOiBcIkQ2NVwiLFxuXHR0b1hZWl9NOiB0b1hZWl9NJDMsXG5cdGZyb21YWVpfTTogZnJvbVhZWl9NJDMsXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge31cblx0fSxcbn0pO1xuXG4vKiBMaXN0IG9mIENTUyBjb2xvciBrZXl3b3Jkc1xuICogTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgaW5jbHVkZSBjdXJyZW50Q29sb3IsIHRyYW5zcGFyZW50LFxuICogb3Igc3lzdGVtIGNvbG9yc1xuICovXG5cbi8vIFRvIHByb2R1Y2U6IFZpc2l0IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItNC8jbmFtZWQtY29sb3JzXG4vLyBhbmQgcnVuIGluIHRoZSBjb25zb2xlOlxuLy8gY29weSgkJChcInRyXCIsICQoXCIubmFtZWQtY29sb3ItdGFibGUgdGJvZHlcIikpLm1hcCh0ciA9PiBgXCIke3RyLmNlbGxzWzJdLnRleHRDb250ZW50LnRyaW0oKX1cIjogWyR7dHIuY2VsbHNbNF0udGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGMgPT4gYyA9PT0gXCIwXCI/IFwiMFwiIDogYyA9PT0gXCIyNTVcIj8gXCIxXCIgOiBjICsgXCIgLyAyNTVcIikuam9pbihcIiwgXCIpfV1gKS5qb2luKFwiLFxcblwiKSlcbnZhciBLRVlXT1JEUyA9IHtcblx0XCJhbGljZWJsdWVcIjogWzI0MCAvIDI1NSwgMjQ4IC8gMjU1LCAxXSxcblx0XCJhbnRpcXVld2hpdGVcIjogWzI1MCAvIDI1NSwgMjM1IC8gMjU1LCAyMTUgLyAyNTVdLFxuXHRcImFxdWFcIjogWzAsIDEsIDFdLFxuXHRcImFxdWFtYXJpbmVcIjogWzEyNyAvIDI1NSwgMSwgMjEyIC8gMjU1XSxcblx0XCJhenVyZVwiOiBbMjQwIC8gMjU1LCAxLCAxXSxcblx0XCJiZWlnZVwiOiBbMjQ1IC8gMjU1LCAyNDUgLyAyNTUsIDIyMCAvIDI1NV0sXG5cdFwiYmlzcXVlXCI6IFsxLCAyMjggLyAyNTUsIDE5NiAvIDI1NV0sXG5cdFwiYmxhY2tcIjogWzAsIDAsIDBdLFxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsxLCAyMzUgLyAyNTUsIDIwNSAvIDI1NV0sXG5cdFwiYmx1ZVwiOiBbMCwgMCwgMV0sXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4IC8gMjU1LCA0MyAvIDI1NSwgMjI2IC8gMjU1XSxcblx0XCJicm93blwiOiBbMTY1IC8gMjU1LCA0MiAvIDI1NSwgNDIgLyAyNTVdLFxuXHRcImJ1cmx5d29vZFwiOiBbMjIyIC8gMjU1LCAxODQgLyAyNTUsIDEzNSAvIDI1NV0sXG5cdFwiY2FkZXRibHVlXCI6IFs5NSAvIDI1NSwgMTU4IC8gMjU1LCAxNjAgLyAyNTVdLFxuXHRcImNoYXJ0cmV1c2VcIjogWzEyNyAvIDI1NSwgMSwgMF0sXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAgLyAyNTUsIDEwNSAvIDI1NSwgMzAgLyAyNTVdLFxuXHRcImNvcmFsXCI6IFsxLCAxMjcgLyAyNTUsIDgwIC8gMjU1XSxcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwIC8gMjU1LCAxNDkgLyAyNTUsIDIzNyAvIDI1NV0sXG5cdFwiY29ybnNpbGtcIjogWzEsIDI0OCAvIDI1NSwgMjIwIC8gMjU1XSxcblx0XCJjcmltc29uXCI6IFsyMjAgLyAyNTUsIDIwIC8gMjU1LCA2MCAvIDI1NV0sXG5cdFwiY3lhblwiOiBbMCwgMSwgMV0sXG5cdFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOSAvIDI1NV0sXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSAvIDI1NSwgMTM5IC8gMjU1XSxcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQgLyAyNTUsIDEzNCAvIDI1NSwgMTEgLyAyNTVdLFxuXHRcImRhcmtncmF5XCI6IFsxNjkgLyAyNTUsIDE2OSAvIDI1NSwgMTY5IC8gMjU1XSxcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCAvIDI1NSwgMF0sXG5cdFwiZGFya2dyZXlcIjogWzE2OSAvIDI1NSwgMTY5IC8gMjU1LCAxNjkgLyAyNTVdLFxuXHRcImRhcmtraGFraVwiOiBbMTg5IC8gMjU1LCAxODMgLyAyNTUsIDEwNyAvIDI1NV0sXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSAvIDI1NSwgMCwgMTM5IC8gMjU1XSxcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUgLyAyNTUsIDEwNyAvIDI1NSwgNDcgLyAyNTVdLFxuXHRcImRhcmtvcmFuZ2VcIjogWzEsIDE0MCAvIDI1NSwgMF0sXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzIC8gMjU1LCA1MCAvIDI1NSwgMjA0IC8gMjU1XSxcblx0XCJkYXJrcmVkXCI6IFsxMzkgLyAyNTUsIDAsIDBdLFxuXHRcImRhcmtzYWxtb25cIjogWzIzMyAvIDI1NSwgMTUwIC8gMjU1LCAxMjIgLyAyNTVdLFxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzIC8gMjU1LCAxODggLyAyNTUsIDE0MyAvIDI1NV0sXG5cdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIgLyAyNTUsIDYxIC8gMjU1LCAxMzkgLyAyNTVdLFxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3IC8gMjU1LCA3OSAvIDI1NSwgNzkgLyAyNTVdLFxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3IC8gMjU1LCA3OSAvIDI1NSwgNzkgLyAyNTVdLFxuXHRcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiAvIDI1NSwgMjA5IC8gMjU1XSxcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDggLyAyNTUsIDAsIDIxMSAvIDI1NV0sXG5cdFwiZGVlcHBpbmtcIjogWzEsIDIwIC8gMjU1LCAxNDcgLyAyNTVdLFxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEgLyAyNTUsIDFdLFxuXHRcImRpbWdyYXlcIjogWzEwNSAvIDI1NSwgMTA1IC8gMjU1LCAxMDUgLyAyNTVdLFxuXHRcImRpbWdyZXlcIjogWzEwNSAvIDI1NSwgMTA1IC8gMjU1LCAxMDUgLyAyNTVdLFxuXHRcImRvZGdlcmJsdWVcIjogWzMwIC8gMjU1LCAxNDQgLyAyNTUsIDFdLFxuXHRcImZpcmVicmlja1wiOiBbMTc4IC8gMjU1LCAzNCAvIDI1NSwgMzQgLyAyNTVdLFxuXHRcImZsb3JhbHdoaXRlXCI6IFsxLCAyNTAgLyAyNTUsIDI0MCAvIDI1NV0sXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0IC8gMjU1LCAxMzkgLyAyNTUsIDM0IC8gMjU1XSxcblx0XCJmdWNoc2lhXCI6IFsxLCAwLCAxXSxcblx0XCJnYWluc2Jvcm9cIjogWzIyMCAvIDI1NSwgMjIwIC8gMjU1LCAyMjAgLyAyNTVdLFxuXHRcImdob3N0d2hpdGVcIjogWzI0OCAvIDI1NSwgMjQ4IC8gMjU1LCAxXSxcblx0XCJnb2xkXCI6IFsxLCAyMTUgLyAyNTUsIDBdLFxuXHRcImdvbGRlbnJvZFwiOiBbMjE4IC8gMjU1LCAxNjUgLyAyNTUsIDMyIC8gMjU1XSxcblx0XCJncmF5XCI6IFsxMjggLyAyNTUsIDEyOCAvIDI1NSwgMTI4IC8gMjU1XSxcblx0XCJncmVlblwiOiBbMCwgMTI4IC8gMjU1LCAwXSxcblx0XCJncmVlbnllbGxvd1wiOiBbMTczIC8gMjU1LCAxLCA0NyAvIDI1NV0sXG5cdFwiZ3JleVwiOiBbMTI4IC8gMjU1LCAxMjggLyAyNTUsIDEyOCAvIDI1NV0sXG5cdFwiaG9uZXlkZXdcIjogWzI0MCAvIDI1NSwgMSwgMjQwIC8gMjU1XSxcblx0XCJob3RwaW5rXCI6IFsxLCAxMDUgLyAyNTUsIDE4MCAvIDI1NV0sXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUgLyAyNTUsIDkyIC8gMjU1LCA5MiAvIDI1NV0sXG5cdFwiaW5kaWdvXCI6IFs3NSAvIDI1NSwgMCwgMTMwIC8gMjU1XSxcblx0XCJpdm9yeVwiOiBbMSwgMSwgMjQwIC8gMjU1XSxcblx0XCJraGFraVwiOiBbMjQwIC8gMjU1LCAyMzAgLyAyNTUsIDE0MCAvIDI1NV0sXG5cdFwibGF2ZW5kZXJcIjogWzIzMCAvIDI1NSwgMjMwIC8gMjU1LCAyNTAgLyAyNTVdLFxuXHRcImxhdmVuZGVyYmx1c2hcIjogWzEsIDI0MCAvIDI1NSwgMjQ1IC8gMjU1XSxcblx0XCJsYXduZ3JlZW5cIjogWzEyNCAvIDI1NSwgMjUyIC8gMjU1LCAwXSxcblx0XCJsZW1vbmNoaWZmb25cIjogWzEsIDI1MCAvIDI1NSwgMjA1IC8gMjU1XSxcblx0XCJsaWdodGJsdWVcIjogWzE3MyAvIDI1NSwgMjE2IC8gMjU1LCAyMzAgLyAyNTVdLFxuXHRcImxpZ2h0Y29yYWxcIjogWzI0MCAvIDI1NSwgMTI4IC8gMjU1LCAxMjggLyAyNTVdLFxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0IC8gMjU1LCAxLCAxXSxcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwIC8gMjU1LCAyNTAgLyAyNTUsIDIxMCAvIDI1NV0sXG5cdFwibGlnaHRncmF5XCI6IFsyMTEgLyAyNTUsIDIxMSAvIDI1NSwgMjExIC8gMjU1XSxcblx0XCJsaWdodGdyZWVuXCI6IFsxNDQgLyAyNTUsIDIzOCAvIDI1NSwgMTQ0IC8gMjU1XSxcblx0XCJsaWdodGdyZXlcIjogWzIxMSAvIDI1NSwgMjExIC8gMjU1LCAyMTEgLyAyNTVdLFxuXHRcImxpZ2h0cGlua1wiOiBbMSwgMTgyIC8gMjU1LCAxOTMgLyAyNTVdLFxuXHRcImxpZ2h0c2FsbW9uXCI6IFsxLCAxNjAgLyAyNTUsIDEyMiAvIDI1NV0sXG5cdFwibGlnaHRzZWFncmVlblwiOiBbMzIgLyAyNTUsIDE3OCAvIDI1NSwgMTcwIC8gMjU1XSxcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSAvIDI1NSwgMjA2IC8gMjU1LCAyNTAgLyAyNTVdLFxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTkgLyAyNTUsIDEzNiAvIDI1NSwgMTUzIC8gMjU1XSxcblx0XCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5IC8gMjU1LCAxMzYgLyAyNTUsIDE1MyAvIDI1NV0sXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiAvIDI1NSwgMTk2IC8gMjU1LCAyMjIgLyAyNTVdLFxuXHRcImxpZ2h0eWVsbG93XCI6IFsxLCAxLCAyMjQgLyAyNTVdLFxuXHRcImxpbWVcIjogWzAsIDEsIDBdLFxuXHRcImxpbWVncmVlblwiOiBbNTAgLyAyNTUsIDIwNSAvIDI1NSwgNTAgLyAyNTVdLFxuXHRcImxpbmVuXCI6IFsyNTAgLyAyNTUsIDI0MCAvIDI1NSwgMjMwIC8gMjU1XSxcblx0XCJtYWdlbnRhXCI6IFsxLCAwLCAxXSxcblx0XCJtYXJvb25cIjogWzEyOCAvIDI1NSwgMCwgMF0sXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyIC8gMjU1LCAyMDUgLyAyNTUsIDE3MCAvIDI1NV0sXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1IC8gMjU1XSxcblx0XCJtZWRpdW1vcmNoaWRcIjogWzE4NiAvIDI1NSwgODUgLyAyNTUsIDIxMSAvIDI1NV0sXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcgLyAyNTUsIDExMiAvIDI1NSwgMjE5IC8gMjU1XSxcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAgLyAyNTUsIDE3OSAvIDI1NSwgMTEzIC8gMjU1XSxcblx0XCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMyAvIDI1NSwgMTA0IC8gMjU1LCAyMzggLyAyNTVdLFxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAgLyAyNTUsIDE1NCAvIDI1NV0sXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiAvIDI1NSwgMjA5IC8gMjU1LCAyMDQgLyAyNTVdLFxuXHRcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5IC8gMjU1LCAyMSAvIDI1NSwgMTMzIC8gMjU1XSxcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1IC8gMjU1LCAyNSAvIDI1NSwgMTEyIC8gMjU1XSxcblx0XCJtaW50Y3JlYW1cIjogWzI0NSAvIDI1NSwgMSwgMjUwIC8gMjU1XSxcblx0XCJtaXN0eXJvc2VcIjogWzEsIDIyOCAvIDI1NSwgMjI1IC8gMjU1XSxcblx0XCJtb2NjYXNpblwiOiBbMSwgMjI4IC8gMjU1LCAxODEgLyAyNTVdLFxuXHRcIm5hdmFqb3doaXRlXCI6IFsxLCAyMjIgLyAyNTUsIDE3MyAvIDI1NV0sXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4IC8gMjU1XSxcblx0XCJvbGRsYWNlXCI6IFsyNTMgLyAyNTUsIDI0NSAvIDI1NSwgMjMwIC8gMjU1XSxcblx0XCJvbGl2ZVwiOiBbMTI4IC8gMjU1LCAxMjggLyAyNTUsIDBdLFxuXHRcIm9saXZlZHJhYlwiOiBbMTA3IC8gMjU1LCAxNDIgLyAyNTUsIDM1IC8gMjU1XSxcblx0XCJvcmFuZ2VcIjogWzEsIDE2NSAvIDI1NSwgMF0sXG5cdFwib3JhbmdlcmVkXCI6IFsxLCA2OSAvIDI1NSwgMF0sXG5cdFwib3JjaGlkXCI6IFsyMTggLyAyNTUsIDExMiAvIDI1NSwgMjE0IC8gMjU1XSxcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzggLyAyNTUsIDIzMiAvIDI1NSwgMTcwIC8gMjU1XSxcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiAvIDI1NSwgMjUxIC8gMjU1LCAxNTIgLyAyNTVdLFxuXHRcInBhbGV0dXJxdW9pc2VcIjogWzE3NSAvIDI1NSwgMjM4IC8gMjU1LCAyMzggLyAyNTVdLFxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSAvIDI1NSwgMTEyIC8gMjU1LCAxNDcgLyAyNTVdLFxuXHRcInBhcGF5YXdoaXBcIjogWzEsIDIzOSAvIDI1NSwgMjEzIC8gMjU1XSxcblx0XCJwZWFjaHB1ZmZcIjogWzEsIDIxOCAvIDI1NSwgMTg1IC8gMjU1XSxcblx0XCJwZXJ1XCI6IFsyMDUgLyAyNTUsIDEzMyAvIDI1NSwgNjMgLyAyNTVdLFxuXHRcInBpbmtcIjogWzEsIDE5MiAvIDI1NSwgMjAzIC8gMjU1XSxcblx0XCJwbHVtXCI6IFsyMjEgLyAyNTUsIDE2MCAvIDI1NSwgMjIxIC8gMjU1XSxcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYgLyAyNTUsIDIyNCAvIDI1NSwgMjMwIC8gMjU1XSxcblx0XCJwdXJwbGVcIjogWzEyOCAvIDI1NSwgMCwgMTI4IC8gMjU1XSxcblx0XCJyZWJlY2NhcHVycGxlXCI6IFsxMDIgLyAyNTUsIDUxIC8gMjU1LCAxNTMgLyAyNTVdLFxuXHRcInJlZFwiOiBbMSwgMCwgMF0sXG5cdFwicm9zeWJyb3duXCI6IFsxODggLyAyNTUsIDE0MyAvIDI1NSwgMTQzIC8gMjU1XSxcblx0XCJyb3lhbGJsdWVcIjogWzY1IC8gMjU1LCAxMDUgLyAyNTUsIDIyNSAvIDI1NV0sXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSAvIDI1NSwgNjkgLyAyNTUsIDE5IC8gMjU1XSxcblx0XCJzYWxtb25cIjogWzI1MCAvIDI1NSwgMTI4IC8gMjU1LCAxMTQgLyAyNTVdLFxuXHRcInNhbmR5YnJvd25cIjogWzI0NCAvIDI1NSwgMTY0IC8gMjU1LCA5NiAvIDI1NV0sXG5cdFwic2VhZ3JlZW5cIjogWzQ2IC8gMjU1LCAxMzkgLyAyNTUsIDg3IC8gMjU1XSxcblx0XCJzZWFzaGVsbFwiOiBbMSwgMjQ1IC8gMjU1LCAyMzggLyAyNTVdLFxuXHRcInNpZW5uYVwiOiBbMTYwIC8gMjU1LCA4MiAvIDI1NSwgNDUgLyAyNTVdLFxuXHRcInNpbHZlclwiOiBbMTkyIC8gMjU1LCAxOTIgLyAyNTUsIDE5MiAvIDI1NV0sXG5cdFwic2t5Ymx1ZVwiOiBbMTM1IC8gMjU1LCAyMDYgLyAyNTUsIDIzNSAvIDI1NV0sXG5cdFwic2xhdGVibHVlXCI6IFsxMDYgLyAyNTUsIDkwIC8gMjU1LCAyMDUgLyAyNTVdLFxuXHRcInNsYXRlZ3JheVwiOiBbMTEyIC8gMjU1LCAxMjggLyAyNTUsIDE0NCAvIDI1NV0sXG5cdFwic2xhdGVncmV5XCI6IFsxMTIgLyAyNTUsIDEyOCAvIDI1NSwgMTQ0IC8gMjU1XSxcblx0XCJzbm93XCI6IFsxLCAyNTAgLyAyNTUsIDI1MCAvIDI1NV0sXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDEsIDEyNyAvIDI1NV0sXG5cdFwic3RlZWxibHVlXCI6IFs3MCAvIDI1NSwgMTMwIC8gMjU1LCAxODAgLyAyNTVdLFxuXHRcInRhblwiOiBbMjEwIC8gMjU1LCAxODAgLyAyNTUsIDE0MCAvIDI1NV0sXG5cdFwidGVhbFwiOiBbMCwgMTI4IC8gMjU1LCAxMjggLyAyNTVdLFxuXHRcInRoaXN0bGVcIjogWzIxNiAvIDI1NSwgMTkxIC8gMjU1LCAyMTYgLyAyNTVdLFxuXHRcInRvbWF0b1wiOiBbMSwgOTkgLyAyNTUsIDcxIC8gMjU1XSxcblx0XCJ0dXJxdW9pc2VcIjogWzY0IC8gMjU1LCAyMjQgLyAyNTUsIDIwOCAvIDI1NV0sXG5cdFwidmlvbGV0XCI6IFsyMzggLyAyNTUsIDEzMCAvIDI1NSwgMjM4IC8gMjU1XSxcblx0XCJ3aGVhdFwiOiBbMjQ1IC8gMjU1LCAyMjIgLyAyNTUsIDE3OSAvIDI1NV0sXG5cdFwid2hpdGVcIjogWzEsIDEsIDFdLFxuXHRcIndoaXRlc21va2VcIjogWzI0NSAvIDI1NSwgMjQ1IC8gMjU1LCAyNDUgLyAyNTVdLFxuXHRcInllbGxvd1wiOiBbMSwgMSwgMF0sXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCAvIDI1NSwgMjA1IC8gMjU1LCA1MCAvIDI1NV1cbn07XG5cbmxldCBjb29yZEdyYW1tYXIgPSBBcnJheSgzKS5maWxsKFwiPHBlcmNlbnRhZ2U+IHwgPG51bWJlcj5bMCwgMjU1XVwiKTtcbmxldCBjb29yZEdyYW1tYXJOdW1iZXIgPSBBcnJheSgzKS5maWxsKFwiPG51bWJlcj5bMCwgMjU1XVwiKTtcblxudmFyIHNSR0IgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcInNyZ2JcIixcblx0bmFtZTogXCJzUkdCXCIsXG5cdGJhc2U6IHNSR0JMaW5lYXIsXG5cdGZyb21CYXNlOiByZ2IgPT4ge1xuXHRcdC8vIGNvbnZlcnQgYW4gYXJyYXkgb2YgbGluZWFyLWxpZ2h0IHNSR0IgdmFsdWVzIGluIHRoZSByYW5nZSAwLjAtMS4wXG5cdFx0Ly8gdG8gZ2FtbWEgY29ycmVjdGVkIGZvcm1cblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUkdCXG5cdFx0cmV0dXJuIHJnYi5tYXAodmFsID0+IHtcblx0XHRcdGxldCBzaWduID0gdmFsIDwgMD8gLTEgOiAxO1xuXHRcdFx0bGV0IGFicyA9IHZhbCAqIHNpZ247XG5cblx0XHRcdGlmIChhYnMgPiAwLjAwMzEzMDgpIHtcblx0XHRcdFx0cmV0dXJuIHNpZ24gKiAoMS4wNTUgKiAoYWJzICoqICgxLzIuNCkpIC0gMC4wNTUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMTIuOTIgKiB2YWw7XG5cdFx0fSk7XG5cdH0sXG5cdHRvQmFzZTogcmdiID0+IHtcblx0XHQvLyBjb252ZXJ0IGFuIGFycmF5IG9mIHNSR0IgdmFsdWVzIGluIHRoZSByYW5nZSAwLjAgLSAxLjBcblx0XHQvLyB0byBsaW5lYXIgbGlnaHQgKHVuLWNvbXBhbmRlZCkgZm9ybS5cblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUkdCXG5cdFx0cmV0dXJuIHJnYi5tYXAodmFsID0+IHtcblx0XHRcdGxldCBzaWduID0gdmFsIDwgMD8gLTEgOiAxO1xuXHRcdFx0bGV0IGFicyA9IHZhbCAqIHNpZ247XG5cblx0XHRcdGlmIChhYnMgPCAwLjA0MDQ1KSB7XG5cdFx0XHRcdHJldHVybiB2YWwgLyAxMi45Mjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNpZ24gKiAoKChhYnMgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40KTtcblx0XHR9KTtcblx0fSxcblx0Zm9ybWF0czoge1xuXHRcdFwicmdiXCI6IHtcblx0XHRcdGNvb3JkczogY29vcmRHcmFtbWFyLFxuXHRcdH0sXG5cdFx0XCJyZ2JfbnVtYmVyXCI6IHtcblx0XHRcdG5hbWU6IFwicmdiXCIsXG5cdFx0XHRjb21tYXM6IHRydWUsXG5cdFx0XHRjb29yZHM6IGNvb3JkR3JhbW1hck51bWJlcixcblx0XHRcdG5vQWxwaGE6IHRydWUsXG5cdFx0fSxcblx0XHRcImNvbG9yXCI6IHsgLyogdXNlIGRlZmF1bHRzICovIH0sXG5cdFx0XCJyZ2JhXCI6IHtcblx0XHRcdGNvb3JkczogY29vcmRHcmFtbWFyLFxuXHRcdFx0Y29tbWFzOiB0cnVlLFxuXHRcdFx0bGFzdEFscGhhOiB0cnVlLFxuXHRcdH0sXG5cdFx0XCJyZ2JhX251bWJlclwiOiB7XG5cdFx0XHRuYW1lOiBcInJnYmFcIixcblx0XHRcdGNvbW1hczogdHJ1ZSxcblx0XHRcdGNvb3JkczogY29vcmRHcmFtbWFyTnVtYmVyXG5cdFx0fSxcblx0XHRcImhleFwiOiB7XG5cdFx0XHR0eXBlOiBcImN1c3RvbVwiLFxuXHRcdFx0dG9HYW11dDogdHJ1ZSxcblx0XHRcdHRlc3Q6IHN0ciA9PiAvXiMoW2EtZjAtOV17Myw0fSl7MSwyfSQvaS50ZXN0KHN0ciksXG5cdFx0XHRwYXJzZSAoc3RyKSB7XG5cdFx0XHRcdGlmIChzdHIubGVuZ3RoIDw9IDUpIHtcblx0XHRcdFx0XHQvLyAjcmdiIG9yICNyZ2JhLCBkdXBsaWNhdGUgZGlnaXRzXG5cdFx0XHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoL1thLWYwLTldL2dpLCBcIiQmJCZcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgcmdiYSA9IFtdO1xuXHRcdFx0XHRzdHIucmVwbGFjZSgvW2EtZjAtOV17Mn0vZ2ksIGNvbXBvbmVudCA9PiB7XG5cdFx0XHRcdFx0cmdiYS5wdXNoKHBhcnNlSW50KGNvbXBvbmVudCwgMTYpIC8gMjU1KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzcGFjZUlkOiBcInNyZ2JcIixcblx0XHRcdFx0XHRjb29yZHM6IHJnYmEuc2xpY2UoMCwgMyksXG5cdFx0XHRcdFx0YWxwaGE6IHJnYmEuc2xpY2UoMylbMF1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRzZXJpYWxpemU6IChjb29yZHMsIGFscGhhLCB7XG5cdFx0XHRcdGNvbGxhcHNlID0gdHJ1ZSAvLyBjb2xsYXBzZSB0byAzLTQgZGlnaXQgaGV4IHdoZW4gcG9zc2libGU/XG5cdFx0XHR9ID0ge30pID0+IHtcblx0XHRcdFx0aWYgKGFscGhhIDwgMSkge1xuXHRcdFx0XHRcdGNvb3Jkcy5wdXNoKGFscGhhKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvb3JkcyA9IGNvb3Jkcy5tYXAoYyA9PiBNYXRoLnJvdW5kKGMgKiAyNTUpKTtcblxuXHRcdFx0XHRsZXQgY29sbGFwc2libGUgPSBjb2xsYXBzZSAmJiBjb29yZHMuZXZlcnkoYyA9PiBjICUgMTcgPT09IDApO1xuXG5cdFx0XHRcdGxldCBoZXggPSBjb29yZHMubWFwKGMgPT4ge1xuXHRcdFx0XHRcdGlmIChjb2xsYXBzaWJsZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChjLzE3KS50b1N0cmluZygxNik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGMudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcblx0XHRcdFx0fSkuam9pbihcIlwiKTtcblxuXHRcdFx0XHRyZXR1cm4gXCIjXCIgKyBoZXg7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImtleXdvcmRcIjoge1xuXHRcdFx0dHlwZTogXCJjdXN0b21cIixcblx0XHRcdHRlc3Q6IHN0ciA9PiAvXlthLXpdKyQvaS50ZXN0KHN0ciksXG5cdFx0XHRwYXJzZSAoc3RyKSB7XG5cdFx0XHRcdHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRsZXQgcmV0ID0ge3NwYWNlSWQ6IFwic3JnYlwiLCBjb29yZHM6IG51bGwsIGFscGhhOiAxfTtcblxuXHRcdFx0XHRpZiAoc3RyID09PSBcInRyYW5zcGFyZW50XCIpIHtcblx0XHRcdFx0XHRyZXQuY29vcmRzID0gS0VZV09SRFMuYmxhY2s7XG5cdFx0XHRcdFx0cmV0LmFscGhhID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXQuY29vcmRzID0gS0VZV09SRFNbc3RyXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXQuY29vcmRzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH1cbn0pO1xuXG52YXIgUDMgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcInAzXCIsXG5cdG5hbWU6IFwiUDNcIixcblx0YmFzZTogUDNMaW5lYXIsXG5cdC8vIEdhbW1hIGVuY29kaW5nL2RlY29kaW5nIGlzIHRoZSBzYW1lIGFzIHNSR0Jcblx0ZnJvbUJhc2U6IHNSR0IuZnJvbUJhc2UsXG5cdHRvQmFzZTogc1JHQi50b0Jhc2UsXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge1xuXHRcdFx0aWQ6IFwiZGlzcGxheS1wM1wiLFxuXHRcdH1cblx0fSxcbn0pO1xuXG4vLyBEZWZhdWx0IHNwYWNlIGZvciBDU1Mgb3V0cHV0LiBDb2RlIGluIENvbG9yLmpzIG1ha2VzIHRoaXMgd2lkZXIgaWYgdGhlcmUncyBhIERPTSBhdmFpbGFibGVcbmRlZmF1bHRzLmRpc3BsYXlfc3BhY2UgPSBzUkdCO1xuXG5pZiAodHlwZW9mIENTUyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDU1Muc3VwcG9ydHMpIHtcblx0Ly8gRmluZCB3aWRlc3Qgc3VwcG9ydGVkIGNvbG9yIHNwYWNlIGZvciBDU1Ncblx0Zm9yIChsZXQgc3BhY2Ugb2YgW2xhYiwgUkVDMjAyMCwgUDNdKSB7XG5cdFx0bGV0IGNvb3JkcyA9IHNwYWNlLmdldE1pbkNvb3JkcygpO1xuXHRcdGxldCBjb2xvciA9IHtzcGFjZSwgY29vcmRzLCBhbHBoYTogMX07XG5cdFx0bGV0IHN0ciA9IHNlcmlhbGl6ZShjb2xvcik7XG5cblx0XHRpZiAoQ1NTLnN1cHBvcnRzKFwiY29sb3JcIiwgc3RyKSkge1xuXHRcdFx0ZGVmYXVsdHMuZGlzcGxheV9zcGFjZSA9IHNwYWNlO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHNlcmlhbGl6YXRpb24gb2YgdGhlIGNvbG9yIHRoYXQgY2FuIGFjdHVhbGx5IGJlIGRpc3BsYXllZCBpbiB0aGUgYnJvd3Nlci5cbiAqIElmIHRoZSBkZWZhdWx0IHNlcmlhbGl6YXRpb24gY2FuIGJlIGRpc3BsYXllZCwgaXQgaXMgcmV0dXJuZWQuXG4gKiBPdGhlcndpc2UsIHRoZSBjb2xvciBpcyBjb252ZXJ0ZWQgdG8gTGFiLCBSRUMyMDIwLCBvciBQMywgd2hpY2hldmVyIGlzIHRoZSB3aWRlc3Qgc3VwcG9ydGVkLlxuICogSW4gTm9kZS5qcywgdGhpcyBpcyBiYXNpY2FsbHkgZXF1aXZhbGVudCB0byBgc2VyaWFsaXplKClgIGJ1dCByZXR1cm5zIGEgYFN0cmluZ2Agb2JqZWN0IGluc3RlYWQuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHt7c3BhY2UsIGNvb3Jkc30gfCBDb2xvciB8IHN0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7Kn0gW29wdGlvbnM9e31dIE9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHNlcmlhbGl6ZSgpXG4gKiBAcGFyYW0ge0NvbG9yU3BhY2UgfCBzdHJpbmd9IFtvcHRpb25zLnNwYWNlID0gZGVmYXVsdHMuZGlzcGxheV9zcGFjZV0gQ29sb3Igc3BhY2UgdG8gdXNlIGZvciBzZXJpYWxpemF0aW9uIGlmIGRlZmF1bHQgaXMgbm90IHN1cHBvcnRlZFxuICogQHJldHVybnMge1N0cmluZ30gU3RyaW5nIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIGNvbG9yIHdpdGggYSBjb2xvciBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSBjb252ZXJ0ZWQgY29sb3IgKG9yIHRoZSBvcmlnaW5hbCwgaWYgbm8gY29udmVyc2lvbiB3YXMgbmVjZXNzYXJ5KVxuICovXG5mdW5jdGlvbiBkaXNwbGF5IChjb2xvciwge3NwYWNlID0gZGVmYXVsdHMuZGlzcGxheV9zcGFjZSwgLi4ub3B0aW9uc30gPSB7fSkge1xuXHRsZXQgcmV0ID0gc2VyaWFsaXplKGNvbG9yLCBvcHRpb25zKTtcblxuXHRpZiAodHlwZW9mIENTUyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBDU1Muc3VwcG9ydHMoXCJjb2xvclwiLCByZXQpIHx8ICFkZWZhdWx0cy5kaXNwbGF5X3NwYWNlKSB7XG5cdFx0cmV0ID0gbmV3IFN0cmluZyhyZXQpO1xuXHRcdHJldC5jb2xvciA9IGNvbG9yO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIElmIHdlJ3JlIGhlcmUsIHdoYXQgd2Ugd2VyZSBhYm91dCB0byBvdXRwdXQgaXMgbm90IHN1cHBvcnRlZFxuXHRcdC8vIEZhbGwgYmFjayB0byBmYWxsYmFjayBzcGFjZVxuXHRcdGxldCBmYWxsYmFja0NvbG9yID0gdG8oY29sb3IsIHNwYWNlKTtcblx0XHRyZXQgPSBuZXcgU3RyaW5nKHNlcmlhbGl6ZShmYWxsYmFja0NvbG9yLCBvcHRpb25zKSk7XG5cdFx0cmV0LmNvbG9yID0gZmFsbGJhY2tDb2xvcjtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRXVjbGlkZWFuIGRpc3RhbmNlIG9mIGNvbG9ycyBpbiBhbiBhcmJpdHJhcnkgY29sb3Igc3BhY2VcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UgKGNvbG9yMSwgY29sb3IyLCBzcGFjZSA9IFwibGFiXCIpIHtcblx0c3BhY2UgPSBDb2xvclNwYWNlLmdldChzcGFjZSk7XG5cblx0bGV0IGNvb3JkczEgPSBzcGFjZS5mcm9tKGNvbG9yMSk7XG5cdGxldCBjb29yZHMyID0gc3BhY2UuZnJvbShjb2xvcjIpO1xuXG5cdHJldHVybiBNYXRoLnNxcnQoY29vcmRzMS5yZWR1Y2UoKGFjYywgYzEsIGkpID0+IHtcblx0XHRsZXQgYzIgPSBjb29yZHMyW2ldO1xuXHRcdGlmIChpc05hTihjMSkgfHwgaXNOYU4oYzIpKSB7XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2MgKyAoYzIgLSBjMSkgKiogMjtcblx0fSwgMCkpO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMgKGNvbG9yMSwgY29sb3IyKSB7XG5cdGNvbG9yMSA9IGdldENvbG9yKGNvbG9yMSk7XG5cdGNvbG9yMiA9IGdldENvbG9yKGNvbG9yMik7XG5cblx0cmV0dXJuIGNvbG9yMS5zcGFjZSA9PT0gY29sb3IyLnNwYWNlXG5cdFx0ICAgJiYgY29sb3IxLmFscGhhID09PSBjb2xvcjIuYWxwaGFcblx0XHQgICAmJiBjb2xvcjEuY29vcmRzLmV2ZXJ5KChjLCBpKSA9PiBjID09PSBjb2xvcjIuY29vcmRzW2ldKTtcbn1cblxuLyoqXG4gKiBSZWxhdGl2ZSBsdW1pbmFuY2VcbiAqL1xuXG5mdW5jdGlvbiBnZXRMdW1pbmFuY2UgKGNvbG9yKSB7XG5cdHJldHVybiBnZXQoY29sb3IsIFtYWVpfRDY1LCBcInlcIl0pO1xufVxuXG5mdW5jdGlvbiBzZXRMdW1pbmFuY2UgKGNvbG9yLCB2YWx1ZSkge1xuXHRzZXQoY29sb3IsIFtYWVpfRDY1LCBcInlcIl0sIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXIkMiAoQ29sb3IpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgXCJsdW1pbmFuY2VcIiwge1xuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4gZ2V0THVtaW5hbmNlKHRoaXMpO1xuXHRcdH0sXG5cdFx0c2V0ICh2YWx1ZSkge1xuXHRcdFx0c2V0THVtaW5hbmNlKHRoaXMsIHZhbHVlKTtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgbHVtaW5hbmNlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGdldEx1bWluYW5jZTogZ2V0THVtaW5hbmNlLFxuXHRyZWdpc3RlcjogcmVnaXN0ZXIkMixcblx0c2V0THVtaW5hbmNlOiBzZXRMdW1pbmFuY2Vcbn0pO1xuXG4vLyBXQ0FHIDIuMCBjb250cmFzdCBodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxOC5odG1sXG4vLyBTaW1wbGUgY29udHJhc3QsIHdpdGggZml4ZWQgNSUgdmlld2luZyBmbGFyZSBjb250cmlidXRpb25cbi8vIFN5bW1ldHJpYywgZG9lcyBub3QgbWF0dGVyIHdoaWNoIGlzIGZvcmVncm91bmQgYW5kIHdoaWNoIGlzIGJhY2tncm91bmRcblxuXG5mdW5jdGlvbiBjb250cmFzdFdDQUcyMSAoY29sb3IxLCBjb2xvcjIpIHtcblx0Y29sb3IxID0gZ2V0Q29sb3IoY29sb3IxKTtcblx0Y29sb3IyID0gZ2V0Q29sb3IoY29sb3IyKTtcblxuXHRsZXQgWTEgPSBNYXRoLm1heChnZXRMdW1pbmFuY2UoY29sb3IxKSwgMCk7XG5cdGxldCBZMiA9IE1hdGgubWF4KGdldEx1bWluYW5jZShjb2xvcjIpLCAwKTtcblxuXHRpZiAoWTIgPiBZMSkge1xuXHRcdFtZMSwgWTJdID0gW1kyLCBZMV07XG5cdH1cblxuXHRyZXR1cm4gKFkxICsgLjA1KSAvIChZMiArIC4wNSk7XG59XG5cbi8vIEFQQ0EgMC4wLjk4R1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL015bmRleC9hcGNhLXczXG4vLyBzZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3NpbHZlci9pc3N1ZXMvNjQzXG5cblxuLy8gZXhwb25lbnRzXG5jb25zdCBub3JtQkcgPSAwLjU2O1xuY29uc3Qgbm9ybVRYVCA9IDAuNTc7XG5jb25zdCByZXZUWFQgPSAwLjYyO1xuY29uc3QgcmV2QkcgPSAwLjY1O1xuXG4vLyBjbGFtcHNcbmNvbnN0IGJsa1RocnMgPSAwLjAyMjtcbmNvbnN0IGJsa0NsbXAgPSAxLjQxNDtcbmNvbnN0IGxvQ2xpcCA9IDAuMTtcbmNvbnN0IGRlbHRhWW1pbiA9IDAuMDAwNTtcblxuLy8gc2NhbGVyc1xuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvc2lsdmVyL2lzc3Vlcy82NDVcbmNvbnN0IHNjYWxlQm9XID0gMS4xNDtcbmNvbnN0IGxvQm9Xb2Zmc2V0ID0gMC4wMjc7XG5jb25zdCBzY2FsZVdvQj0gMS4xNDtcblxuZnVuY3Rpb24gZmNsYW1wIChZKSB7XG5cdGlmIChZID49IGJsa1RocnMpIHtcblx0XHRyZXR1cm4gWTtcblx0fVxuXHRyZXR1cm4gWSArIChibGtUaHJzIC0gWSkgKiogYmxrQ2xtcDtcbn1cblxuZnVuY3Rpb24gbGluZWFyaXplICh2YWwpIHtcblx0bGV0IHNpZ24gPSB2YWwgPCAwPyAtMSA6IDE7XG5cdGxldCBhYnMgPSBNYXRoLmFicyh2YWwpO1xuXHRyZXR1cm4gc2lnbiAqIE1hdGgucG93KGFicywgMi40KTtcbn1cblxuLy8gTm90IHN5bW1ldHJpYywgcmVxdWlyZXMgYSBmb3JlZ3JvdW5kICh0ZXh0KSBjb2xvciwgYW5kIGEgYmFja2dyb3VuZCBjb2xvclxuZnVuY3Rpb24gY29udHJhc3RBUENBIChiYWNrZ3JvdW5kLCBmb3JlZ3JvdW5kKSB7XG5cdGZvcmVncm91bmQgPSBnZXRDb2xvcihmb3JlZ3JvdW5kKTtcblx0YmFja2dyb3VuZCA9IGdldENvbG9yKGJhY2tncm91bmQpO1xuXG5cdGxldCBTO1xuXHRsZXQgQztcblx0bGV0IFNhcGM7XG5cblx0Ly8gTXluZGV4IGFzLXB1Ymxpc2hlZCwgYXNzdW1lcyBzUkdCIGlucHV0c1xuXHRsZXQgUiwgRywgQjtcblxuXHRmb3JlZ3JvdW5kID0gdG8oZm9yZWdyb3VuZCwgXCJzcmdiXCIpO1xuXHQvLyBTaG91bGQgdGhlc2UgYmUgY2xhbXBlZCB0byBpbi1nYW11dCB2YWx1ZXM/XG5cblx0Ly8gQ2FsY3VsYXRlcyBcInNjcmVlbiBsdW1pbmFuY2VcIiB3aXRoIG5vbi1zdGFuZGFyZCBzaW1wbGUgZ2FtbWEgRU9URlxuXHQvLyB3ZWlnaHRzIHNob3VsZCBiZSBmcm9tIENTUyBDb2xvciA0LCBub3QgdGhlIG9uZXMgaGVyZSB3aGljaCBhcmUgdmlhIE15bmRleCBhbmQgY29waWVkIGZyb20gTGluZGJsb29tXG5cdFtSLCBHLCBCXSA9IGZvcmVncm91bmQuY29vcmRzO1xuXHRsZXQgbHVtVHh0ID0gbGluZWFyaXplKFIpICogMC4yMTI2NzI5ICsgbGluZWFyaXplKEcpICogMC43MTUxNTIyICsgbGluZWFyaXplKEIpICogMC4wNzIxNzUwO1xuXG5cdGJhY2tncm91bmQgPSB0byhiYWNrZ3JvdW5kLCBcInNyZ2JcIik7XG5cdFtSLCBHLCBCXSA9IGJhY2tncm91bmQuY29vcmRzO1xuXHRsZXQgbHVtQmcgPSBsaW5lYXJpemUoUikgKiAwLjIxMjY3MjkgKyBsaW5lYXJpemUoRykgKiAwLjcxNTE1MjIgKyBsaW5lYXJpemUoQikgKiAwLjA3MjE3NTA7XG5cblx0Ly8gdG9lIGNsYW1waW5nIG9mIHZlcnkgZGFyayB2YWx1ZXMgdG8gYWNjb3VudCBmb3IgZmxhcmVcblx0bGV0IFl0eHQgPSBmY2xhbXAobHVtVHh0KTtcblx0bGV0IFliZyA9IGZjbGFtcChsdW1CZyk7XG5cblx0Ly8gYXJlIHdlIFwiQmxhY2sgb24gV2hpdGVcIiAoZGFyayBvbiBsaWdodCksIG9yIGxpZ2h0IG9uIGRhcms/XG5cdGxldCBCb1cgPSBZYmcgPiBZdHh0O1xuXG5cdC8vIHdoeSBpcyB0aGlzIGEgZGVsdGEsIHdoZW4gWSBpcyBub3QgcGVyY2VwdHVhbGx5IHVuaWZvcm0/XG5cdC8vIEFuc3dlcjogaXQgaXMgYSBub2lzZSBnYXRlLCBzZWVcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYVZlcm91L2NvbG9yLmpzL2lzc3Vlcy8yMDhcblx0aWYgKE1hdGguYWJzKFliZyAtIFl0eHQpIDwgZGVsdGFZbWluKSB7XG5cdFx0QyA9IDA7XG5cdH1cblx0ZWxzZSB7XG5cdFx0aWYgKEJvVykge1xuXHRcdFx0Ly8gZGFyayB0ZXh0IG9uIGxpZ2h0IGJhY2tncm91bmRcblx0XHRcdFMgPSBZYmcgKiogbm9ybUJHIC0gWXR4dCAqKiBub3JtVFhUO1xuXHRcdFx0QyA9IFMgKiBzY2FsZUJvVztcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBsaWdodCB0ZXh0IG9uIGRhcmsgYmFja2dyb3VuZFxuXHRcdFx0UyA9IFliZyAqKiByZXZCRyAtIFl0eHQgKiogcmV2VFhUO1xuXHRcdFx0QyA9IFMgKiBzY2FsZVdvQjtcblx0XHR9XG5cdH1cblx0aWYgKE1hdGguYWJzKEMpIDwgbG9DbGlwKSB7XG5cdFx0U2FwYyA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoQyA+IDApIHtcblx0XHQvLyBub3QgY2xlYXIgd2hldGhlciBXb2Zmc2V0IGlzIGxvQm9Xb2Zmc2V0IG9yIGxvV29Cb2Zmc2V0XG5cdFx0Ly8gYnV0IHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZVxuXHRcdFNhcGMgPSBDIC0gbG9Cb1dvZmZzZXQ7XG5cdH1cblx0ZWxzZSB7XG5cdFx0U2FwYyA9IEMgKyBsb0JvV29mZnNldDtcblx0fVxuXG5cdHJldHVybiBTYXBjICogMTAwO1xufVxuXG4vLyBNaWNoZWxzb24gIGx1bWluYW5jZSBjb250cmFzdFxuLy8gdGhlIHJlbGF0aW9uIGJldHdlZW4gdGhlIHNwcmVhZCBhbmQgdGhlIHN1bSBvZiB0aGUgdHdvIGx1bWluYW5jZXNcbi8vIFN5bW1ldHJpYywgZG9lcyBub3QgbWF0dGVyIHdoaWNoIGlzIGZvcmVncm91bmQgYW5kIHdoaWNoIGlzIGJhY2tncm91bmRcbi8vIE5vIGJsYWNrIGxldmVsIGNvbXBlbnNhdGlvbiBmb3IgZmxhcmUuXG5cblxuZnVuY3Rpb24gY29udHJhc3RNaWNoZWxzb24gKGNvbG9yMSwgY29sb3IyKSB7XG5cdGNvbG9yMSA9IGdldENvbG9yKGNvbG9yMSk7XG5cdGNvbG9yMiA9IGdldENvbG9yKGNvbG9yMik7XG5cblx0bGV0IFkxID0gTWF0aC5tYXgoZ2V0THVtaW5hbmNlKGNvbG9yMSksIDApO1xuXHRsZXQgWTIgPSBNYXRoLm1heChnZXRMdW1pbmFuY2UoY29sb3IyKSwgMCk7XG5cblx0aWYgKFkyID4gWTEpIHtcblx0XHRbWTEsIFkyXSA9IFtZMiwgWTFdO1xuXHR9XG5cblx0bGV0IGRlbm9tID0gKFkxICsgWTIpO1xuXHRyZXR1cm4gZGVub20gPT09IDAgPyAwIDogKFkxIC0gWTIpIC8gZGVub207XG59XG5cbi8vIFdlYmVyIGx1bWluYW5jZSBjb250cmFzdFxuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGx1bWluYW5jZXMgZGl2aWRlZCBieSB0aGUgbG93ZXIgbHVtaW5hbmNlXG4vLyBTeW1tZXRyaWMsIGRvZXMgbm90IG1hdHRlciB3aGljaCBpcyBmb3JlZ3JvdW5kIGFuZCB3aGljaCBpcyBiYWNrZ3JvdW5kXG4vLyBObyBibGFjayBsZXZlbCBjb21wZW5zYXRpb24gZm9yIGZsYXJlLlxuXG5cbi8vIHRoZSBkYXJrZXN0IHNSR0IgY29sb3IgYWJvdmUgYmxhY2sgaXMgIzAwMDAwMSBhbmQgdGhpcyBwcm9kdWNlc1xuLy8gYSBwbGFpbiBXZWJlciBjb250cmFzdCBvZiB+NDU2NDcuXG4vLyBTbywgc2V0dGluZyB0aGUgZGl2aWRlLWJ5LXplcm8gcmVzdWx0IGF0IDUwMDAwIGlzIGEgcmVhc29uYWJsZVxuLy8gbWF4IGNsYW1wIGZvciB0aGUgcGxhaW4gV2ViZXJcbmNvbnN0IG1heCA9IDUwMDAwO1xuXG5mdW5jdGlvbiBjb250cmFzdFdlYmVyIChjb2xvcjEsIGNvbG9yMikge1xuXHRjb2xvcjEgPSBnZXRDb2xvcihjb2xvcjEpO1xuXHRjb2xvcjIgPSBnZXRDb2xvcihjb2xvcjIpO1xuXG5cdGxldCBZMSA9IE1hdGgubWF4KGdldEx1bWluYW5jZShjb2xvcjEpLCAwKTtcblx0bGV0IFkyID0gTWF0aC5tYXgoZ2V0THVtaW5hbmNlKGNvbG9yMiksIDApO1xuXG5cdGlmIChZMiA+IFkxKSB7XG5cdFx0W1kxLCBZMl0gPSBbWTIsIFkxXTtcblx0fVxuXG5cdHJldHVybiBZMiA9PT0gMCA/IG1heCA6IChZMSAtIFkyKSAvIFkyO1xufVxuXG4vLyBDSUUgTGlnaHRuZXNzIGRpZmZlcmVuY2UsIGFzIHVzZWQgYnkgR29vZ2xlIE1hdGVyaWFsIERlc2lnblxuLy8gR29vZ2xlIEhDVCBUb25lIGlzIHRoZSBzYW1lIGFzIENJRSBMaWdodG5lc3Ncbi8vIGh0dHBzOi8vbWF0ZXJpYWwuaW8vYmxvZy9zY2llbmNlLW9mLWNvbG9yLWRlc2lnblxuXG5cbmZ1bmN0aW9uIGNvbnRyYXN0THN0YXIgKGNvbG9yMSwgY29sb3IyKSB7XG5cdGNvbG9yMSA9IGdldENvbG9yKGNvbG9yMSk7XG5cdGNvbG9yMiA9IGdldENvbG9yKGNvbG9yMik7XG5cblx0bGV0IEwxID0gZ2V0KGNvbG9yMSwgW2xhYiwgXCJsXCJdKTtcblx0bGV0IEwyID0gZ2V0KGNvbG9yMiwgW2xhYiwgXCJsXCJdKTtcblxuXHRyZXR1cm4gTWF0aC5hYnMoTDEgLSBMMik7XG59XG5cbi8vIM66ICogzrUgID0gMl4zID0gOFxuY29uc3QgzrUkMSA9IDIxNi8yNDM4OTsgIC8vIDZeMy8yOV4zID09ICgyNC8xMTYpXjNcbmNvbnN0IM61MyA9IDI0LzExNjtcbmNvbnN0IM66ID0gMjQzODkvMjc7ICAgLy8gMjleMy8zXjNcblxubGV0IHdoaXRlID0gV0hJVEVTLkQ2NTtcblxudmFyIGxhYl9kNjUgPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcImxhYi1kNjVcIixcblx0bmFtZTogXCJMYWIgRDY1XCIsXG5cdGNvb3Jkczoge1xuXHRcdGw6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMTAwXSxcblx0XHRcdG5hbWU6IFwiTFwiXG5cdFx0fSxcblx0XHRhOiB7XG5cdFx0XHRyZWZSYW5nZTogWy0xMjUsIDEyNV1cblx0XHR9LFxuXHRcdGI6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTEyNSwgMTI1XVxuXHRcdH1cblx0fSxcblxuXHQvLyBBc3N1bWluZyBYWVogaXMgcmVsYXRpdmUgdG8gRDY1LCBjb252ZXJ0IHRvIENJRSBMYWJcblx0Ly8gZnJvbSBDSUUgc3RhbmRhcmQsIHdoaWNoIG5vdyBkZWZpbmVzIHRoZXNlIGFzIGEgcmF0aW9uYWwgZnJhY3Rpb25cblx0d2hpdGUsXG5cblx0YmFzZTogWFlaX0Q2NSxcblx0Ly8gQ29udmVydCBENjUtYWRhcHRlZCBYWVogdG8gTGFiXG5cdC8vICBDSUUgMTUuMzoyMDA0IHNlY3Rpb24gOC4yLjEuMVxuXHRmcm9tQmFzZSAoWFlaKSB7XG5cdFx0Ly8gY29tcHV0ZSB4eXosIHdoaWNoIGlzIFhZWiBzY2FsZWQgcmVsYXRpdmUgdG8gcmVmZXJlbmNlIHdoaXRlXG5cdFx0bGV0IHh5eiA9IFhZWi5tYXAoKHZhbHVlLCBpKSA9PiB2YWx1ZSAvIHdoaXRlW2ldKTtcblxuXHRcdC8vIG5vdyBjb21wdXRlIGZcblx0XHRsZXQgZiA9IHh5ei5tYXAodmFsdWUgPT4gdmFsdWUgPiDOtSQxID8gTWF0aC5jYnJ0KHZhbHVlKSA6ICjOuiAqIHZhbHVlICsgMTYpLzExNik7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0KDExNiAqIGZbMV0pIC0gMTYsIFx0IC8vIExcblx0XHRcdDUwMCAqIChmWzBdIC0gZlsxXSksIC8vIGFcblx0XHRcdDIwMCAqIChmWzFdIC0gZlsyXSkgIC8vIGJcblx0XHRdO1xuXHR9LFxuXHQvLyBDb252ZXJ0IExhYiB0byBENjUtYWRhcHRlZCBYWVpcblx0Ly8gU2FtZSByZXN1bHQgYXMgQ0lFIDE1LjM6MjAwNCBBcHBlbmRpeCBEIGFsdGhvdWdoIHRoZSBkZXJpdmF0aW9uIGlzIGRpZmZlcmVudFxuXHQvLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9SR0JfWFlaX01hdHJpeC5odG1sXG5cdHRvQmFzZSAoTGFiKSB7XG5cdFx0Ly8gY29tcHV0ZSBmLCBzdGFydGluZyB3aXRoIHRoZSBsdW1pbmFuY2UtcmVsYXRlZCB0ZXJtXG5cdFx0bGV0IGYgPSBbXTtcblx0XHRmWzFdID0gKExhYlswXSArIDE2KS8xMTY7XG5cdFx0ZlswXSA9IExhYlsxXS81MDAgKyBmWzFdO1xuXHRcdGZbMl0gPSBmWzFdIC0gTGFiWzJdLzIwMDtcblxuXHRcdC8vIGNvbXB1dGUgeHl6XG5cdFx0bGV0IHh5eiA9IFtcblx0XHRcdGZbMF0gICA+IM61MyAgPyAgTWF0aC5wb3coZlswXSwgMykgICAgICAgICAgICA6ICgxMTYqZlswXS0xNikvzrosXG5cdFx0XHRMYWJbMF0gPiA4ICAgPyAgTWF0aC5wb3coKExhYlswXSsxNikvMTE2LCAzKSA6IExhYlswXS/Ouixcblx0XHRcdGZbMl0gICA+IM61MyAgPyAgTWF0aC5wb3coZlsyXSwgMykgICAgICAgICAgICA6ICgxMTYqZlsyXS0xNikvzrpcblx0XHRdO1xuXG5cdFx0Ly8gQ29tcHV0ZSBYWVogYnkgc2NhbGluZyB4eXogYnkgcmVmZXJlbmNlIHdoaXRlXG5cdFx0cmV0dXJuIHh5ei5tYXAoKHZhbHVlLCBpKSA9PiB2YWx1ZSAqIHdoaXRlW2ldKTtcblx0fSxcblxuXHRmb3JtYXRzOiB7XG5cdFx0XCJsYWItZDY1XCI6IHtcblx0XHRcdGNvb3JkczogW1wiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5cIiwgXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlstMSwxXVwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+Wy0xLDFdXCJdLFxuXHRcdH1cblx0fVxufSk7XG5cbi8vIERlbHRhIFBoaSBTdGFyIHBlcmNlcHR1YWwgbGlnaHRuZXNzIGNvbnRyYXN0XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL015bmRleC9kZWx0YXBoaXN0YXJcbi8vIFRoZSAoZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBMc3RhcnMgZWFjaCByYWlzZWQgdG8gcGhpKSByYWlzZWQgdG8gKDEvcGhpKVxuLy8gU3ltbWV0cmljLCBkb2VzIG5vdCBtYXR0ZXIgd2hpY2ggaXMgZm9yZWdyb3VuZCBhbmQgd2hpY2ggaXMgYmFja2dyb3VuZFxuXG5cbmNvbnN0IHBoaSA9IE1hdGgucG93KDUsIDAuNSkgKiAwLjUgKyAwLjU7IC8vIE1hdGgucGhpIGNhbiBiZSB1c2VkIGlmIE1hdGguanNcblxuZnVuY3Rpb24gY29udHJhc3REZWx0YVBoaSAoY29sb3IxLCBjb2xvcjIpIHtcblx0Y29sb3IxID0gZ2V0Q29sb3IoY29sb3IxKTtcblx0Y29sb3IyID0gZ2V0Q29sb3IoY29sb3IyKTtcblxuXHRsZXQgTHN0cjEgPSBnZXQoY29sb3IxLCBbbGFiX2Q2NSwgXCJsXCJdKTtcblx0bGV0IExzdHIyID0gZ2V0KGNvbG9yMiwgW2xhYl9kNjUsIFwibFwiXSk7XG5cblx0bGV0IGRlbHRhUGhpU3RhciA9IE1hdGguYWJzKE1hdGgucG93KExzdHIxLCBwaGkpIC0gTWF0aC5wb3coTHN0cjIsIHBoaSkpO1xuXG5cdGxldCBjb250cmFzdCA9IE1hdGgucG93KGRlbHRhUGhpU3RhciwgKDEgLyBwaGkpKSAqIE1hdGguU1FSVDIgLSA0MDtcblxuXHRyZXR1cm4gKGNvbnRyYXN0IDwgNy41KSA/IDAuMCA6IGNvbnRyYXN0IDtcbn1cblxudmFyIGNvbnRyYXN0TWV0aG9kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRjb250cmFzdEFQQ0E6IGNvbnRyYXN0QVBDQSxcblx0Y29udHJhc3REZWx0YVBoaTogY29udHJhc3REZWx0YVBoaSxcblx0Y29udHJhc3RMc3RhcjogY29udHJhc3RMc3Rhcixcblx0Y29udHJhc3RNaWNoZWxzb246IGNvbnRyYXN0TWljaGVsc29uLFxuXHRjb250cmFzdFdDQUcyMTogY29udHJhc3RXQ0FHMjEsXG5cdGNvbnRyYXN0V2ViZXI6IGNvbnRyYXN0V2ViZXJcbn0pO1xuXG5mdW5jdGlvbiBjb250cmFzdCAoYmFja2dyb3VuZCwgZm9yZWdyb3VuZCwgbyA9IHt9KSB7XG5cdGlmIChpc1N0cmluZyhvKSkge1xuXHRcdG8gPSB7YWxnb3JpdGhtOiBvfTtcblx0fVxuXG5cdGxldCB7YWxnb3JpdGhtLCAuLi5yZXN0fSA9IG87XG5cblx0aWYgKCFhbGdvcml0aG0pIHtcblx0XHRsZXQgYWxnb3JpdGhtcyA9IE9iamVjdC5rZXlzKGNvbnRyYXN0TWV0aG9kcykubWFwKGEgPT4gYS5yZXBsYWNlKC9eY29udHJhc3QvLCBcIlwiKSkuam9pbihcIiwgXCIpO1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYGNvbnRyYXN0KCkgZnVuY3Rpb24gbmVlZHMgYSBjb250cmFzdCBhbGdvcml0aG0uIFBsZWFzZSBzcGVjaWZ5IG9uZSBvZjogJHthbGdvcml0aG1zfWApO1xuXHR9XG5cblx0YmFja2dyb3VuZCA9IGdldENvbG9yKGJhY2tncm91bmQpO1xuXHRmb3JlZ3JvdW5kID0gZ2V0Q29sb3IoZm9yZWdyb3VuZCk7XG5cblx0Zm9yIChsZXQgYSBpbiBjb250cmFzdE1ldGhvZHMpIHtcblx0XHRpZiAoXCJjb250cmFzdFwiICsgYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09IGEudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0cmV0dXJuIGNvbnRyYXN0TWV0aG9kc1thXShiYWNrZ3JvdW5kLCBmb3JlZ3JvdW5kLCByZXN0KTtcblx0XHR9XG5cdH1cblxuXHR0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGNvbnRyYXN0IGFsZ29yaXRobTogJHthbGdvcml0aG19YCk7XG59XG5cbi8vIENocm9tYXRpY2l0eSBjb29yZGluYXRlc1xuZnVuY3Rpb24gdXYgKGNvbG9yKSB7XG5cdGxldCBbWCwgWSwgWl0gPSBnZXRBbGwoY29sb3IsIFhZWl9ENjUpO1xuXHRsZXQgZGVub20gPSBYICsgMTUgKiBZICsgMyAqIFo7XG5cdHJldHVybiBbNCAqIFggLyBkZW5vbSwgOSAqIFkgLyBkZW5vbV07XG59XG5cbmZ1bmN0aW9uIHh5IChjb2xvcikge1xuXHRsZXQgW1gsIFksIFpdID0gZ2V0QWxsKGNvbG9yLCBYWVpfRDY1KTtcblx0bGV0ICBzdW0gPSBYICsgWSArIFo7XG5cdHJldHVybiBbWCAvIHN1bSwgWSAvIHN1bV07XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyJDEgKENvbG9yKSB7XG5cdC8vIG5vIHNldHRlcnMsIGFzIGxpZ2h0bmVzcyBpbmZvcm1hdGlvbiBpcyBsb3N0XG5cdC8vIHdoZW4gY29udmVydGluZyBjb2xvciB0byBjaHJvbWF0aWNpdHlcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgXCJ1dlwiLCB7XG5cdFx0Z2V0ICgpIHtcblx0XHRcdHJldHVybiB1dih0aGlzKTtcblx0XHR9XG5cdH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsIFwieHlcIiwge1xuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4geHkodGhpcyk7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIGNocm9tYXRpY2l0eSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRyZWdpc3RlcjogcmVnaXN0ZXIkMSxcblx0dXY6IHV2LFxuXHR4eTogeHlcbn0pO1xuXG5mdW5jdGlvbiBkZWx0YUU3NiAoY29sb3IsIHNhbXBsZSkge1xuXHRyZXR1cm4gZGlzdGFuY2UoY29sb3IsIHNhbXBsZSwgXCJsYWJcIik7XG59XG5cbi8vIE1vcmUgYWNjdXJhdGUgY29sb3ItZGlmZmVyZW5jZSBmb3JtdWxhZVxuLy8gdGhhbiB0aGUgc2ltcGxlIDE5NzYgRXVjbGlkZWFuIGRpc3RhbmNlIGluIExhYlxuXG4vLyBDTUMgYnkgdGhlIENvbG9yIE1lYXN1cmVtZW50IENvbW1pdHRlZSBvZiB0aGVcbi8vIEJyYWRmb3JkIFNvY2lldHkgb2YgRHllaXN0cyBhbmQgQ29sb3JzdHMsIDE5OTQuXG4vLyBVc2VzIExDSCByYXRoZXIgdGhhbiBMYWIsXG4vLyB3aXRoIGRpZmZlcmVudCB3ZWlnaHRzIGZvciBMLCBDIGFuZCBIIGRpZmZlcmVuY2VzXG4vLyBBIG5pY2UgaW5jcmVhc2UgaW4gYWNjdXJhY3kgZm9yIG1vZGVzdCBpbmNyZWFzZSBpbiBjb21wbGV4aXR5XG5jb25zdCDPgCA9IE1hdGguUEk7XG5jb25zdCBkMnIgPSDPgCAvIDE4MDtcblxuZnVuY3Rpb24gZGVsdGFFQ01DIChjb2xvciwgc2FtcGxlLCB7bCA9IDIsIGMgPSAxfSA9IHt9KSB7XG5cdC8vIEdpdmVuIHRoaXMgY29sb3IgYXMgdGhlIHJlZmVyZW5jZVxuXHQvLyBhbmQgYSBzYW1wbGUsXG5cdC8vIGNhbGN1bGF0ZSBkZWx0YUUgQ01DLlxuXG5cdC8vIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGUgcGFyYW1ldHJpY1xuXHQvLyB3ZWlnaHRpbmcgZmFjdG9ycyBsOmMgYXJlIDI6MVxuXHQvLyB3aGljaCBpcyB0eXBpY2FsIGZvciBub24tdGV4dGlsZSB1c2VzLlxuXG5cdGxldCBbTDEsIGExLCBiMV0gPSBsYWIuZnJvbShjb2xvcik7XG5cdGxldCBbLCBDMSwgSDFdID0gbGNoLmZyb20obGFiLCBbTDEsIGExLCBiMV0pO1xuXHRsZXQgW0wyLCBhMiwgYjJdID0gbGFiLmZyb20oc2FtcGxlKTtcblx0bGV0IEMyID0gbGNoLmZyb20obGFiLCBbTDIsIGEyLCBiMl0pWzFdO1xuXG5cdC8vIGxldCBbTDEsIGExLCBiMV0gPSBjb2xvci5nZXRBbGwobGFiKTtcblx0Ly8gbGV0IEMxID0gY29sb3IuZ2V0KFwibGNoLmNcIik7XG5cdC8vIGxldCBIMSA9IGNvbG9yLmdldChcImxjaC5oXCIpO1xuXHQvLyBsZXQgW0wyLCBhMiwgYjJdID0gc2FtcGxlLmdldEFsbChsYWIpO1xuXHQvLyBsZXQgQzIgPSBzYW1wbGUuZ2V0KFwibGNoLmNcIik7XG5cblx0Ly8gQ2hlY2sgZm9yIG5lZ2F0aXZlIENocm9tYSxcblx0Ly8gd2hpY2ggbWlnaHQgaGFwcGVuIHRocm91Z2hcblx0Ly8gZGlyZWN0IHVzZXIgaW5wdXQgb2YgTENIIHZhbHVlc1xuXG5cdGlmIChDMSA8IDApIHtcblx0XHRDMSA9IDA7XG5cdH1cblx0aWYgKEMyIDwgMCkge1xuXHRcdEMyID0gMDtcblx0fVxuXG5cdC8vIHdlIGRvbid0IG5lZWQgSDIgYXMgzpRIIGlzIGNhbGN1bGF0ZWQgZnJvbSDOlGEsIM6UYiBhbmQgzpRDXG5cblx0Ly8gTGlnaHRuZXNzIGFuZCBDaHJvbWEgZGlmZmVyZW5jZXNcblx0Ly8gVGhlc2UgYXJlIChjb2xvciAtIHNhbXBsZSksIHVubGlrZSBkZWx0YUUyMDAwXG5cdGxldCDOlEwgPSBMMSAtIEwyO1xuXHRsZXQgzpRDID0gQzEgLSBDMjtcblxuXHRsZXQgzpRhID0gYTEgLSBhMjtcblx0bGV0IM6UYiA9IGIxIC0gYjI7XG5cblx0Ly8gd2VpZ2h0ZWQgSHVlIGRpZmZlcmVuY2UsIGxlc3MgZm9yIGxhcmdlciBDaHJvbWEgZGlmZmVyZW5jZVxuXG5cdGxldCBIMiA9ICjOlGEgKiogMikgKyAozpRiICoqIDIpIC0gKM6UQyAqKiAyKTtcblx0Ly8gZHVlIHRvIHJvdW5kb2ZmIGVycm9yIGl0IGlzIHBvc3NpYmxlIHRoYXQsIGZvciB6ZXJvIGEgYW5kIGIsXG5cdC8vIM6UQyA+IM6UYSArIM6UYiBpcyAwLCByZXN1bHRpbmcgaW4gYXR0ZW1wdGluZ1xuXHQvLyB0byB0YWtlIHRoZSBzcXVhcmUgcm9vdCBvZiBhIG5lZ2F0aXZlIG51bWJlclxuXG5cdC8vIHRyeWluZyBpbnN0ZWFkIHRoZSBlcXVhdGlvbiBmcm9tIEluZHVzdHJpYWwgQ29sb3IgUGh5c2ljc1xuXHQvLyBCeSBHZW9yZyBBLiBLbGVpblxuXG5cdC8vIGxldCDOlEggPSAoKGExICogYjIpIC0gKGEyICogYjEpKSAvIE1hdGguc3FydCgwLjUgKiAoKEMyICogQzEpICsgKGEyICogYTEpICsgKGIyICogYjEpKSk7XG5cdC8vIGNvbnNvbGUubG9nKHvOlEh9KTtcblx0Ly8gVGhpcyBnaXZlcyB0aGUgc2FtZSByZXN1bHQgdG8gMTIgZGVjaW1hbCBwbGFjZXNcblx0Ly8gZXhjZXB0IGl0IHNvbWV0aW1lcyBOYU5zIHdoZW4gdHJ5aW5nIHRvIHJvb3QgYSBuZWdhdGl2ZSBudW1iZXJcblxuXHQvLyBsZXQgzpRIID0gTWF0aC5zcXJ0KEgyKTsgd2UgbmV2ZXIgYWN0dWFsbHkgdXNlIHRoZSByb290LCBpdCBnZXRzIHNxdWFyZWQgYWdhaW4hIVxuXG5cdC8vIHBvc2l0aW9uYWwgY29ycmVjdGlvbnMgdG8gdGhlIGxhY2sgb2YgdW5pZm9ybWl0eSBvZiBDSUVMQUJcblx0Ly8gVGhlc2UgYXJlIGFsbCB0cnlpbmcgdG8gbWFrZSBKTkQgZWxsaXBzb2lkcyBtb3JlIGxpa2Ugc3BoZXJlc1xuXG5cdC8vIFNMIExpZ2h0bmVzcyBjcmlzcGVuaW5nIGZhY3RvciwgZGVwZW5kcyBlbnRpcmVseSBvbiBMMSBub3QgTDJcblx0bGV0IFNMID0gMC41MTE7XHQvLyBsaW5lYXIgcG9ydGlvbiBvZiB0aGUgWSB0byBMIHRyYW5zZmVyIGZ1bmN0aW9uXG5cdGlmIChMMSA+PSAxNikge1x0Ly8gY3ViaWMgcG9ydGlvblxuXHRcdFNMID0gKDAuMDQwOTc1ICogTDEpIC8gKDEgKyAwLjAxNzY1ICogTDEpO1xuXHR9XG5cblx0Ly8gU0MgQ2hyb21hIGZhY3RvclxuXHRsZXQgU0MgPSAoKDAuMDYzOCAqIEMxKSAvICgxICsgMC4wMTMxICogQzEpKSArIDAuNjM4O1xuXG5cdC8vIENyb3NzIHRlcm0gVCBmb3IgYmx1ZSBub24tbGluZWFyaXR5XG5cdGxldCBUO1xuXHRpZiAoIE51bWJlci5pc05hTihIMSkpIHtcblx0XHRIMSA9IDA7XG5cdH1cblxuXHRpZiAoSDEgPj0gMTY0ICYmIEgxIDw9IDM0NSkge1xuXHRcdFQgPSAwLjU2ICsgTWF0aC5hYnMoMC4yICogTWF0aC5jb3MoKEgxICsgMTY4KSAqIGQycikpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdFQgPSAwLjM2ICsgTWF0aC5hYnMoMC40ICogTWF0aC5jb3MoKEgxICsgMzUpICogZDJyKSk7XG5cdH1cblx0Ly8gY29uc29sZS5sb2coe1R9KTtcblxuXHQvLyBTSCBIdWUgZmFjdG9yIGFsc28gZGVwZW5kcyBvbiBDMSxcblx0bGV0IEM0ID0gTWF0aC5wb3coQzEsIDQpO1xuXHRsZXQgRiA9IE1hdGguc3FydChDNCAvIChDNCArIDE5MDApKTtcblx0bGV0IFNIID0gU0MgKiAoKEYgKiBUKSArIDEgLSBGKTtcblxuXHQvLyBGaW5hbGx5IGNhbGN1bGF0ZSB0aGUgZGVsdGFFLCB0ZXJtIGJ5IHRlcm0gYXMgcm9vdCBzdW1lIG9mIHNxdWFyZXNcblx0bGV0IGRFID0gKM6UTCAvIChsICogU0wpKSAqKiAyO1xuXHRkRSArPSAozpRDIC8gKGMgKiBTQykpICoqIDI7XG5cdGRFICs9IChIMiAvIChTSCAqKiAyKSk7XG5cdC8vIGRFICs9ICjOlEggLyBTSCkgICoqIDI7XG5cdHJldHVybiBNYXRoLnNxcnQoZEUpO1xuXHQvLyBZYXkhISFcbn1cblxuY29uc3QgWXckMSA9IDIwMztcdC8vIGFic29sdXRlIGx1bWluYW5jZSBvZiBtZWRpYSB3aGl0ZVxuXG52YXIgWFlaX0Fic19ENjUgPSBuZXcgQ29sb3JTcGFjZSh7XG4vLyBBYnNvbHV0ZSBDSUUgWFlaLCB3aXRoIGEgRDY1IHdoaXRlcG9pbnQsXG4vLyBhcyB1c2VkIGluIG1vc3QgSERSIGNvbG9yc3BhY2VzIGFzIGEgc3RhcnRpbmcgcG9pbnQuXG4vLyBTRFIgc3BhY2VzIGFyZSBjb252ZXJ0ZWQgcGVyIEJULjIwNDhcbi8vIHNvIHRoYXQgZGlmZnVzZSwgbWVkaWEgd2hpdGUgaXMgMjAzIGNkL23CslxuXHRpZDogXCJ4eXotYWJzLWQ2NVwiLFxuXHRuYW1lOiBcIkFic29sdXRlIFhZWiBENjVcIixcblx0Y29vcmRzOiB7XG5cdFx0eDoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCA5NTA0LjddLFxuXHRcdFx0bmFtZTogXCJYYVwiLFxuXHRcdH0sXG5cdFx0eToge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAxMDAwMF0sXG5cdFx0XHRuYW1lOiBcIllhXCIsXG5cdFx0fSxcblx0XHR6OiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDEwODg4LjNdLFxuXHRcdFx0bmFtZTogXCJaYVwiLFxuXHRcdH1cblx0fSxcblxuXHRiYXNlOiBYWVpfRDY1LFxuXHRmcm9tQmFzZSAoWFlaKSB7XG5cdFx0Ly8gTWFrZSBYWVogYWJzb2x1dGUsIG5vdCByZWxhdGl2ZSB0byBtZWRpYSB3aGl0ZVxuXHRcdC8vIE1heGltdW0gbHVtaW5hbmNlIGluIFBRIGlzIDEwLDAwMCBjZC9twrJcblx0XHQvLyBSZWxhdGl2ZSBYWVogaGFzIFk9MSBmb3IgbWVkaWEgd2hpdGVcblx0XHRyZXR1cm4gWFlaLm1hcCAodiA9PiBNYXRoLm1heCh2ICogWXckMSwgMCkpO1xuXHR9LFxuXHR0b0Jhc2UgKEFic1hZWikge1xuXHRcdC8vIENvbnZlcnQgdG8gbWVkaWEtd2hpdGUgcmVsYXRpdmUgWFlaXG5cdFx0cmV0dXJuIEFic1hZWi5tYXAodiA9PiBNYXRoLm1heCh2IC8gWXckMSwgMCkpO1xuXHR9XG59KTtcblxuY29uc3QgYiQxID0gMS4xNTtcbmNvbnN0IGcgPSAwLjY2O1xuY29uc3QgbiQxID0gMjYxMCAvICgyICoqIDE0KTtcbmNvbnN0IG5pbnYkMSA9ICgyICoqIDE0KSAvIDI2MTA7XG5jb25zdCBjMSQyID0gMzQyNCAvICgyICoqIDEyKTtcbmNvbnN0IGMyJDIgPSAyNDEzIC8gKDIgKiogNyk7XG5jb25zdCBjMyQyID0gMjM5MiAvICgyICoqIDcpO1xuY29uc3QgcCA9IDEuNyAqIDI1MjMgLyAoMiAqKiA1KTtcbmNvbnN0IHBpbnYgPSAoMiAqKiA1KSAvICgxLjcgKiAyNTIzKTtcbmNvbnN0IGQgPSAtMC41NjtcbmNvbnN0IGQwID0gMS42Mjk1NDk5NTMyODIxNTY2RS0xMTtcblxuY29uc3QgWFladG9Db25lX00gPSBbXG5cdFsgIDAuNDE0Nzg5NzIsIDAuNTc5OTk5LCAgMC4wMTQ2NDgwIF0sXG5cdFsgLTAuMjAxNTEwMCwgIDEuMTIwNjQ5LCAgMC4wNTMxMDA4IF0sXG5cdFsgLTAuMDE2NjAwOCwgIDAuMjY0ODAwLCAgMC42Njg0Nzk5IF1cbl07XG4vLyBYWVp0b0NvbmVfTSBpbnZlcnRlZFxuY29uc3QgQ29uZXRvWFlaX00gPSBbXG5cdFsgIDEuOTI0MjI2NDM1Nzg3NjA2NywgIC0xLjAwNDc5MjMxMjU5NTM2NTcsICAwLjAzNzY1MTQwNDAzMDYxOCAgIF0sXG5cdFsgIDAuMzUwMzE2NzYyMDk0OTk5MDcsICAwLjcyNjQ4MTE5MzkzMTY1NTIsIC0wLjA2NTM4NDQyMjk0ODA4NTAxIF0sXG5cdFsgLTAuMDkwOTgyODEwOTgyODQ3NTIsIC0wLjMxMjcyODI5MDUyMzA3MzksICAxLjUyMjc2NjU2MTMwNTI2MDMgIF1cbl07XG5jb25zdCBDb25ldG9JYWJfTSA9IFtcblx0WyAgMC41LCAgICAgICAwLjUsICAgICAgIDAgICAgICAgIF0sXG5cdFsgIDMuNTI0MDAwLCAtNC4wNjY3MDgsICAwLjU0MjcwOCBdLFxuXHRbICAwLjE5OTA3NiwgIDEuMDk2Nzk5LCAtMS4yOTU4NzUgXVxuXTtcbi8vIENvbmV0b0lhYl9NIGludmVydGVkXG5jb25zdCBJYWJ0b0NvbmVfTSA9IFtcblx0WyAxLCAgICAgICAgICAgICAgICAgICAwLjEzODYwNTA0MzI3MTUzOTMsICAgMC4wNTgwNDczMTYxNTYxMTg4NiBdLFxuXHRbIDAuOTk5OTk5OTk5OTk5OTk5OSwgLTAuMTM4NjA1MDQzMjcxNTM5MywgIC0wLjA1ODA0NzMxNjE1NjExODg2IF0sXG5cdFsgMC45OTk5OTk5OTk5OTk5OTk4LCAtMC4wOTYwMTkyNDIwMjYzMTg5NSwgLTAuODExODkxODk2MDU2MDM4OCAgXVxuXTtcblxudmFyIEp6YXpieiA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwianphemJ6XCIsXG5cdG5hbWU6IFwiSnphemJ6XCIsXG5cdGNvb3Jkczoge1xuXHRcdGp6OiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDFdLFxuXHRcdFx0bmFtZTogXCJKelwiLFxuXHRcdH0sXG5cdFx0YXo6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTAuNSwgMC41XSxcblx0XHR9LFxuXHRcdGJ6OiB7XG5cdFx0XHRyZWZSYW5nZTogWy0wLjUsIDAuNV0sXG5cdFx0fVxuXHR9LFxuXG5cdGJhc2U6IFhZWl9BYnNfRDY1LFxuXHRmcm9tQmFzZSAoWFlaKSB7XG5cdFx0Ly8gRmlyc3QgbWFrZSBYWVogYWJzb2x1dGUsIG5vdCByZWxhdGl2ZSB0byBtZWRpYSB3aGl0ZVxuXHRcdC8vIE1heGltdW0gbHVtaW5hbmNlIGluIFBRIGlzIDEwLDAwMCBjZC9twrJcblx0XHQvLyBSZWxhdGl2ZSBYWVogaGFzIFk9MSBmb3IgbWVkaWEgd2hpdGVcblx0XHQvLyBCVC4yMDQ4IHNheXMgbWVkaWEgd2hpdGUgWT0yMDMgYXQgUFEgNThcblxuXHRcdGxldCBbIFhhLCBZYSwgWmEgXSA9IFhZWjtcblxuXHRcdC8vIG1vZGlmeSBYIGFuZCBZXG5cdFx0bGV0IFhtID0gKGIkMSAqIFhhKSAtICgoYiQxIC0gMSkgKiBaYSk7XG5cdFx0bGV0IFltID0gKGcgKiBZYSkgLSAoKGcgLSAxKSAqIFhhKTtcblxuXHRcdC8vIG1vdmUgdG8gTE1TIGNvbmUgZG9tYWluXG5cdFx0bGV0IExNUyA9IG11bHRpcGx5TWF0cmljZXMoWFladG9Db25lX00sIFsgWG0sIFltLCBaYSBdKTtcblxuXHRcdC8vIFBRLWVuY29kZSBMTVNcblx0XHRsZXQgUFFMTVMgPSBMTVMubWFwIChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRsZXQgbnVtID0gYzEkMiArIChjMiQyICogKCh2YWwgLyAxMDAwMCkgKiogbiQxKSk7XG5cdFx0XHRsZXQgZGVub20gPSAxICsgKGMzJDIgKiAoKHZhbCAvIDEwMDAwKSAqKiBuJDEpKTtcblxuXHRcdFx0cmV0dXJuIChudW0gLyBkZW5vbSkgICoqIHA7XG5cdFx0fSk7XG5cblx0XHQvLyBhbG1vc3QgdGhlcmUsIGNhbGN1bGF0ZSBJeiBheiBielxuXHRcdGxldCBbIEl6LCBheiwgYnpdID0gbXVsdGlwbHlNYXRyaWNlcyhDb25ldG9JYWJfTSwgUFFMTVMpO1xuXHRcdC8vIGNvbnNvbGUubG9nKHtJeiwgYXosIGJ6fSk7XG5cblx0XHRsZXQgSnogPSAoKDEgKyBkKSAqIEl6KSAvICgxICsgKGQgKiBJeikpIC0gZDA7XG5cdFx0cmV0dXJuIFtKeiwgYXosIGJ6XTtcblx0fSxcblx0dG9CYXNlIChKemF6YnopIHtcblx0XHRsZXQgW0p6LCBheiwgYnpdID0gSnphemJ6O1xuXHRcdGxldCBJeiA9IChKeiArIGQwKSAvICgxICsgZCAtIGQgKiAoSnogKyBkMCkpO1xuXG5cdFx0Ly8gYnJpbmcgaW50byBMTVMgY29uZSBkb21haW5cblx0XHRsZXQgUFFMTVMgPSBtdWx0aXBseU1hdHJpY2VzKElhYnRvQ29uZV9NLCBbIEl6LCBheiwgYnogXSk7XG5cblx0XHQvLyBjb252ZXJ0IGZyb20gUFEtY29kZWQgdG8gbGluZWFyLWxpZ2h0XG5cdFx0bGV0IExNUyA9IFBRTE1TLm1hcChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRsZXQgbnVtID0gKGMxJDIgLSAodmFsICoqIHBpbnYpKTtcblx0XHRcdGxldCBkZW5vbSA9IChjMyQyICogKHZhbCAqKiBwaW52KSkgLSBjMiQyO1xuXHRcdFx0bGV0IHggPSAxMDAwMCAqICgobnVtIC8gZGVub20pICoqIG5pbnYkMSk7XG5cblx0XHRcdHJldHVybiAoeCk7IFx0Ly8gbHVtaW5hbmNlIHJlbGF0aXZlIHRvIGRpZmZ1c2Ugd2hpdGUsIFswLCA3MCBvciBzb10uXG5cdFx0fSk7XG5cblx0XHQvLyBtb2RpZmllZCBhYnMgWFlaXG5cdFx0bGV0IFsgWG0sIFltLCBaYSBdID0gbXVsdGlwbHlNYXRyaWNlcyhDb25ldG9YWVpfTSwgTE1TKTtcblxuXHRcdC8vIHJlc3RvcmUgc3RhbmRhcmQgRDUwIHJlbGF0aXZlIFhZWiwgcmVsYXRpdmUgdG8gbWVkaWEgd2hpdGVcblx0XHRsZXQgWGEgPSAoWG0gKyAoKGIkMSAtMSkgKiBaYSkpIC8gYiQxO1xuXHRcdGxldCBZYSA9IChZbSArICgoZyAtMSkgKiBYYSkpIC8gZztcblx0XHRyZXR1cm4gWyBYYSwgWWEsIFphIF07XG5cdH0sXG5cblx0Zm9ybWF0czoge1xuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtY29sb3ItaGRyLyNKemF6Ynpcblx0XHRcImNvbG9yXCI6IHt9XG5cdH1cbn0pO1xuXG52YXIganpjemh6ID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJqemN6aHpcIixcblx0bmFtZTogXCJKekN6SHpcIixcblx0Y29vcmRzOiB7XG5cdFx0ano6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMV0sXG5cdFx0XHRuYW1lOiBcIkp6XCIsXG5cdFx0fSxcblx0XHRjejoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAxXSxcblx0XHRcdG5hbWU6IFwiQ2hyb21hXCIsXG5cdFx0fSxcblx0XHRoejoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAzNjBdLFxuXHRcdFx0dHlwZTogXCJhbmdsZVwiLFxuXHRcdFx0bmFtZTogXCJIdWVcIixcblx0XHR9XG5cdH0sXG5cblx0YmFzZTogSnphemJ6LFxuXHRmcm9tQmFzZSAoanphemJ6KSB7XG5cdFx0Ly8gQ29udmVydCB0byBwb2xhciBmb3JtXG5cdFx0bGV0IFtKeiwgYXosIGJ6XSA9IGp6YXpiejtcblx0XHRsZXQgaHVlO1xuXHRcdGNvbnN0IM61ID0gMC4wMDAyOyAvLyBjaHJvbWF0aWMgY29tcG9uZW50cyBtdWNoIHNtYWxsZXIgdGhhbiBhLGJcblxuXHRcdGlmIChNYXRoLmFicyhheikgPCDOtSAmJiBNYXRoLmFicyhieikgPCDOtSkge1xuXHRcdFx0aHVlID0gTmFOO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGh1ZSA9IE1hdGguYXRhbjIoYnosIGF6KSAqIDE4MCAvIE1hdGguUEk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtcblx0XHRcdEp6LCAvLyBKeiBpcyBzdGlsbCBKelxuXHRcdFx0TWF0aC5zcXJ0KGF6ICoqIDIgKyBieiAqKiAyKSwgLy8gQ2hyb21hXG5cdFx0XHRjb25zdHJhaW4oaHVlKSAvLyBIdWUsIGluIGRlZ3JlZXMgWzAgdG8gMzYwKVxuXHRcdF07XG5cdH0sXG5cdHRvQmFzZSAoanpjemh6KSB7XG5cdFx0Ly8gQ29udmVydCBmcm9tIHBvbGFyIGZvcm1cblx0XHQvLyBkZWJ1Z2dlcjtcblx0XHRyZXR1cm4gW1xuXHRcdFx0anpjemh6WzBdLCAvLyBKeiBpcyBzdGlsbCBKelxuXHRcdFx0anpjemh6WzFdICogTWF0aC5jb3Moanpjemh6WzJdICogTWF0aC5QSSAvIDE4MCksIC8vIGF6XG5cdFx0XHRqemN6aHpbMV0gKiBNYXRoLnNpbihqemN6aHpbMl0gKiBNYXRoLlBJIC8gMTgwKSAgLy8gYnpcblx0XHRdO1xuXHR9LFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHt9XG5cdH0sXG59KTtcblxuLy8gTW9yZSBhY2N1cmF0ZSBjb2xvci1kaWZmZXJlbmNlIGZvcm11bGFlXG4vLyB0aGFuIHRoZSBzaW1wbGUgMTk3NiBFdWNsaWRlYW4gZGlzdGFuY2UgaW4gTGFiXG5cbi8vIFVzZXMgSnpDekh6LCB3aGljaCBoYXMgaW1wcm92ZWQgcGVyY2VwdHVhbCB1bmlmb3JtaXR5XG4vLyBhbmQgdGh1cyBhIHNpbXBsZSBFdWNsaWRlYW4gcm9vdC1zdW0gb2YgzpRMwrIgzpRDwrIgzpRIwrJcbi8vIGdpdmVzIGdvb2QgcmVzdWx0cy5cblxuZnVuY3Rpb24gZGVsdGFFSnogKGNvbG9yLCBzYW1wbGUpIHtcblx0Ly8gR2l2ZW4gdGhpcyBjb2xvciBhcyB0aGUgcmVmZXJlbmNlXG5cdC8vIGFuZCBhIHNhbXBsZSxcblx0Ly8gY2FsY3VsYXRlIGRlbHRhRSBpbiBKekN6SHouXG5cdGxldCBbSnoxLCBDejEsIEh6MV0gPSBqemN6aHouZnJvbShjb2xvcik7XG5cdGxldCBbSnoyLCBDejIsIEh6Ml0gPSBqemN6aHouZnJvbShzYW1wbGUpO1xuXG5cdC8vIExpZ2h0bmVzcyBhbmQgQ2hyb21hIGRpZmZlcmVuY2VzXG5cdC8vIHNpZ24gZG9lcyBub3QgbWF0dGVyIGFzIHRoZXkgYXJlIHNxdWFyZWQuXG5cdGxldCDOlEogPSBKejEgLSBKejI7XG5cdGxldCDOlEMgPSBDejEgLSBDejI7XG5cblx0Ly8gbGVuZ3RoIG9mIGNob3JkIGZvciDOlEhcblx0aWYgKChOdW1iZXIuaXNOYU4oSHoxKSkgJiYgKE51bWJlci5pc05hTihIejIpKSkge1xuXHRcdC8vIGJvdGggdW5kZWZpbmVkIGh1ZXNcblx0XHRIejEgPSAwO1xuXHRcdEh6MiA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoTnVtYmVyLmlzTmFOKEh6MSkpIHtcblx0XHQvLyBvbmUgdW5kZWZpbmVkLCBzZXQgdG8gdGhlIGRlZmluZWQgaHVlXG5cdFx0SHoxID0gSHoyO1xuXHR9XG5cdGVsc2UgaWYgKE51bWJlci5pc05hTihIejIpKSB7XG5cdFx0SHoyID0gSHoxO1xuXHR9XG5cblx0bGV0IM6UaCA9IEh6MSAtIEh6Mjtcblx0bGV0IM6USCA9IDIgKiBNYXRoLnNxcnQoQ3oxICogQ3oyKSAqIE1hdGguc2luKCjOlGggLyAyKSAqIChNYXRoLlBJIC8gMTgwKSk7XG5cblx0cmV0dXJuIE1hdGguc3FydCjOlEogKiogMiArIM6UQyAqKiAyICsgzpRIICoqIDIpO1xufVxuXG5jb25zdCBjMSQxID0gMzQyNCAvIDQwOTY7XG5jb25zdCBjMiQxID0gMjQxMyAvIDEyODtcbmNvbnN0IGMzJDEgPSAyMzkyIC8gMTI4O1xuY29uc3QgbTEgPSAyNjEwIC8gMTYzODQ7XG5jb25zdCBtMiA9IDI1MjMgLyAzMjtcbmNvbnN0IGltMSA9IDE2Mzg0IC8gMjYxMDtcbmNvbnN0IGltMiA9IDMyIC8gMjUyMztcblxuLy8gVGhlIG1hdHJpeCBiZWxvdyBpbmNsdWRlcyB0aGUgNCUgY3Jvc3N0YWxrIGNvbXBvbmVudHNcbi8vIGFuZCBpcyBmcm9tIHRoZSBEb2xieSBcIldoYXQgaXMgSUN0Q3BcIiBwYXBlclwiXG5jb25zdCBYWVp0b0xNU19NJDEgPSBbXG5cdFsgMC4zNTkyLCAgMC42OTc2LCAtMC4wMzU4XSxcblx0Wy0wLjE5MjIsICAxLjEwMDQsICAwLjA3NTVdLFxuXHRbIDAuMDA3MCwgIDAuMDc0OSwgIDAuODQzNF1cbl07XG4vLyBsaW5lYXItbGlnaHQgUmVjLjIwMjAgdG8gTE1TLCBhZ2FpbiB3aXRoIGNyb3NzdGFsa1xuLy8gcmF0aW9uYWwgdGVybXMgZnJvbSBKYW4gRnLDtmhsaWNoLFxuLy8gRW5jb2RpbmcgSGlnaCBEeW5hbWljIFJhbmdlIGFuZFdpZGUgQ29sb3IgR2FtdXQgSW1hZ2VyeSwgcC45N1xuLy8gYW5kIElUVS1SIEJULjIxMjQtMCBwLjJcbi8qXG5jb25zdCBSZWMyMDIwdG9MTVNfTSA9IFtcblx0WyAxNjg4IC8gNDA5NiwgIDIxNDYgLyA0MDk2LCAgIDI2MiAvIDQwOTYgXSxcblx0WyAgNjgzIC8gNDA5NiwgIDI5NTEgLyA0MDk2LCAgIDQ2MiAvIDQwOTYgXSxcblx0WyAgIDk5IC8gNDA5NiwgICAzMDkgLyA0MDk2LCAgMzY4OCAvIDQwOTYgXVxuXTtcbiovXG4vLyB0aGlzIGluY2x1ZGVzIHRoZSBFYm5lciBMTVMgY29lZmZpY2llbnRzLFxuLy8gdGhlIHJvdGF0aW9uLCBhbmQgdGhlIHNjYWxpbmcgdG8gWy0wLjUsMC41XSByYW5nZVxuLy8gcmF0aW9uYWwgdGVybXMgZnJvbSBGcsO2aGxpY2ggcC45N1xuLy8gYW5kIElUVS1SIEJULjIxMjQtMCBwcC4yLTNcbmNvbnN0IExNU3RvSVBUX00gPSBbXG5cdFsgIDIwNDggLyA0MDk2LCAgIDIwNDggLyA0MDk2LCAgICAgICAwICAgICAgXSxcblx0WyAgNjYxMCAvIDQwOTYsIC0xMzYxMyAvIDQwOTYsICA3MDAzIC8gNDA5NiBdLFxuXHRbIDE3OTMzIC8gNDA5NiwgLTE3MzkwIC8gNDA5NiwgIC01NDMgLyA0MDk2IF1cbl07XG5cbi8vIGludmVydGVkIG1hdHJpY2VzLCBjYWxjdWxhdGVkIGZyb20gdGhlIGFib3ZlXG5jb25zdCBJUFR0b0xNU19NID0gW1xuXHRbMC45OTk5ODg4OTY1NjI4NDAxMzgzMywgMC4wMDg2MDUwNTAxNDcyODcwNTgyMSwgIDAuMTExMDM0MzcxNTk4NjE2NDc4NiBdLFxuXHRbMS4wMDAwMTExMDM0MzcxNTk4NjE2LCAtMC4wMDg2MDUwNTAxNDcyODcwNTgyMSwgLTAuMTExMDM0MzcxNTk4NjE2NDc4NiBdLFxuXHRbMS4wMDAwMzIwNjMzOTEwMDU0MTIsICAgMC41NjAwNDkxMzU0NzI3OTAwMDExMywgLTAuMzIwNjMzOTEwMDU0MTIwMjY0NjldLFxuXTtcbi8qXG5jb25zdCBMTVN0b1JlYzIwMjBfTSA9IFtcblx0WyAzLjQzNzU1Njg5MzI4MTQwMTIxMTIsICAgLTIuNTA3MjExMjEyNTA5NTA1ODE5NSwgICAwLjA2OTY1NDMxOTIyODEwNDYwODM4Ml0sXG5cdFstMC43OTE0Mjg2ODY2NTY0NDE1NjEyNSwgICAxLjk4MzgzNzIxOTg3NDAwODk4NzQsICAtMC4xOTI0MDg1MzMyMTc1Njc0MjYyNiBdLFxuXHRbLTAuMDI1NjQ2NjYyOTExNTA2NDc2MzYzLCAtMC4wOTkyNDAyNDg2NDM5NDU1NjY3NTEsIDEuMTI0ODg2OTExNTU1NDUyMDQzMSAgXVxuXTtcbiovXG5jb25zdCBMTVN0b1hZWl9NJDEgPSBbXG5cdFsgMi4wNzAxODAwNTY2OTU2MTM1MDk2LCAgIC0xLjMyNjQ1Njg3NjEwMzAyMTAyNTUsICAgIDAuMjA2NjE2MDA2ODQ3ODU1MTcwODEgXSxcblx0WyAwLjM2NDk4ODI1MDAzMjY1NzQ3OTc0LCAgIDAuNjgwNDY3MzYyODUyMjM1MTQxMDIsICAtMC4wNDU0MjE3NTMwNzU4NTMyMzE0MDldLFxuXHRbLTAuMDQ5NTk1NTQyMjM4OTMyMTA3ODk2LCAtMC4wNDk0MjExNjExODY3NTc0ODc0MTIsICAxLjE4Nzk5NTk0MTczMjgwMzQzOTQgIF1cbl07XG5cbi8vIE9ubHkgdGhlIFBRIGZvcm0gb2YgSUN0Q3AgaXMgaW1wbGVtZW50ZWQgaGVyZS4gVGhlcmUgaXMgYWxzbyBhbiBITEcgZm9ybS5cbi8vIGZyb20gRG9sYnksIFwiV0hBVCBJUyBJQ1RDUD9cIlxuLy8gaHR0cHM6Ly9wcm9mZXNzaW9uYWwuZG9sYnkuY29tL3NpdGVhc3NldHMvcGRmcy9pY3RjcF9kb2xieXdoaXRlcGFwZXJfdjA3MS5wZGZcbi8vIGFuZFxuLy8gRG9sYnksIFwiUGVyY2VwdHVhbCBDb2xvciBWb2x1bWVcbi8vIE1lYXN1cmluZyB0aGUgRGlzdGluZ3Vpc2hhYmxlIENvbG9ycyBvZiBIRFIgYW5kIFdDRyBEaXNwbGF5c1wiXG4vLyBodHRwczovL3Byb2Zlc3Npb25hbC5kb2xieS5jb20vc2l0ZWFzc2V0cy9wZGZzL2RvbGJ5LXZpc2lvbi1tZWFzdXJpbmctcGVyY2VwdHVhbC1jb2xvci12b2x1bWUtdjcuMS5wZGZcbnZhciBpY3RjcCA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwiaWN0Y3BcIixcblx0bmFtZTogXCJJQ1RDUFwiLFxuXHQvLyBGcm9tIEJULjIxMDAtMiBwYWdlIDc6XG5cdC8vIER1cmluZyBwcm9kdWN0aW9uLCBzaWduYWwgdmFsdWVzIGFyZSBleHBlY3RlZCB0byBleGNlZWQgdGhlXG5cdC8vIHJhbmdlIEXigLIgPSBbMC4wIDogMS4wXS4gVGhpcyBwcm92aWRlcyBwcm9jZXNzaW5nIGhlYWRyb29tIGFuZCBhdm9pZHNcblx0Ly8gc2lnbmFsIGRlZ3JhZGF0aW9uIGR1cmluZyBjYXNjYWRlZCBwcm9jZXNzaW5nLiBTdWNoIHZhbHVlcyBvZiBF4oCyLFxuXHQvLyBiZWxvdyAwLjAgb3IgZXhjZWVkaW5nIDEuMCwgc2hvdWxkIG5vdCBiZSBjbGlwcGVkIGR1cmluZyBwcm9kdWN0aW9uXG5cdC8vIGFuZCBleGNoYW5nZS5cblx0Ly8gVmFsdWVzIGJlbG93IDAuMCBzaG91bGQgbm90IGJlIGNsaXBwZWQgaW4gcmVmZXJlbmNlIGRpc3BsYXlzIChldmVuXG5cdC8vIHRob3VnaCB0aGV5IHJlcHJlc2VudCDigJxuZWdhdGl2ZeKAnSBsaWdodCkgdG8gYWxsb3cgdGhlIGJsYWNrIGxldmVsIG9mXG5cdC8vIHRoZSBzaWduYWwgKExCKSB0byBiZSBwcm9wZXJseSBzZXQgdXNpbmcgdGVzdCBzaWduYWxzIGtub3duIGFzIOKAnFBMVUdF4oCdXG5cdGNvb3Jkczoge1xuXHRcdGk6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMV0sXHQvLyBDb25zdGFudCBsdW1pbmFuY2UsXG5cdFx0XHRuYW1lOiBcIklcIlxuXHRcdH0sXG5cdFx0Y3Q6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTAuNSwgMC41XSxcdC8vIEZ1bGwgQlQuMjAyMCBnYW11dCBpbiByYW5nZSBbLTAuNSwgMC41XVxuXHRcdFx0bmFtZTogXCJDVFwiXG5cdFx0fSxcblx0XHRjcDoge1xuXHRcdFx0cmVmUmFuZ2U6IFstMC41LCAwLjVdLFxuXHRcdFx0bmFtZTogXCJDUFwiXG5cdFx0fVxuXHR9LFxuXG5cdGJhc2U6IFhZWl9BYnNfRDY1LFxuXHRmcm9tQmFzZSAoWFlaKSB7XG5cdFx0Ly8gbW92ZSB0byBMTVMgY29uZSBkb21haW5cblx0XHRsZXQgTE1TID0gbXVsdGlwbHlNYXRyaWNlcyhYWVp0b0xNU19NJDEsIFhZWik7XG5cblx0XHRyZXR1cm4gTE1TdG9JQ3RDcChMTVMpO1xuXHR9LFxuXHR0b0Jhc2UgKElDdENwKSB7XG5cdFx0bGV0IExNUyA9IElDdENwdG9MTVMoSUN0Q3ApO1xuXG5cdFx0cmV0dXJuIG11bHRpcGx5TWF0cmljZXMoTE1TdG9YWVpfTSQxLCBMTVMpO1xuXHR9LFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHt9XG5cdH0sXG59KTtcblxuZnVuY3Rpb24gTE1TdG9JQ3RDcCAoTE1TKSB7XG5cdC8vIGFwcGx5IHRoZSBQUSBFT1RGXG5cdC8vIHdlIGNhbid0IGV2ZXIgYmUgZGl2aWRpbmcgYnkgemVybyBiZWNhdXNlIG9mIHRoZSBcIjEgK1wiIGluIHRoZSBkZW5vbWluYXRvclxuXHRsZXQgUFFMTVMgPSBMTVMubWFwIChmdW5jdGlvbiAodmFsKSB7XG5cdFx0bGV0IG51bSA9IGMxJDEgKyAoYzIkMSAqICgodmFsIC8gMTAwMDApICoqIG0xKSk7XG5cdFx0bGV0IGRlbm9tID0gMSArIChjMyQxICogKCh2YWwgLyAxMDAwMCkgKiogbTEpKTtcblxuXHRcdHJldHVybiAobnVtIC8gZGVub20pICAqKiBtMjtcblx0fSk7XG5cblx0Ly8gTE1TIHRvIElQVCwgd2l0aCByb3RhdGlvbiBmb3IgWSdDJ2JDJ3IgY29tcGF0aWJpbGl0eVxuXHRyZXR1cm4gbXVsdGlwbHlNYXRyaWNlcyhMTVN0b0lQVF9NLCBQUUxNUyk7XG59XG5cbmZ1bmN0aW9uIElDdENwdG9MTVMgKElDdENwKSB7XG5cdGxldCBQUUxNUyA9IG11bHRpcGx5TWF0cmljZXMoSVBUdG9MTVNfTSwgSUN0Q3ApO1xuXG5cdC8vIEZyb20gQlQuMjEyNC0wIEFubmV4IDIgQ29udmVyc2lvbiAzXG5cdGxldCBMTVMgPSBQUUxNUy5tYXAgKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRsZXQgbnVtICA9IE1hdGgubWF4KCh2YWwgKiogaW0yKSAtIGMxJDEsIDApO1xuXHRcdGxldCBkZW5vbSA9IChjMiQxIC0gKGMzJDEgKiAodmFsICoqIGltMikpKTtcblx0XHRyZXR1cm4gMTAwMDAgKiAoKG51bSAvIGRlbm9tKSAqKiBpbTEpO1xuXHR9KTtcblxuXHRyZXR1cm4gTE1TO1xufVxuXG4vLyBEZWx0YSBFIGluIElDdENwIHNwYWNlLFxuLy8gd2hpY2ggdGhlIElUVSBjYWxscyBEZWx0YSBFIElUUCwgd2hpY2ggaXMgc2hvcnRlclxuLy8gZm9ybXVsYWUgZnJvbSBJVFUgUmVjLiBJVFUtUiBCVC4yMTI0LTBcblxuZnVuY3Rpb24gZGVsdGFFSVRQIChjb2xvciwgc2FtcGxlKSB7XG5cdC8vIEdpdmVuIHRoaXMgY29sb3IgYXMgdGhlIHJlZmVyZW5jZVxuXHQvLyBhbmQgYSBzYW1wbGUsXG5cdC8vIGNhbGN1bGF0ZSBkZWx0YUUgaW4gSUN0Q3Bcblx0Ly8gd2hpY2ggaXMgc2ltcGx5IHRoZSBFdWNsaWRlYW4gZGlzdGFuY2VcblxuXHRsZXQgWyBJMSwgVDEsIFAxIF0gPSBpY3RjcC5mcm9tKGNvbG9yKTtcblx0bGV0IFsgSTIsIFQyLCBQMiBdID0gaWN0Y3AuZnJvbShzYW1wbGUpO1xuXG5cdC8vIHRoZSAwLjI1IGZhY3RvciBpcyB0byB1bmRvIHRoZSBlbmNvZGluZyBzY2FsaW5nIGluIEN0XG5cdC8vIHRoZSA3MjAgaXMgc28gdGhhdCAxIGRlbHRhRSA9IDEgSk5EXG5cdC8vIHBlciAgSVRVLVIgQlQuMjEyNC0wIHAuM1xuXG5cdHJldHVybiA3MjAgKiBNYXRoLnNxcnQoKEkxIC0gSTIpICoqIDIgKyAoMC4yNSAqIChUMSAtVDIpICoqIDIpICsgKFAxIC0gUDIpICoqIDIpO1xufVxuXG4vLyBSZWNhbGN1bGF0ZWQgZm9yIGNvbnNpc3RlbnQgcmVmZXJlbmNlIHdoaXRlXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3czYy9jc3N3Zy1kcmFmdHMvaXNzdWVzLzY2NDIjaXNzdWVjb21tZW50LTk0MzUyMTQ4NFxuY29uc3QgWFladG9MTVNfTSA9IFtcblx0WyAwLjgxOTAyMjQ0MzIxNjQzMTksICAgIDAuMzYxOTA2MjU2MjgwMTIyMSwgICAtMC4xMjg4NzM3ODI2MTIxNjQxNCBdLFxuXHRbIDAuMDMyOTgzNjY3MTk4MDI3MSwgICAgMC45MjkyODY4NDY4OTY1NTQ2LCAgICAgMC4wMzYxNDQ2NjgxNjk5OTg0NCBdLFxuXHRbIDAuMDQ4MTc3MTk5NTY2MDQ2MjU1LCAgMC4yNjQyMzk1MjQ5NDQyMjc2NCwgICAgMC42MzM1NDc4MjU4MTM2OTM3ICBdXG5dO1xuLy8gaW52ZXJzZSBvZiBYWVp0b0xNU19NXG5jb25zdCBMTVN0b1hZWl9NID0gW1xuXHRbICAxLjIyNjg3OTg3MzM3NDE1NTcsICAtMC41NTc4MTQ5OTY1NTU0ODEzLCAgIDAuMjgxMzkxMDUwMTc3MjE1ODNdLFxuXHRbIC0wLjA0MDU3NTc2MjYyNDMxMzcyLCAgMS4xMTIyODY4MjkzOTcwNTk0LCAgLTAuMDcxNzExMDY2NjYxNTE3MDFdLFxuXHRbIC0wLjA3NjM3Mjk0OTc0NjcyMTQyLCAtMC40MjE0OTMzMjM5NjI3OTE0LCAgIDEuNTg2OTI0MDI0NDI3MjQxOCBdXG5dO1xuY29uc3QgTE1TdG9MYWJfTSA9IFtcblx0WyAgMC4yMTA0NTQyNTUzLCAgIDAuNzkzNjE3Nzg1MCwgIC0wLjAwNDA3MjA0NjggXSxcblx0WyAgMS45Nzc5OTg0OTUxLCAgLTIuNDI4NTkyMjA1MCwgICAwLjQ1MDU5MzcwOTkgXSxcblx0WyAgMC4wMjU5MDQwMzcxLCAgIDAuNzgyNzcxNzY2MiwgIC0wLjgwODY3NTc2NjAgXVxuXTtcbi8vIExNU3RvSWFiX00gaW52ZXJ0ZWRcbmNvbnN0IExhYnRvTE1TX00gPSBbXG5cdFsgMC45OTk5OTk5OTg0NTA1MTk4MTQzMiwgIDAuMzk2MzM3NzkyMTczNzY3ODU2NzgsICAgMC4yMTU4MDM3NTgwNjA3NTg4MDMzOSAgXSxcblx0WyAxLjAwMDAwMDAwODg4MTc2MDc3NjcsICAtMC4xMDU1NjEzNDIzMjM2NTYzNDk0LCAgIC0wLjA2Mzg1NDE3NDc3MTcwNTkwMzQwMiBdLFxuXHRbIDEuMDAwMDAwMDU0NjcyNDEwOTE3NywgIC0wLjA4OTQ4NDE4MjA5NDk2NTc1OTY4NCwgLTEuMjkxNDg1NTM3ODY0MDkxNzM5OSAgIF1cbl07XG5cbnZhciBPS0xhYiA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwib2tsYWJcIixcbiAgICBuYW1lOiBcIk9rbGFiXCIsXG4gICAgY29vcmRzOiB7XG5cdFx0bDoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAxXSxcblx0XHRcdG5hbWU6IFwiTFwiXG5cdFx0fSxcblx0XHRhOiB7XG5cdFx0XHRyZWZSYW5nZTogWy0wLjQsIDAuNF1cblx0XHR9LFxuXHRcdGI6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTAuNCwgMC40XVxuXHRcdH1cbiAgICB9LFxuXG5cdC8vIE5vdGUgdGhhdCBYWVogaXMgcmVsYXRpdmUgdG8gRDY1XG4gIHdoaXRlOiBcIkQ2NVwiLFxuXHRiYXNlOiBYWVpfRDY1LFxuXHRmcm9tQmFzZSAoWFlaKSB7XG5cdFx0Ly8gbW92ZSB0byBMTVMgY29uZSBkb21haW5cblx0XHRsZXQgTE1TID0gbXVsdGlwbHlNYXRyaWNlcyhYWVp0b0xNU19NLCBYWVopO1xuXG5cdFx0Ly8gbm9uLWxpbmVhcml0eVxuXHRcdGxldCBMTVNnID0gTE1TLm1hcCh2YWwgPT4gTWF0aC5jYnJ0KHZhbCkpO1xuXG5cdFx0cmV0dXJuIG11bHRpcGx5TWF0cmljZXMoTE1TdG9MYWJfTSwgTE1TZyk7XG5cblx0fSxcblx0dG9CYXNlIChPS0xhYikge1xuXHRcdC8vIG1vdmUgdG8gTE1TIGNvbmUgZG9tYWluXG5cdFx0bGV0IExNU2cgPSBtdWx0aXBseU1hdHJpY2VzKExhYnRvTE1TX00sIE9LTGFiKTtcblxuXHRcdC8vIHJlc3RvcmUgbGluZWFyaXR5XG5cdFx0bGV0IExNUyA9IExNU2cubWFwKHZhbCA9PiB2YWwgKiogMyk7XG5cblx0XHRyZXR1cm4gbXVsdGlwbHlNYXRyaWNlcyhMTVN0b1hZWl9NLCBMTVMpO1xuXHR9LFxuXG5cdGZvcm1hdHM6IHtcblx0XHRcIm9rbGFiXCI6IHtcblx0XHRcdGNvb3JkczogW1wiPHBlcmNlbnRhZ2U+IHwgPG51bWJlcj5cIiwgXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlstMSwxXVwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+Wy0xLDFdXCJdLFxuXHRcdH1cblx0fVxufSk7XG5cbi8vIE1vcmUgYWNjdXJhdGUgY29sb3ItZGlmZmVyZW5jZSBmb3JtdWxhZVxuLy8gdGhhbiB0aGUgc2ltcGxlIDE5NzYgRXVjbGlkZWFuIGRpc3RhbmNlIGluIENJRSBMYWJcblxuXG5mdW5jdGlvbiBkZWx0YUVPSyAoY29sb3IsIHNhbXBsZSkge1xuXHQvLyBHaXZlbiB0aGlzIGNvbG9yIGFzIHRoZSByZWZlcmVuY2Vcblx0Ly8gYW5kIGEgc2FtcGxlLFxuXHQvLyBjYWxjdWxhdGUgZGVsdGFFT0ssIHRlcm0gYnkgdGVybSBhcyByb290IHN1bSBvZiBzcXVhcmVzXG5cdGxldCBbTDEsIGExLCBiMV0gPSBPS0xhYi5mcm9tKGNvbG9yKTtcblx0bGV0IFtMMiwgYTIsIGIyXSA9IE9LTGFiLmZyb20oc2FtcGxlKTtcblx0bGV0IM6UTCA9IEwxIC0gTDI7XG5cdGxldCDOlGEgPSBhMSAtIGEyO1xuXHRsZXQgzpRiID0gYjEgLSBiMjtcblx0cmV0dXJuIE1hdGguc3FydCjOlEwgKiogMiArIM6UYSAqKiAyICsgzpRiICoqIDIpO1xufVxuXG52YXIgZGVsdGFFTWV0aG9kcyA9IHtcblx0ZGVsdGFFNzYsXG5cdGRlbHRhRUNNQyxcblx0ZGVsdGFFMjAwMCxcblx0ZGVsdGFFSnosXG5cdGRlbHRhRUlUUCxcblx0ZGVsdGFFT0ssXG59O1xuXG5mdW5jdGlvbiBkZWx0YUUgKGMxLCBjMiwgbyA9IHt9KSB7XG5cdGlmIChpc1N0cmluZyhvKSkge1xuXHRcdG8gPSB7bWV0aG9kOiBvfTtcblx0fVxuXG5cdGxldCB7bWV0aG9kID0gZGVmYXVsdHMuZGVsdGFFLCAuLi5yZXN0fSA9IG87XG5cblx0YzEgPSBnZXRDb2xvcihjMSk7XG5cdGMyID0gZ2V0Q29sb3IoYzIpO1xuXG5cdGZvciAobGV0IG0gaW4gZGVsdGFFTWV0aG9kcykge1xuXHRcdGlmIChcImRlbHRhZVwiICsgbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IG0udG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0cmV0dXJuIGRlbHRhRU1ldGhvZHNbbV0oYzEsIGMyLCByZXN0KTtcblx0XHR9XG5cdH1cblxuXHR0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGRlbHRhRSBtZXRob2Q6ICR7bWV0aG9kfWApO1xufVxuXG5mdW5jdGlvbiBsaWdodGVuIChjb2xvciwgYW1vdW50ID0gLjI1KSB7XG5cdGxldCBzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KFwib2tsY2hcIiwgXCJsY2hcIik7XG5cdGxldCBsaWdodG5lc3MgPSBbc3BhY2UsIFwibFwiXTtcblx0cmV0dXJuIHNldChjb2xvciwgbGlnaHRuZXNzLCBsID0+IGwgKiAoMSArIGFtb3VudCkpO1xufVxuXG5mdW5jdGlvbiBkYXJrZW4gKGNvbG9yLCBhbW91bnQgPSAuMjUpIHtcblx0bGV0IHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoXCJva2xjaFwiLCBcImxjaFwiKTtcblx0bGV0IGxpZ2h0bmVzcyA9IFtzcGFjZSwgXCJsXCJdO1xuXHRyZXR1cm4gc2V0KGNvbG9yLCBsaWdodG5lc3MsIGwgPT4gbCAqICgxIC0gYW1vdW50KSk7XG59XG5cbnZhciB2YXJpYXRpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGRhcmtlbjogZGFya2VuLFxuXHRsaWdodGVuOiBsaWdodGVuXG59KTtcblxuLyoqXG4gKiBGdW5jdGlvbnMgcmVsYXRlZCB0byBjb2xvciBpbnRlcnBvbGF0aW9uXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gYW4gaW50ZXJtZWRpYXRlIGNvbG9yIGJldHdlZW4gdHdvIGNvbG9yc1xuICogU2lnbmF0dXJlczogbWl4KGMxLCBjMiwgcCwgb3B0aW9ucylcbiAqICAgICAgICAgICAgIG1peChjMSwgYzIsIG9wdGlvbnMpXG4gKiAgICAgICAgICAgICBtaXgoY29sb3IpXG4gKiBAcGFyYW0ge0NvbG9yIHwgc3RyaW5nfSBjMSBUaGUgZmlyc3QgY29sb3JcbiAqIEBwYXJhbSB7Q29sb3IgfCBzdHJpbmd9IFtjMl0gVGhlIHNlY29uZCBjb2xvclxuICogQHBhcmFtIHtudW1iZXJ9IFtwPS41XSBBIDAtMSBwZXJjZW50YWdlIHdoZXJlIDAgaXMgYzEgYW5kIDEgaXMgYzJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbbz17fV1cbiAqIEByZXR1cm4ge0NvbG9yfVxuICovXG5mdW5jdGlvbiBtaXggKGMxLCBjMiwgcCA9IC41LCBvID0ge30pIHtcblx0W2MxLCBjMl0gPSBbZ2V0Q29sb3IoYzEpLCBnZXRDb2xvcihjMildO1xuXG5cdGlmICh0eXBlKHApID09PSBcIm9iamVjdFwiKSB7XG5cdFx0W3AsIG9dID0gWy41LCBwXTtcblx0fVxuXG5cdGxldCB7c3BhY2UsIG91dHB1dFNwYWNlLCBwcmVtdWx0aXBsaWVkfSA9IG87XG5cblx0bGV0IHIgPSByYW5nZShjMSwgYzIsIHtzcGFjZSwgb3V0cHV0U3BhY2UsIHByZW11bHRpcGxpZWR9KTtcblx0cmV0dXJuIHIocCk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Q29sb3IgfCBzdHJpbmcgfCBGdW5jdGlvbn0gYzEgVGhlIGZpcnN0IGNvbG9yIG9yIGEgcmFuZ2VcbiAqIEBwYXJhbSB7Q29sb3IgfCBzdHJpbmd9IFtjMl0gVGhlIHNlY29uZCBjb2xvciBpZiBjMSBpcyBub3QgYSByYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogQHJldHVybiB7Q29sb3JbXX1cbiAqL1xuZnVuY3Rpb24gc3RlcHMgKGMxLCBjMiwgb3B0aW9ucyA9IHt9KSB7XG5cdGxldCBjb2xvclJhbmdlO1xuXG5cdGlmIChpc1JhbmdlKGMxKSkge1xuXHRcdC8vIFR3ZWFraW5nIGV4aXN0aW5nIHJhbmdlXG5cdFx0W2NvbG9yUmFuZ2UsIG9wdGlvbnNdID0gW2MxLCBjMl07XG5cdFx0W2MxLCBjMl0gPSBjb2xvclJhbmdlLnJhbmdlQXJncy5jb2xvcnM7XG5cdH1cblxuXHRsZXQge1xuXHRcdG1heERlbHRhRSwgZGVsdGFFTWV0aG9kLFxuXHRcdHN0ZXBzID0gMiwgbWF4U3RlcHMgPSAxMDAwLFxuXHRcdC4uLnJhbmdlT3B0aW9uc1xuXHR9ID0gb3B0aW9ucztcblxuXHRpZiAoIWNvbG9yUmFuZ2UpIHtcblx0XHRbYzEsIGMyXSA9IFtnZXRDb2xvcihjMSksIGdldENvbG9yKGMyKV07XG5cdFx0Y29sb3JSYW5nZSA9IHJhbmdlKGMxLCBjMiwgcmFuZ2VPcHRpb25zKTtcblx0fVxuXG5cdGxldCB0b3RhbERlbHRhID0gZGVsdGFFKGMxLCBjMik7XG5cdGxldCBhY3R1YWxTdGVwcyA9IG1heERlbHRhRSA+IDA/IE1hdGgubWF4KHN0ZXBzLCBNYXRoLmNlaWwodG90YWxEZWx0YSAvIG1heERlbHRhRSkgKyAxKSA6IHN0ZXBzO1xuXHRsZXQgcmV0ID0gW107XG5cblx0aWYgKG1heFN0ZXBzICE9PSB1bmRlZmluZWQpIHtcblx0XHRhY3R1YWxTdGVwcyA9IE1hdGgubWluKGFjdHVhbFN0ZXBzLCBtYXhTdGVwcyk7XG5cdH1cblxuXHRpZiAoYWN0dWFsU3RlcHMgPT09IDEpIHtcblx0XHRyZXQgPSBbe3A6IC41LCBjb2xvcjogY29sb3JSYW5nZSguNSl9XTtcblx0fVxuXHRlbHNlIHtcblx0XHRsZXQgc3RlcCA9IDEgLyAoYWN0dWFsU3RlcHMgLSAxKTtcblx0XHRyZXQgPSBBcnJheS5mcm9tKHtsZW5ndGg6IGFjdHVhbFN0ZXBzfSwgKF8sIGkpID0+IHtcblx0XHRcdGxldCBwID0gaSAqIHN0ZXA7XG5cdFx0XHRyZXR1cm4ge3AsIGNvbG9yOiBjb2xvclJhbmdlKHApfTtcblx0XHR9KTtcblx0fVxuXG5cdGlmIChtYXhEZWx0YUUgPiAwKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBzdG9wcyBhbmQgZmluZCBtYXggZGVsdGFFXG5cdFx0bGV0IG1heERlbHRhID0gcmV0LnJlZHVjZSgoYWNjLCBjdXIsIGkpID0+IHtcblx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgzpTOlSA9IGRlbHRhRShjdXIuY29sb3IsIHJldFtpIC0gMV0uY29sb3IsIGRlbHRhRU1ldGhvZCk7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoYWNjLCDOlM6VKTtcblx0XHR9LCAwKTtcblxuXHRcdHdoaWxlIChtYXhEZWx0YSA+IG1heERlbHRhRSkge1xuXHRcdFx0Ly8gSW5zZXJ0IGludGVybWVkaWF0ZSBzdG9wcyBhbmQgbWVhc3VyZSBtYXhEZWx0YSBhZ2FpblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkbyB0aGlzIGZvciBhbGwgcGFpcnMsIG90aGVyd2lzZSB0aGUgbWlkcG9pbnQgc2hpZnRzXG5cdFx0XHRtYXhEZWx0YSA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAxOyAoaSA8IHJldC5sZW5ndGgpICYmIChyZXQubGVuZ3RoIDwgbWF4U3RlcHMpOyBpKyspIHtcblx0XHRcdFx0bGV0IHByZXYgPSByZXRbaSAtIDFdO1xuXHRcdFx0XHRsZXQgY3VyID0gcmV0W2ldO1xuXG5cdFx0XHRcdGxldCBwID0gKGN1ci5wICsgcHJldi5wKSAvIDI7XG5cdFx0XHRcdGxldCBjb2xvciA9IGNvbG9yUmFuZ2UocCk7XG5cdFx0XHRcdG1heERlbHRhID0gTWF0aC5tYXgobWF4RGVsdGEsIGRlbHRhRShjb2xvciwgcHJldi5jb2xvciksIGRlbHRhRShjb2xvciwgY3VyLmNvbG9yKSk7XG5cdFx0XHRcdHJldC5zcGxpY2UoaSwgMCwge3AsIGNvbG9yOiBjb2xvclJhbmdlKHApfSk7XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXQgPSByZXQubWFwKGEgPT4gYS5jb2xvcik7XG5cblx0cmV0dXJuIHJldDtcbn1cbi8qKlxuICogSW50ZXJwb2xhdGUgdG8gY29sb3IyIGFuZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgMC0xIHBlcmNlbnRhZ2VcbiAqIEBwYXJhbSB7Q29sb3IgfCBzdHJpbmcgfCBGdW5jdGlvbn0gY29sb3IxIFRoZSBmaXJzdCBjb2xvciBvciBhbiBleGlzdGluZyByYW5nZVxuICogQHBhcmFtIHtDb2xvciB8IHN0cmluZ30gW2NvbG9yMl0gSWYgY29sb3IxIGlzIGEgY29sb3IsIHRoaXMgaXMgdGhlIHNlY29uZCBjb2xvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSAwLTEgcGVyY2VudGFnZSBhbmQgcmV0dXJucyBhIGNvbG9yXG4gKi9cbmZ1bmN0aW9uIHJhbmdlIChjb2xvcjEsIGNvbG9yMiwgb3B0aW9ucyA9IHt9KSB7XG5cdGlmIChpc1JhbmdlKGNvbG9yMSkpIHtcblx0XHQvLyBUd2Vha2luZyBleGlzdGluZyByYW5nZVxuXHRcdGxldCBbciwgb3B0aW9uc10gPSBbY29sb3IxLCBjb2xvcjJdO1xuXG5cdFx0cmV0dXJuIHJhbmdlKC4uLnIucmFuZ2VBcmdzLmNvbG9ycywgey4uLnIucmFuZ2VBcmdzLm9wdGlvbnMsIC4uLm9wdGlvbnN9KTtcblx0fVxuXG5cdGxldCB7c3BhY2UsIG91dHB1dFNwYWNlLCBwcm9ncmVzc2lvbiwgcHJlbXVsdGlwbGllZH0gPSBvcHRpb25zO1xuXG5cdGNvbG9yMSA9IGdldENvbG9yKGNvbG9yMSk7XG5cdGNvbG9yMiA9IGdldENvbG9yKGNvbG9yMik7XG5cblx0Ly8gTWFrZSBzdXJlIHdlJ3JlIHdvcmtpbmcgb24gY29waWVzIG9mIHRoZXNlIGNvbG9yc1xuXHRjb2xvcjEgPSBjbG9uZShjb2xvcjEpO1xuXHRjb2xvcjIgPSBjbG9uZShjb2xvcjIpO1xuXG5cdGxldCByYW5nZUFyZ3MgPSB7Y29sb3JzOiBbY29sb3IxLCBjb2xvcjJdLCBvcHRpb25zfTtcblxuXHRpZiAoc3BhY2UpIHtcblx0XHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblx0fVxuXHRlbHNlIHtcblx0XHRzcGFjZSA9IENvbG9yU3BhY2UucmVnaXN0cnlbZGVmYXVsdHMuaW50ZXJwb2xhdGlvblNwYWNlXSB8fCBjb2xvcjEuc3BhY2U7XG5cdH1cblxuXHRvdXRwdXRTcGFjZSA9IG91dHB1dFNwYWNlPyBDb2xvclNwYWNlLmdldChvdXRwdXRTcGFjZSkgOiBzcGFjZTtcblxuXHRjb2xvcjEgPSB0byhjb2xvcjEsIHNwYWNlKTtcblx0Y29sb3IyID0gdG8oY29sb3IyLCBzcGFjZSk7XG5cblx0Ly8gR2FtdXQgbWFwIHRvIGF2b2lkIGFyZWFzIG9mIGZsYXQgY29sb3Jcblx0Y29sb3IxID0gdG9HYW11dChjb2xvcjEpO1xuXHRjb2xvcjIgPSB0b0dhbXV0KGNvbG9yMik7XG5cblx0Ly8gSGFuZGxlIGh1ZSBpbnRlcnBvbGF0aW9uXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdzNjL2Nzc3dnLWRyYWZ0cy9pc3N1ZXMvNDczNSNpc3N1ZWNvbW1lbnQtNjM1NzQxODQwXG5cdGlmIChzcGFjZS5jb29yZHMuaCAmJiBzcGFjZS5jb29yZHMuaC50eXBlID09PSBcImFuZ2xlXCIpIHtcblx0XHRsZXQgYXJjID0gb3B0aW9ucy5odWUgPSBvcHRpb25zLmh1ZSB8fCBcInNob3J0ZXJcIjtcblxuXHRcdGxldCBodWUgPSBbc3BhY2UsIFwiaFwiXTtcblx0XHRsZXQgW864MSwgzrgyXSA9IFtnZXQoY29sb3IxLCBodWUpLCBnZXQoY29sb3IyLCBodWUpXTtcblx0XHRbzrgxLCDOuDJdID0gYWRqdXN0KGFyYywgW864MSwgzrgyXSk7XG5cdFx0c2V0KGNvbG9yMSwgaHVlLCDOuDEpO1xuXHRcdHNldChjb2xvcjIsIGh1ZSwgzrgyKTtcblx0fVxuXG5cdGlmIChwcmVtdWx0aXBsaWVkKSB7XG5cdFx0Ly8gbm90IGNvcGluZyB3aXRoIHBvbGFyIHNwYWNlcyB5ZXRcblx0XHRjb2xvcjEuY29vcmRzID0gY29sb3IxLmNvb3Jkcy5tYXAoYyA9PiBjICogY29sb3IxLmFscGhhKTtcblx0XHRjb2xvcjIuY29vcmRzID0gY29sb3IyLmNvb3Jkcy5tYXAoYyA9PiBjICogY29sb3IyLmFscGhhKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QuYXNzaWduKHAgPT4ge1xuXHRcdHAgPSBwcm9ncmVzc2lvbj8gcHJvZ3Jlc3Npb24ocCkgOiBwO1xuXHRcdGxldCBjb29yZHMgPSBjb2xvcjEuY29vcmRzLm1hcCgoc3RhcnQsIGkpID0+IHtcblx0XHRcdGxldCBlbmQgPSBjb2xvcjIuY29vcmRzW2ldO1xuXHRcdFx0cmV0dXJuIGludGVycG9sYXRlKHN0YXJ0LCBlbmQsIHApO1xuXHRcdH0pO1xuXG5cdFx0bGV0IGFscGhhID0gaW50ZXJwb2xhdGUoY29sb3IxLmFscGhhLCBjb2xvcjIuYWxwaGEsIHApO1xuXHRcdGxldCByZXQgPSB7c3BhY2UsIGNvb3JkcywgYWxwaGF9O1xuXG5cdFx0aWYgKHByZW11bHRpcGxpZWQpIHtcblx0XHRcdC8vIHVuZG8gcHJlbXVsdGlwbGljYXRpb25cblx0XHRcdHJldC5jb29yZHMgPSByZXQuY29vcmRzLm1hcChjID0+IGMgLyBhbHBoYSk7XG5cdFx0fVxuXG5cdFx0aWYgKG91dHB1dFNwYWNlICE9PSBzcGFjZSkge1xuXHRcdFx0cmV0ID0gdG8ocmV0LCBvdXRwdXRTcGFjZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSwge1xuXHRcdHJhbmdlQXJnc1xuXHR9KTtcbn1cbmZ1bmN0aW9uIGlzUmFuZ2UgKHZhbCkge1xuXHRyZXR1cm4gdHlwZSh2YWwpID09PSBcImZ1bmN0aW9uXCIgJiYgISF2YWwucmFuZ2VBcmdzO1xufVxuZGVmYXVsdHMuaW50ZXJwb2xhdGlvblNwYWNlID0gXCJsYWJcIjtcblxuZnVuY3Rpb24gcmVnaXN0ZXIgKENvbG9yKSB7XG5cdENvbG9yLmRlZmluZUZ1bmN0aW9uKFwibWl4XCIsIG1peCwge3JldHVybnM6IFwiY29sb3JcIn0pO1xuXHRDb2xvci5kZWZpbmVGdW5jdGlvbihcInJhbmdlXCIsIHJhbmdlLCB7cmV0dXJuczogXCJmdW5jdGlvbjxjb2xvcj5cIn0pO1xuXHRDb2xvci5kZWZpbmVGdW5jdGlvbihcInN0ZXBzXCIsIHN0ZXBzLCB7cmV0dXJuczogXCJhcnJheTxjb2xvcj5cIn0pO1xufVxuXG52YXIgaW50ZXJwb2xhdGlvbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRpc1JhbmdlOiBpc1JhbmdlLFxuXHRtaXg6IG1peCxcblx0cmFuZ2U6IHJhbmdlLFxuXHRyZWdpc3RlcjogcmVnaXN0ZXIsXG5cdHN0ZXBzOiBzdGVwc1xufSk7XG5cbnZhciBIU0wgPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcImhzbFwiLFxuXHRuYW1lOiBcIkhTTFwiLFxuXHRjb29yZHM6IHtcblx0XHRoOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDM2MF0sXG5cdFx0XHR0eXBlOiBcImFuZ2xlXCIsXG5cdFx0XHRuYW1lOiBcIkh1ZVwiXG5cdFx0fSxcblx0XHRzOiB7XG5cdFx0XHRyYW5nZTogWzAsIDEwMF0sXG5cdFx0XHRuYW1lOiBcIlNhdHVyYXRpb25cIlxuXHRcdH0sXG5cdFx0bDoge1xuXHRcdFx0cmFuZ2U6IFswLCAxMDBdLFxuXHRcdFx0bmFtZTogXCJMaWdodG5lc3NcIlxuXHRcdH1cblx0fSxcblxuXHRiYXNlOiBzUkdCLFxuXG5cdC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTViNGcm9tX1JHQlxuXHRmcm9tQmFzZTogcmdiID0+IHtcblx0XHRsZXQgbWF4ID0gTWF0aC5tYXgoLi4ucmdiKTtcblx0XHRsZXQgbWluID0gTWF0aC5taW4oLi4ucmdiKTtcblx0XHRsZXQgW3IsIGcsIGJdID0gcmdiO1xuXHRcdGxldCBbaCwgcywgbF0gPSBbTmFOLCAwLCAobWluICsgbWF4KS8yXTtcblx0XHRsZXQgZCA9IG1heCAtIG1pbjtcblxuXHRcdGlmIChkICE9PSAwKSB7XG5cdFx0XHRzID0gKGwgPT09IDAgfHwgbCA9PT0gMSkgPyAwIDogKG1heCAtIGwpIC8gTWF0aC5taW4obCwgMSAtIGwpO1xuXG5cdFx0XHRzd2l0Y2ggKG1heCkge1xuXHRcdFx0XHRjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDtcblx0XHRcdH1cblxuXHRcdFx0aCA9IGggKiA2MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xuXHR9LFxuXG5cdC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTViNIU0xfdG9fUkdCX2FsdGVybmF0aXZlXG5cdHRvQmFzZTogaHNsID0+IHtcblx0XHRsZXQgW2gsIHMsIGxdID0gaHNsO1xuXHRcdGggPSBoICUgMzYwO1xuXG5cdFx0aWYgKGggPCAwKSB7XG5cdFx0XHRoICs9IDM2MDtcblx0XHR9XG5cblx0XHRzIC89IDEwMDtcblx0XHRsIC89IDEwMDtcblxuXHRcdGZ1bmN0aW9uIGYgKG4pIHtcblx0XHRcdGxldCBrID0gKG4gKyBoLzMwKSAlIDEyO1xuXHRcdFx0bGV0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuXHRcdFx0cmV0dXJuIGwgLSBhICogTWF0aC5tYXgoLTEsIE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG5cdH0sXG5cblx0Zm9ybWF0czoge1xuXHRcdFwiaHNsXCI6IHtcblx0XHRcdHRvR2FtdXQ6IHRydWUsXG5cdFx0XHRjb29yZHM6IFtcIjxudW1iZXI+IHwgPGFuZ2xlPlwiLCBcIjxwZXJjZW50YWdlPlwiLCBcIjxwZXJjZW50YWdlPlwiXSxcblx0XHR9LFxuXHRcdFwiaHNsYVwiOiB7XG5cdFx0XHRjb29yZHM6IFtcIjxudW1iZXI+IHwgPGFuZ2xlPlwiLCBcIjxwZXJjZW50YWdlPlwiLCBcIjxwZXJjZW50YWdlPlwiXSxcblx0XHRcdGNvbW1hczogdHJ1ZSxcblx0XHRcdGxhc3RBbHBoYTogdHJ1ZSxcblx0XHR9XG5cdH0sXG59KTtcblxuLy8gVGhlIEh1ZSwgV2hpdGVuZXNzIEJsYWNrbmVzcyAoSFdCKSBjb2xvcnNwYWNlXG4vLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci00LyN0aGUtaHdiLW5vdGF0aW9uXG4vLyBOb3RlIHRoYXQsIGxpa2UgSFNMLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgZGlyZWN0bHkgb25cbi8vIGdhbW1hLWNvcnJlY3RlZCBzUkdCIHZhbHVlcyByYXRoZXIgdGhhbiBsaW5lYXJpc2luZyB0aGVtIGZpcnN0LlxuXG52YXIgSFNWID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJoc3ZcIixcblx0bmFtZTogXCJIU1ZcIixcblx0Y29vcmRzOiB7XG5cdFx0aDoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAzNjBdLFxuXHRcdFx0dHlwZTogXCJhbmdsZVwiLFxuXHRcdFx0bmFtZTogXCJIdWVcIlxuXHRcdH0sXG5cdFx0czoge1xuXHRcdFx0cmFuZ2U6IFswLCAxMDBdLFxuXHRcdFx0bmFtZTogXCJTYXR1cmF0aW9uXCJcblx0XHR9LFxuXHRcdHY6IHtcblx0XHRcdHJhbmdlOiBbMCwgMTAwXSxcblx0XHRcdG5hbWU6IFwiVmFsdWVcIlxuXHRcdH1cblx0fSxcblxuXHRiYXNlOiBIU0wsXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWI0ludGVyY29udmVyc2lvblxuXHRmcm9tQmFzZSAoaHNsKSB7XG5cdFx0bGV0IFtoLCBzLCBsXSA9IGhzbDtcblx0XHRzIC89IDEwMDtcblx0XHRsIC89IDEwMDtcblxuXHRcdGxldCB2ID0gbCArIHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0aCwgLy8gaCBpcyB0aGUgc2FtZVxuXHRcdFx0diA9PT0gMD8gMCA6IDIwMCAqICgxIC0gbCAvIHYpLCAvLyBzXG5cdFx0XHQxMDAgKiB2XG5cdFx0XTtcblx0fSxcblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1YjSW50ZXJjb252ZXJzaW9uXG5cdHRvQmFzZSAoaHN2KSB7XG5cdFx0bGV0IFtoLCBzLCB2XSA9IGhzdjtcblxuXHRcdHMgLz0gMTAwO1xuXHRcdHYgLz0gMTAwO1xuXG5cdFx0bGV0IGwgPSB2ICogKDEgLSBzLzIpO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdGgsIC8vIGggaXMgdGhlIHNhbWVcblx0XHRcdChsID09PSAwIHx8IGwgPT09IDEpPyAwIDogKCh2IC0gbCkgLyBNYXRoLm1pbihsLCAxIC0gbCkpICogMTAwLFxuXHRcdFx0bCAqIDEwMFxuXHRcdF07XG5cdH0sXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge1xuXHRcdFx0dG9HYW11dDogdHJ1ZSxcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBUaGUgSHVlLCBXaGl0ZW5lc3MgQmxhY2tuZXNzIChIV0IpIGNvbG9yc3BhY2Vcbi8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLTQvI3RoZS1od2Itbm90YXRpb25cbi8vIE5vdGUgdGhhdCwgbGlrZSBIU0wsIGNhbGN1bGF0aW9ucyBhcmUgZG9uZSBkaXJlY3RseSBvblxuLy8gZ2FtbWEtY29ycmVjdGVkIHNSR0IgdmFsdWVzIHJhdGhlciB0aGFuIGxpbmVhcmlzaW5nIHRoZW0gZmlyc3QuXG5cbnZhciBod2IgPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcImh3YlwiLFxuXHRuYW1lOiBcIkhXQlwiLFxuXHRjb29yZHM6IHtcblx0XHRoOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDM2MF0sXG5cdFx0XHR0eXBlOiBcImFuZ2xlXCIsXG5cdFx0XHRuYW1lOiBcIkh1ZVwiXG5cdFx0fSxcblx0XHR3OiB7XG5cdFx0XHRyYW5nZTogWzAsIDEwMF0sXG5cdFx0XHRuYW1lOiBcIldoaXRlbmVzc1wiXG5cdFx0fSxcblx0XHRiOiB7XG5cdFx0XHRyYW5nZTogWzAsIDEwMF0sXG5cdFx0XHRuYW1lOiBcIkJsYWNrbmVzc1wiXG5cdFx0fVxuXHR9LFxuXG5cdGJhc2U6IEhTVixcblx0ZnJvbUJhc2UgKGhzdikge1xuXHRcdGxldCBbaCwgcywgdl0gPSBoc3Y7XG5cblx0XHRyZXR1cm4gW2gsIHYgKiAoMTAwIC0gcykgLyAxMDAsIDEwMCAtIHZdO1xuXHR9LFxuXHR0b0Jhc2UgKGh3Yikge1xuXHRcdGxldCBbaCwgdywgYl0gPSBod2I7XG5cblx0XHQvLyBOb3cgY29udmVydCBwZXJjZW50YWdlcyB0byBbMC4uMV1cblx0XHR3IC89IDEwMDtcblx0XHRiIC89IDEwMDtcblxuXHRcdC8vIEFjaHJvbWF0aWMgY2hlY2sgKHdoaXRlIHBsdXMgYmxhY2sgPj0gMSlcblx0XHRsZXQgc3VtID0gdyArIGI7XG5cdFx0aWYgKHN1bSA+PSAxKSB7XG5cdFx0XHQgbGV0IGdyYXkgPSB3IC8gc3VtO1xuXHRcdFx0IHJldHVybiBbaCwgMCwgZ3JheSAqIDEwMF07XG5cdFx0fVxuXG5cdFx0bGV0IHYgPSAoMSAtIGIpO1xuXHRcdGxldCBzID0gKHYgPT09IDApID8gMCA6IDEgLSB3IC8gdjtcblx0XHRyZXR1cm4gW2gsIHMgKiAxMDAsIHYgKiAxMDBdO1xuXHR9LFxuXG5cdGZvcm1hdHM6IHtcblx0XHRcImh3YlwiOiB7XG5cdFx0XHR0b0dhbXV0OiB0cnVlLFxuXHRcdFx0Y29vcmRzOiBbXCI8bnVtYmVyPiB8IDxhbmdsZT5cIiwgXCI8cGVyY2VudGFnZT5cIiwgXCI8cGVyY2VudGFnZT5cIl0sXG5cdFx0fVxuXHR9XG59KTtcblxuLy8gY29udmVydCBhbiBhcnJheSBvZiBsaW5lYXItbGlnaHQgYTk4LXJnYiB2YWx1ZXMgdG8gQ0lFIFhZWlxuLy8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuLy8gaGFzIGdyZWF0ZXIgbnVtZXJpY2FsIHByZWNpc2lvbiB0aGFuIHNlY3Rpb24gNC4zLjUuMyBvZlxuLy8gaHR0cHM6Ly93d3cuYWRvYmUuY29tL2RpZ2l0YWxpbWFnL3BkZnMvQWRvYmVSR0IxOTk4LnBkZlxuLy8gYnV0IHRoZSB2YWx1ZXMgYmVsb3cgd2VyZSBjYWxjdWxhdGVkIGZyb20gZmlyc3QgcHJpbmNpcGxlc1xuLy8gZnJvbSB0aGUgY2hyb21hdGljaXR5IGNvb3JkaW5hdGVzIG9mIFIgRyBCIFdcbmNvbnN0IHRvWFlaX00kMiA9IFtcblx0WyAwLjU3NjY2OTA0MjkxMDEzMDUsICAgMC4xODU1NTgyMzc5MDY1NDYzLCAgIDAuMTg4MjI4NjQ2MjM0OTk0NyAgXSxcblx0WyAwLjI5NzM0NDk3NTI1MDUzNjA1LCAgMC42MjczNjM1NjYyNTU0NjYxLCAgIDAuMDc1MjkxNDU4NDkzOTk3ODggXSxcblx0WyAwLjAyNzAzMTM2MTM4NjQxMjM0LCAgMC4wNzA2ODg4NTI1MzU4MjcyMywgIDAuOTkxMzM3NTM2ODM3NjM4OCAgXVxuXTtcblxuY29uc3QgZnJvbVhZWl9NJDIgPSBbXG5cdFsgIDIuMDQxNTg3OTAzODEwNzQ2NSwgICAgLTAuNTY1MDA2OTc0Mjc4ODU5NiwgICAtMC4zNDQ3MzEzNTA3NzgzMjk1NiBdLFxuXHRbIC0wLjk2OTI0MzYzNjI4MDg3OTUsICAgICAxLjg3NTk2NzUwMTUwNzcyMDIsICAgIDAuMDQxNTU1MDU3NDA3MTc1NTcgXSxcblx0WyAgMC4wMTM0NDQyODA2MzIwMzExNDIsICAtMC4xMTgzNjIzOTIyMzEwMTgzOCwgICAxLjAxNTE3NDk5NDM5MTIwNTQgIF1cbl07XG5cbnZhciBBOThMaW5lYXIgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcImE5OHJnYi1saW5lYXJcIixcblx0bmFtZTogXCJMaW5lYXIgQWRvYmXCriA5OCBSR0IgY29tcGF0aWJsZVwiLFxuXHR3aGl0ZTogXCJENjVcIixcblx0dG9YWVpfTTogdG9YWVpfTSQyLFxuXHRmcm9tWFlaX006IGZyb21YWVpfTSQyXG59KTtcblxudmFyIGE5OHJnYiA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwiYTk4cmdiXCIsXG5cdG5hbWU6IFwiQWRvYmXCriA5OCBSR0IgY29tcGF0aWJsZVwiLFxuXHRiYXNlOiBBOThMaW5lYXIsXG5cdHRvQmFzZTogUkdCID0+IFJHQi5tYXAodmFsID0+IE1hdGgucG93KE1hdGguYWJzKHZhbCksIDU2MyAvIDI1NikgKiBNYXRoLnNpZ24odmFsKSksXG5cdGZyb21CYXNlOiBSR0IgPT4gUkdCLm1hcCh2YWwgPT4gTWF0aC5wb3coTWF0aC5hYnModmFsKSwgMjU2IC8gNTYzKSAqIE1hdGguc2lnbih2YWwpKSxcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7XG5cdFx0XHRpZDogXCJhOTgtcmdiXCJcblx0XHR9XG5cdH0sXG59KTtcblxuLy8gY29udmVydCBhbiBhcnJheSBvZiAgcHJvcGhvdG8tcmdiIHZhbHVlcyB0byBDSUUgWFlaXG4vLyB1c2luZyAgRDUwIChzbyBubyBjaHJvbWF0aWMgYWRhcHRhdGlvbiBuZWVkZWQgYWZ0ZXJ3YXJkcylcbi8vIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX1JHQl9YWVpfTWF0cml4Lmh0bWxcbmNvbnN0IHRvWFlaX00kMSA9IFtcblx0WyAwLjc5Nzc2MDQ4OTY3MjMwMjcsICAwLjEzNTE4NTgzNzE3NTc0MDMxLCAgMC4wMzEzNDkzNDk1ODE1MjQ4ICAgICBdLFxuXHRbIDAuMjg4MDcxMTI4MjI5MjkzNCwgIDAuNzExODQzMjE3ODEwMTAxNCwgICAwLjAwMDA4NTY1Mzk2MDYwNTI1OTAyIF0sXG5cdFsgMC4wLCAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgIDAuODI1MTA0NjAyNTEwNDYwMSAgICAgXVxuXTtcblxuY29uc3QgZnJvbVhZWl9NJDEgPSBbXG5cdFsgIDEuMzQ1Nzk4OTczMTAyODI4MSwgIC0wLjI1NTU4MDEwMDA3OTk3NTM0LCAgLTAuMDUxMTA2Mjg1MDY3NTM0MDEgXSxcblx0WyAtMC41NDQ2MjI0OTM5MDI4MzQ3LCAgIDEuNTA4MjMyNzQxMzEzMjc4MSwgICAgMC4wMjA1MzYwMzIzOTE0Nzk3MyBdLFxuXHRbICAwLjAsICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAxLjIxMTk2NzU0NTYzODk0NTQgIF1cbl07XG5cbnZhciBQcm9QaG90b0xpbmVhciA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwicHJvcGhvdG8tbGluZWFyXCIsXG5cdG5hbWU6IFwiTGluZWFyIFByb1Bob3RvXCIsXG5cdHdoaXRlOiBcIkQ1MFwiLFxuXHRiYXNlOiBYWVpfRDUwLFxuXHR0b1hZWl9NOiB0b1hZWl9NJDEsXG5cdGZyb21YWVpfTTogZnJvbVhZWl9NJDFcbn0pO1xuXG5jb25zdCBFdCA9IDEvNTEyO1xuY29uc3QgRXQyID0gMTYvNTEyO1xuXG52YXIgcHJvcGhvdG8gPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcInByb3Bob3RvXCIsXG5cdG5hbWU6IFwiUHJvUGhvdG9cIixcblx0YmFzZTogUHJvUGhvdG9MaW5lYXIsXG5cdHRvQmFzZSAoUkdCKSB7XG5cdFx0Ly8gVHJhbnNmZXIgY3VydmUgaXMgZ2FtbWEgMS44IHdpdGggYSBzbWFsbCBsaW5lYXIgcG9ydGlvblxuXHRcdHJldHVybiBSR0IubWFwKHYgPT4gdiA8IEV0Mj8gdiAvIDE2IDogdiAqKiAxLjgpO1xuXHR9LFxuXHRmcm9tQmFzZSAoUkdCKSB7XG5cdFx0cmV0dXJuIFJHQi5tYXAodiA9PiB2ID49IEV0PyB2ICoqICgxLzEuOCkgOiAxNiAqIHYpO1xuXHR9LFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHtcblx0XHRcdGlkOiBcInByb3Bob3RvLXJnYlwiXG5cdFx0fVxuXHR9LFxufSk7XG5cbnZhciBva2xjaCA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwib2tsY2hcIixcblx0bmFtZTogXCJPa2xjaFwiLFxuXHRjb29yZHM6IHtcblx0XHRsOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDFdLFxuXHRcdFx0bmFtZTogXCJMaWdodG5lc3NcIlxuXHRcdH0sXG5cdFx0Yzoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAwLjRdLFxuXHRcdFx0bmFtZTogXCJDaHJvbWFcIlxuXHRcdH0sXG5cdFx0aDoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAzNjBdLFxuXHRcdFx0dHlwZTogXCJhbmdsZVwiLFxuXHRcdFx0bmFtZTogXCJIdWVcIlxuXHRcdH1cblx0fSxcblx0d2hpdGU6IFwiRDY1XCIsXG5cblx0YmFzZTogT0tMYWIsXG5cdGZyb21CYXNlIChva2xhYikge1xuXHRcdC8vIENvbnZlcnQgdG8gcG9sYXIgZm9ybVxuXHRcdGxldCBbTCwgYSwgYl0gPSBva2xhYjtcblx0XHRsZXQgaDtcblx0XHRjb25zdCDOtSA9IDAuMDAwMjsgLy8gY2hyb21hdGljIGNvbXBvbmVudHMgbXVjaCBzbWFsbGVyIHRoYW4gYSxiXG5cblx0XHRpZiAoTWF0aC5hYnMoYSkgPCDOtSAmJiBNYXRoLmFicyhiKSA8IM61KSB7XG5cdFx0XHRoID0gTmFOO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGggPSBNYXRoLmF0YW4yKGIsIGEpICogMTgwIC8gTWF0aC5QSTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0TCwgLy8gT0tMYWIgTCBpcyBzdGlsbCBMXG5cdFx0XHRNYXRoLnNxcnQoYSAqKiAyICsgYiAqKiAyKSwgLy8gQ2hyb21hXG5cdFx0XHRjb25zdHJhaW4oaCkgLy8gSHVlLCBpbiBkZWdyZWVzIFswIHRvIDM2MClcblx0XHRdO1xuXHR9LFxuXHQvLyBDb252ZXJ0IGZyb20gcG9sYXIgZm9ybVxuXHR0b0Jhc2UgKG9rbGNoKSB7XG5cdFx0bGV0IFtMLCBDLCBoXSA9IG9rbGNoO1xuXHRcdGxldCBhLCBiO1xuXG5cdFx0Ly8gY2hlY2sgZm9yIE5hTiBodWVcblx0XHRpZiAoaXNOYU4oaCkpIHtcblx0XHRcdGEgPSAwO1xuXHRcdFx0YiA9IDA7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0YSA9IEMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHRiID0gQyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gWyBMLCBhLCBiIF07XG5cdH0sXG5cblx0Zm9ybWF0czoge1xuXHRcdFwib2tsY2hcIjoge1xuXHRcdFx0Y29vcmRzOiBbXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+WzAsMV1cIiwgXCI8bnVtYmVyPiB8IDxhbmdsZT5cIl0sXG5cdFx0fVxuXHR9XG59KTtcblxuY29uc3QgWXcgPSAyMDM7XHQvLyBhYnNvbHV0ZSBsdW1pbmFuY2Ugb2YgbWVkaWEgd2hpdGUsIGNkL23CslxuY29uc3QgbiA9IDI2MTAgLyAoMiAqKiAxNCk7XG5jb25zdCBuaW52ID0gKDIgKiogMTQpIC8gMjYxMDtcbmNvbnN0IG0gPSAyNTIzIC8gKDIgKiogNSk7XG5jb25zdCBtaW52ID0gKDIgKiogNSkgLyAyNTIzO1xuY29uc3QgYzEgPSAzNDI0IC8gKDIgKiogMTIpO1xuY29uc3QgYzIgPSAyNDEzIC8gKDIgKiogNyk7XG5jb25zdCBjMyA9IDIzOTIgLyAoMiAqKiA3KTtcblxudmFyIHJlYzIxMDBQcSA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwicmVjMjEwMHBxXCIsXG5cdG5hbWU6IFwiUkVDLjIxMDAtUFFcIixcblx0YmFzZTogUkVDMjAyMExpbmVhcixcblx0dG9CYXNlIChSR0IpIHtcblx0XHQvLyBnaXZlbiBQUSBlbmNvZGVkIGNvbXBvbmVudCBpbiByYW5nZSBbMCwgMV1cblx0XHQvLyByZXR1cm4gbWVkaWEtd2hpdGUgcmVsYXRpdmUgbGluZWFyLWxpZ2h0XG5cdFx0cmV0dXJuIFJHQi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0bGV0IHggPSAoKE1hdGgubWF4KCgodmFsICoqIG1pbnYpIC0gYzEpLCAwKSAvIChjMiAtIChjMyAqICh2YWwgKiogbWludikpKSkgKiogbmludik7XG5cdFx0XHRyZXR1cm4gKHggKiAxMDAwMCAvIFl3KTsgXHQvLyBsdW1pbmFuY2UgcmVsYXRpdmUgdG8gZGlmZnVzZSB3aGl0ZSwgWzAsIDcwIG9yIHNvXS5cblx0XHR9KTtcblx0fSxcblx0ZnJvbUJhc2UgKFJHQikge1xuXHRcdC8vIGdpdmVuIG1lZGlhLXdoaXRlIHJlbGF0aXZlIGxpbmVhci1saWdodFxuXHRcdC8vIHJldHVyblBRIGVuY29kZWQgY29tcG9uZW50IGluIHJhbmdlIFswLCAxXVxuXHRcdHJldHVybiBSR0IubWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdGxldCB4ID0gTWF0aC5tYXgodmFsICogWXcgLyAxMDAwMCwgMCk7IFx0Ly8gYWJzb2x1dGUgbHVtaW5hbmNlIG9mIHBlYWsgd2hpdGUgaXMgMTAsMDAwIGNkL23Csi5cblx0XHRcdGxldCBudW0gPSAoYzEgKyAoYzIgKiAoeCAqKiBuKSkpO1xuXHRcdFx0bGV0IGRlbm9tID0gKDEgKyAoYzMgKiAoeCAqKiBuKSkpO1xuXG5cdFx0XHRyZXR1cm4gKChudW0gLyBkZW5vbSkgICoqIG0pO1xuXHRcdH0pO1xuXHR9LFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHtcblx0XHRcdGlkOiBcInJlYzIxMDAtcHFcIlxuXHRcdH0sXG5cdH0sXG59KTtcblxuLy8gRklYTUUgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFWZXJvdS9jb2xvci5qcy9pc3N1ZXMvMTkwXG5cbmNvbnN0IGEgPSAwLjE3ODgzMjc3O1xuY29uc3QgYiA9IDAuMjg0NjY4OTI7IC8vIDEgLSAoNCAqIGEpXG5jb25zdCBjID0gMC41NTk5MTA3MzsgLy8gMC41IC0gYSAqIE1hdGgubG9nKDQgKmEpXG5cbmNvbnN0IHNjYWxlID0gMy43NzQzO1x0Ly8gUGxhY2UgMTglIGdyZXkgYXQgSExHIDAuMzgsIHNvIG1lZGlhIHdoaXRlIGF0IDAuNzVcblxudmFyIHJlYzIxMDBIbGcgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcInJlYzIxMDBobGdcIixcblx0Y3NzaWQ6IFwicmVjMjEwMC1obGdcIixcblx0bmFtZTogXCJSRUMuMjEwMC1ITEdcIixcblx0cmVmZXJyZWQ6IFwic2NlbmVcIixcblxuXHRiYXNlOiBSRUMyMDIwTGluZWFyLFxuXHR0b0Jhc2UgKFJHQikge1xuXHRcdC8vIGdpdmVuIEhMRyBlbmNvZGVkIGNvbXBvbmVudCBpbiByYW5nZSBbMCwgMV1cblx0XHQvLyByZXR1cm4gbWVkaWEtd2hpdGUgcmVsYXRpdmUgbGluZWFyLWxpZ2h0XG5cdFx0cmV0dXJuIFJHQi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0Ly8gZmlyc3QgdGhlIEhMRyBFT1RGXG5cdFx0XHQvLyBJVFUtUiBCVC4yMzkwLTEwIHAuMzAgc2VjdGlvblxuXHRcdFx0Ly8gNi4zIFRoZSBoeWJyaWQgbG9nLWdhbW1hIGVsZWN0cm8tb3B0aWNhbCB0cmFuc2ZlciBmdW5jdGlvbiAoRU9URilcblx0XHRcdC8vIFRoZW4gc2NhbGUgYnkgMyBzbyBtZWRpYSB3aGl0ZSBpcyAxLjBcblx0XHRcdGlmICh2YWwgPD0gMC41KSB7XG5cdFx0XHRcdHJldHVybiAodmFsICoqIDIpIC8gMyAqIHNjYWxlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICgoTWF0aC5leHAoKHZhbCAtIGMpIC8gYSkgKyBiKSAvIDEyKSAqIHNjYWxlO1xuXHRcdH0pO1xuXHR9LFxuXHRmcm9tQmFzZSAoUkdCKSB7XG5cdFx0Ly8gZ2l2ZW4gbWVkaWEtd2hpdGUgcmVsYXRpdmUgbGluZWFyLWxpZ2h0XG5cdFx0Ly8gd2hlcmUgZGlmZnVzZSB3aGl0ZSBpcyAxLjAsXG5cdFx0Ly8gcmV0dXJuIEhMRyBlbmNvZGVkIGNvbXBvbmVudCBpbiByYW5nZSBbMCwgMV1cblx0XHRyZXR1cm4gUkdCLm1hcChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHQvLyBmaXJzdCBzY2FsZSB0byBwdXQgbGluZWFyLWxpZ2h0IG1lZGlhIHdoaXRlIGF0IDEvM1xuXHRcdFx0dmFsIC89IHNjYWxlO1xuXHRcdFx0Ly8gbm93IHRoZSBITEcgT0VURlxuXHRcdFx0Ly8gSVRVLVIgQlQuMjM5MC0xMCBwLjIzXG5cdFx0XHQvLyA2LjEgVGhlIGh5YnJpZCBsb2ctZ2FtbWEgb3B0by1lbGVjdHJvbmljIHRyYW5zZmVyIGZ1bmN0aW9uIChPRVRGKVxuXHRcdFx0aWYgKHZhbCA8PSAxLzEyKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoIDMgKiB2YWwpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGEgKiBNYXRoLmxvZygxMiAqIHZhbCAtIGIpICsgYztcblx0XHR9KTtcblx0fSxcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7XG5cdFx0XHRpZDogXCJyZWMyMTAwLWhsZ1wiXG5cdFx0fSxcblx0fSxcbn0pO1xuXG5jb25zdCBDQVRzID0ge307XG5cbmhvb2tzLmFkZChcImNocm9tYXRpYy1hZGFwdGF0aW9uLXN0YXJ0XCIsIGVudiA9PiB7XG5cdGlmIChlbnYub3B0aW9ucy5tZXRob2QpIHtcblx0XHRlbnYuTSA9IGFkYXB0KGVudi5XMSwgZW52LlcyLCBlbnYub3B0aW9ucy5tZXRob2QpO1xuXHR9XG59KTtcblxuaG9va3MuYWRkKFwiY2hyb21hdGljLWFkYXB0YXRpb24tZW5kXCIsIGVudiA9PiB7XG5cdGlmICghZW52Lk0pIHtcblx0XHRlbnYuTSA9IGFkYXB0KGVudi5XMSwgZW52LlcyLCBlbnYub3B0aW9ucy5tZXRob2QpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gZGVmaW5lQ0FUICh7aWQsIHRvQ29uZV9NLCBmcm9tQ29uZV9NfSkge1xuXHQvLyBVc2UgaWQsIHRvQ29uZV9NLCBmcm9tQ29uZV9NIGxpa2UgdmFyaWFibGVzXG5cdENBVHNbaWRdID0gYXJndW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gYWRhcHQgKFcxLCBXMiwgaWQgPSBcIkJyYWRmb3JkXCIpIHtcblx0Ly8gYWRhcHQgZnJvbSBhIHNvdXJjZSB3aGl0ZXBvaW50IG9yIGlsbHVtaW5hbnQgVzFcblx0Ly8gdG8gYSBkZXN0aW5hdGlvbiB3aGl0ZXBvaW50IG9yIGlsbHVtaW5hbnQgVzIsXG5cdC8vIHVzaW5nIHRoZSBnaXZlbiBjaHJvbWF0aWMgYWRhcHRhdGlvbiB0cmFuc2Zvcm0gKENBVClcblx0Ly8gZGVidWdnZXI7XG5cdGxldCBtZXRob2QgPSBDQVRzW2lkXTtcblxuXHRsZXQgW8+BcywgzrNzLCDOsnNdID0gbXVsdGlwbHlNYXRyaWNlcyhtZXRob2QudG9Db25lX00sIFcxKTtcblx0bGV0IFvPgWQsIM6zZCwgzrJkXSA9IG11bHRpcGx5TWF0cmljZXMobWV0aG9kLnRvQ29uZV9NLCBXMik7XG5cblx0Ly8gYWxsIHByYWN0aWNhbCBpbGx1bWluYW50cyBoYXZlIG5vbi16ZXJvIFhZWiBzbyBubyBkaXZpc2lvbiBieSB6ZXJvIGNhbiBvY2N1ciBiZWxvd1xuXHRsZXQgc2NhbGUgPSBbXG5cdFx0W8+BZC/PgXMsICAgIDAsICAgICAgMCAgICAgIF0sXG5cdFx0WzAsICAgICAgICDOs2QvzrNzLCAgMCAgICAgIF0sXG5cdFx0WzAsICAgICAgICAwLCAgICAgIM6yZC/OsnMgIF1cblx0XTtcblx0Ly8gY29uc29sZS5sb2coe3NjYWxlfSk7XG5cblx0bGV0IHNjYWxlZF9jb25lX00gPSBtdWx0aXBseU1hdHJpY2VzKHNjYWxlLCBtZXRob2QudG9Db25lX00pO1xuXHRsZXQgYWRhcHRfTVx0PSBtdWx0aXBseU1hdHJpY2VzKG1ldGhvZC5mcm9tQ29uZV9NLCBzY2FsZWRfY29uZV9NKTtcblx0Ly8gY29uc29sZS5sb2coe3NjYWxlZF9jb25lX00sIGFkYXB0X019KTtcblx0cmV0dXJuIGFkYXB0X007XG59XG5kZWZpbmVDQVQoe1xuXHRpZDogXCJ2b24gS3JpZXNcIixcblx0dG9Db25lX006IFtcblx0XHRbICAwLjQwMDI0MDAsICAwLjcwNzYwMDAsIC0wLjA4MDgxMDAgXSxcblx0XHRbIC0wLjIyNjMwMDAsICAxLjE2NTMyMDAsICAwLjA0NTcwMDAgXSxcblx0XHRbICAwLjAwMDAwMDAsICAwLjAwMDAwMDAsICAwLjkxODIyMDAgXVxuXHRdLFxuXHRmcm9tQ29uZV9NOiBbXG5cdFx0WyAgMS44NTk5MzY0LCAtMS4xMjkzODE2LCAgMC4yMTk4OTc0IF0sXG5cdFx0WyAgMC4zNjExOTE0LCAgMC42Mzg4MTI1LCAtMC4wMDAwMDY0IF0sXG5cdFx0WyAgMC4wMDAwMDAwLCAgMC4wMDAwMDAwLCAgMS4wODkwNjM2IF1cblx0XVxufSk7XG5cbmRlZmluZUNBVCh7XG5cdGlkOiBcIkJyYWRmb3JkXCIsXG5cdC8vIENvbnZlcnQgYW4gYXJyYXkgb2YgWFlaIHZhbHVlcyBpbiB0aGUgcmFuZ2UgMC4wIC0gMS4wXG5cdC8vIHRvIGNvbmUgZnVuZGFtZW50YWxzXG5cdHRvQ29uZV9NOiBbXG5cdFx0WyAgMC44OTUxMDAwLCAgMC4yNjY0MDAwLCAtMC4xNjE0MDAwIF0sXG5cdFx0WyAtMC43NTAyMDAwLCAgMS43MTM1MDAwLCAgMC4wMzY3MDAwIF0sXG5cdFx0WyAgMC4wMzg5MDAwLCAtMC4wNjg1MDAwLCAgMS4wMjk2MDAwIF1cblx0XSxcblx0Ly8gYW5kIGJhY2tcblx0ZnJvbUNvbmVfTTogW1xuXHRcdFsgIDAuOTg2OTkyOSwgLTAuMTQ3MDU0MywgIDAuMTU5OTYyNyBdLFxuXHRcdFsgIDAuNDMyMzA1MywgIDAuNTE4MzYwMywgIDAuMDQ5MjkxMiBdLFxuXHRcdFsgLTAuMDA4NTI4NywgIDAuMDQwMDQyOCwgIDAuOTY4NDg2NyBdXG5cdF1cbn0pO1xuXG5kZWZpbmVDQVQoe1xuXHRpZDogXCJDQVQwMlwiLFxuXHQvLyB3aXRoIGNvbXBsZXRlIGNocm9tYXRpYyBhZGFwdGF0aW9uIHRvIFcyLCBzbyBEID0gMS4wXG5cdHRvQ29uZV9NOiBbXG5cdFx0WyAgMC43MzI4MDAwLCAgMC40Mjk2MDAwLCAtMC4xNjI0MDAwIF0sXG5cdFx0WyAtMC43MDM2MDAwLCAgMS42OTc1MDAwLCAgMC4wMDYxMDAwIF0sXG5cdFx0WyAgMC4wMDMwMDAwLCAgMC4wMTM2MDAwLCAgMC45ODM0MDAwIF1cblx0XSxcblx0ZnJvbUNvbmVfTTogW1xuXHRcdFsgIDEuMDk2MTIzOCwgLTAuMjc4ODY5MCwgIDAuMTgyNzQ1MiBdLFxuXHRcdFsgIDAuNDU0MzY5MCwgIDAuNDczNTMzMiwgIDAuMDcyMDk3OCBdLFxuXHRcdFsgLTAuMDA5NjI3NiwgLTAuMDA1Njk4MCwgIDEuMDE1MzI1NiBdXG5cdF1cbn0pO1xuXG5kZWZpbmVDQVQoe1xuXHRpZDogXCJDQVQxNlwiLFxuXHR0b0NvbmVfTTogW1xuXHRcdFsgIDAuNDAxMjg4LCAgMC42NTAxNzMsIC0wLjA1MTQ2MSBdLFxuXHRcdFsgLTAuMjUwMjY4LCAgMS4yMDQ0MTQsICAwLjA0NTg1NCBdLFxuXHRcdFsgLTAuMDAyMDc5LCAgMC4wNDg5NTIsICAwLjk1MzEyNyBdXG5cdF0sXG5cdC8vIHRoZSBleHRyYSBwcmVjaXNpb24gaXMgbmVlZGVkIHRvIGF2b2lkIHJvdW5kdHJpcHBpbmcgZXJyb3JzXG5cdGZyb21Db25lX006IFtcblx0XHRbICAxLjg2MjA2Nzg1NTA4NzIzM2UrMCwgLTEuMDExMjU0NjMwNTMxNjg1ZSswLCAgIDEuNDkxODY3NzU0NDQ0NTE4ZS0xIF0sXG5cdFx0WyAgMy44NzUyNjU0MzIzNjEzNzJlLTEsICA2LjIxNDQ3NDQxOTMxNDc1M2UtMSwgIC04Ljk3Mzk4NTE2NzYxMjUxOGUtMyBdLFxuXHRcdFsgLTEuNTg0MTQ5ODg0OTMzMzg2ZS0yLCAtMy40MTIyOTM4MDI4NTE1NTdlLTIsICAgMS4wNDk5NjQ0MzY4Nzc4NTBlKzAgXVxuXHRdXG59KTtcblxuT2JqZWN0LmFzc2lnbihXSElURVMsIHtcblx0Ly8gd2hpdGVwb2ludCB2YWx1ZXMgZnJvbSBBU1RNIEUzMDgtMDEgd2l0aCAxMG5tIHNwYWNpbmcsIDE5MzEgMiBkZWdyZWUgb2JzZXJ2ZXJcblx0Ly8gYWxsIG5vcm1hbGl6ZWQgdG8gWSAobHVtaW5hbmNlKSA9IDEuMDAwMDBcblx0Ly8gSWxsdW1pbmFudCBBIGlzIGEgdHVuZ3N0ZW4gZWxlY3RyaWMgbGlnaHQsIGdpdmluZyBhIHZlcnkgd2FybSwgb3JhbmdlIGxpZ2h0LlxuXHRBOiAgWzEuMDk4NTAsIDEuMDAwMDAsIDAuMzU1ODVdLFxuXG5cdC8vIElsbHVtaW5hbnQgQyB3YXMgYW4gZWFybHkgYXBwcm94aW1hdGlvbiB0byBkYXlsaWdodDogaWxsdW1pbmFudCBBIHdpdGggYSBibHVlIGZpbHRlci5cblx0QzogICBbMC45ODA3NCwgMS4wMDAwMDAsIDEuMTgyMzJdLFxuXG5cdC8vIFRoZSBkYXlsaWdodCBzZXJpZXMgb2YgaWxsdW1pbmFudHMgc2ltdWxhdGUgbmF0dXJhbCBkYXlsaWdodC5cblx0Ly8gVGhlIGNvbG9yIHRlbXBlcmF0dXJlIChpbiBkZWdyZWVzIEtlbHZpbi8xMDApIHJhbmdlcyBmcm9tXG5cdC8vIGNvb2wsIG92ZXJjYXN0IGRheWxpZ2h0IChENTApIHRvIGJyaWdodCwgZGlyZWN0IHN1bmxpZ2h0IChENjUpLlxuXHRENTU6IFswLjk1NjgyLCAxLjAwMDAwLCAwLjkyMTQ5XSxcblx0RDc1OiBbMC45NDk3MiwgMS4wMDAwMCwgMS4yMjYzOF0sXG5cblx0Ly8gRXF1YWwtZW5lcmd5IGlsbHVtaW5hbnQsIHVzZWQgaW4gdHdvLXN0YWdlIENBVDE2XG5cdEU6ICAgWzEuMDAwMDAsIDEuMDAwMDAsIDEuMDAwMDBdLFxuXG5cdC8vIFRoZSBGIHNlcmllcyBvZiBpbGx1bWluYW50cyByZXByZXNlbnQgZmx1b3Jlc2NlbnQgbGlnaHRzXG5cdEYyOiAgWzAuOTkxODYsIDEuMDAwMDAsIDAuNjczOTNdLFxuXHRGNzogIFswLjk1MDQxLCAxLjAwMDAwLCAxLjA4NzQ3XSxcblx0RjExOiBbMS4wMDk2MiwgMS4wMDAwMCwgMC42NDM1MF0sXG59KTtcblxuLy8gVGhlIEFDRVMgd2hpdGVwb2ludFxuLy8gc2VlIFRCLTIwMTgtMDAxIERlcml2YXRpb24gb2YgdGhlIEFDRVMgV2hpdGUgUG9pbnQgQ0lFIENocm9tYXRpY2l0eSBDb29yZGluYXRlc1xuLy8gYWxzbyBodHRwczovL2dpdGh1Yi5jb20vYW1wYXMvYWNlcy1kZXYvYmxvYi9tYXN0ZXIvZG9jdW1lbnRzL3B5dGhvbi9UQi0yMDE4LTAwMS9hY2VzX3dwLnB5XG4vLyBTaW1pbGFyIHRvIEQ2MFxuV0hJVEVTLkFDRVMgPSBbMC4zMjE2OC8wLjMzNzY3LCAxLjAwMDAwLCAoMS4wMDAwMCAtIDAuMzIxNjggLSAwLjMzNzY3KS8wLjMzNzY3XTtcblxuLy8gY29udmVydCBhbiBhcnJheSBvZiBsaW5lYXItbGlnaHQgQUNFU2NjIHZhbHVlcyB0byBDSUUgWFlaXG5jb25zdCB0b1hZWl9NID0gW1xuXHRbICAwLjY2MjQ1NDE4MTEwODUwNTMsICAgMC4xMzQwMDQyMDY0NTY0MzMxMywgIDAuMTU2MTg3Njg3MDA0OTA3OCAgXSxcblx0WyAgMC4yNzIyMjg3MTY3ODA5MTQ1NCwgIDAuNjc0MDgxNzY1ODExMTQ4NCwgICAwLjA1MzY4OTUxNzQwNzkzNzA1IF0sXG5cdFsgLTAuMDA1NTc0NjQ5NDkwMzk0MTA4LCAwLjAwNDA2MDczMzUyODk4MjgyNiwgMS4wMTAzMzkxMDAzMTI5OTcxICBdXG5dO1xuY29uc3QgZnJvbVhZWl9NID0gW1xuXHRbICAxLjY0MTAyMzM3OTY5NDMyNTcsICAgLTAuMzI0ODAzMjk0MTg0NzksICAgIC0wLjIzNjQyNDY5NTIzNzYxMjI1ICBdLFxuXHRbIC0wLjY2MzY2Mjg1ODcyMjk4MjksICAgIDEuNjE1MzMxNTkxNjU3MzM3OSwgICAwLjAxNjc1NjM0NzY4NTUzMDEzNyBdLFxuXHRbICAwLjAxMTcyMTg5NDMyODM3NTM3NiwgLTAuMDA4Mjg0NDQxOTk2MjM3NDA5LCAwLjk4ODM5NDg1ODUzOTAyMTUgICBdXG5dO1xuXG52YXIgQUNFU2NnID0gbmV3IFJHQkNvbG9yU3BhY2Uoe1xuXHRpZDogXCJhY2VzY2dcIixcblx0bmFtZTogXCJBQ0VTY2dcIixcblxuXHQvLyBBQ0VTY2cg4oCTIEEgc2NlbmUtcmVmZXJyZWQsIGxpbmVhci1saWdodCBlbmNvZGluZyBvZiBBQ0VTIERhdGFcblx0Ly8gaHR0cHM6Ly9kb2NzLmFjZXNjZW50cmFsLmNvbS9zcGVjaWZpY2F0aW9ucy9hY2VzY2cvXG5cdC8vIHVzZXMgdGhlIEFQMSBwcmltYXJpZXMsIHNlZSBzZWN0aW9uIDQuMy4xIENvbG9yIHByaW1hcmllc1xuXHRjb29yZHM6IHtcblx0XHRyOiB7XG5cdFx0XHRyYW5nZTogWzAsIDY1NTA0XSxcblx0XHRcdG5hbWU6IFwiUmVkXCJcblx0XHR9LFxuXHRcdGc6IHtcblx0XHRcdHJhbmdlOiBbMCwgNjU1MDRdLFxuXHRcdFx0bmFtZTogXCJHcmVlblwiXG5cdFx0fSxcblx0XHRiOiB7XG5cdFx0XHRyYW5nZTogWzAsIDY1NTA0XSxcblx0XHRcdG5hbWU6IFwiQmx1ZVwiXG5cdFx0fVxuXHR9LFxuXG5cdHJlZmVycmVkOiBcInNjZW5lXCIsXG5cblx0d2hpdGU6IFdISVRFUy5BQ0VTLFxuXG5cdHRvWFlaX00sXG5cdGZyb21YWVpfTSxcblxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHt9XG5cdH0sXG59KTtcblxuLy8gZXhwb3J0IGRlZmF1bHQgQ29sb3I7XG5cbmNvbnN0IM61ID0gMiAqKiAtMTY7XG5cbi8vIHRoZSBzbWFsbGVzdCB2YWx1ZSB3aGljaCwgaW4gdGhlIDMyYml0IElFRUUgNzU0IGZsb2F0IGVuY29kaW5nLFxuLy8gZGVjb2RlcyBhcyBhIG5vbi1uZWdhdGl2ZSB2YWx1ZVxuY29uc3QgQUNFU19taW5fbm9uemVybyA9IC0wLjM1ODI4NjgzO1xuXG4vLyBicmlnaHRlc3QgZW5jb2RlZCB2YWx1ZSwgZGVjb2RlcyB0byA2NTUwNFxuY29uc3QgQUNFU19jY19tYXggPSAoTWF0aC5sb2cyKDY1NTA0KSArIDkuNzIpIC8gMTcuNTI7IC8vIDEuNDY4XG5cbnZhciBhY2VzY2MgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcImFjZXNjY1wiLFxuXHRuYW1lOiBcIkFDRVNjY1wiLFxuXHQvLyBzZWUgUy0yMDE0LTAwMyBBQ0VTY2Mg4oCTIEEgTG9nYXJpdGhtaWMgRW5jb2Rpbmcgb2YgQUNFUyBEYXRhXG5cdC8vIGh0dHBzOi8vZG9jcy5hY2VzY2VudHJhbC5jb20vc3BlY2lmaWNhdGlvbnMvYWNlc2NjL1xuXHQvLyB1c2VzIHRoZSBBUDEgcHJpbWFyaWVzLCBzZWUgc2VjdGlvbiA0LjMuMSBDb2xvciBwcmltYXJpZXNcblxuXHQvLyBBcHBlbmRpeCBBOiBcIlZlcnkgc21hbGwgQUNFUyBzY2VuZSByZWZlcnJlZCB2YWx1ZXMgYmVsb3cgNyAxLzQgc3RvcHNcblx0Ly8gYmVsb3cgMTglIG1pZGRsZSBncmF5IGFyZSBlbmNvZGVkIGFzIG5lZ2F0aXZlIEFDRVNjYyB2YWx1ZXMuXG5cdC8vIFRoZXNlIHZhbHVlcyBzaG91bGQgYmUgcHJlc2VydmVkIHBlciB0aGUgZW5jb2RpbmcgaW4gU2VjdGlvbiA0LjRcblx0Ly8gc28gdGhhdCBhbGwgcG9zaXRpdmUgQUNFUyB2YWx1ZXMgYXJlIG1haW50YWluZWQuXCJcblx0Y29vcmRzOiB7XG5cdFx0cjoge1xuXHRcdFx0cmFuZ2U6IFtBQ0VTX21pbl9ub256ZXJvLCBBQ0VTX2NjX21heF0sXG5cdFx0XHRuYW1lOiBcIlJlZFwiXG5cdFx0fSxcblx0XHRnOiB7XG5cdFx0XHRyYW5nZTogW0FDRVNfbWluX25vbnplcm8sIEFDRVNfY2NfbWF4XSxcblx0XHRcdG5hbWU6IFwiR3JlZW5cIlxuXHRcdH0sXG5cdFx0Yjoge1xuXHRcdFx0cmFuZ2U6IFtBQ0VTX21pbl9ub256ZXJvLCBBQ0VTX2NjX21heF0sXG5cdFx0XHRuYW1lOiBcIkJsdWVcIlxuXHRcdH1cblx0fSxcblx0cmVmZXJyZWQ6IFwic2NlbmVcIixcblxuXHRiYXNlOiBBQ0VTY2csXG5cdC8vIGZyb20gc2VjdGlvbiA0LjQuMiBEZWNvZGluZyBGdW5jdGlvblxuXHR0b0Jhc2UgKFJHQikge1xuXHRcdGNvbnN0IGxvdyA9ICg5LjcyIC0gMTUpIC8gMTcuNTI7IC8vIC0wLjMwMTRcblxuXHRcdHJldHVybiBSR0IubWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdGlmICh2YWwgPD0gbG93KSB7XG5cdFx0XHRcdHJldHVybiAoMiAqKiAoKHZhbCAqIDE3LjUyKSAtIDkuNzIpIC0gzrUpICogMjsgLy8gdmVyeSBsb3cgdmFsdWVzLCBiZWxvdyAtMC4zMDE0XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh2YWwgPCBBQ0VTX2NjX21heCkge1xuXHRcdFx0XHRyZXR1cm4gMiAqKiAoKHZhbCAqIDE3LjUyKSAtIDkuNzIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIHZhbCA+PSBBQ0VTX2NjX21heFxuXHRcdFx0XHRyZXR1cm4gNjU1MDQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Ly8gTm9uLWxpbmVhciBlbmNvZGluZyBmdW5jdGlvbiBmcm9tIFMtMjAxNC0wMDMsIHNlY3Rpb24gNC40LjEgRW5jb2RpbmcgRnVuY3Rpb25cblx0ZnJvbUJhc2UgKFJHQikge1xuXHRcdHJldHVybiBSR0IubWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdGlmICh2YWwgPD0gMCkge1xuXHRcdFx0XHRyZXR1cm4gKE1hdGgubG9nMijOtSkgKyA5LjcyKSAvIDE3LjUyOyAvLyAtMC4zNTg0XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh2YWwgPCDOtSkge1xuXHRcdFx0XHRyZXR1cm4gIChNYXRoLmxvZzIozrUgKyB2YWwgKiAwLjUpICsgOS43MikgLyAxNy41Mjtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyB2YWwgPj0gzrVcblx0XHRcdFx0cmV0dXJuICAoTWF0aC5sb2cyKHZhbCkgKyA5LjcyKSAvIDE3LjUyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHQvLyBlbmNvZGVkIG1lZGlhIHdoaXRlIChyZ2IgMSwxLDEpID0+IGxpbmVhciAgWyAyMjIuODYxLCAyMjIuODYxLCAyMjIuODYxIF1cblx0Ly8gZW5jb2RlZCBtZWRpYSBibGFjayAocmdiIDAsMCwwKSA9PiBsaW5lYXIgWyAwLjAwMTE4NTcsIDAuMDAxMTg1NywgMC4wMDExODU3XVxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHt9XG5cdH1cbn0pO1xuXG52YXIgc3BhY2VzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEE5OFJHQjogYTk4cmdiLFxuXHRBOThSR0JfTGluZWFyOiBBOThMaW5lYXIsXG5cdEFDRVNjYzogYWNlc2NjLFxuXHRBQ0VTY2c6IEFDRVNjZyxcblx0SFNMOiBIU0wsXG5cdEhTVjogSFNWLFxuXHRIV0I6IGh3Yixcblx0SUNUQ1A6IGljdGNwLFxuXHRKekN6SHo6IGp6Y3poeixcblx0SnphemJ6OiBKemF6YnosXG5cdExDSDogbGNoLFxuXHRMYWI6IGxhYixcblx0TGFiX0Q2NTogbGFiX2Q2NSxcblx0T0tMQ0g6IG9rbGNoLFxuXHRPS0xhYjogT0tMYWIsXG5cdFAzOiBQMyxcblx0UDNfTGluZWFyOiBQM0xpbmVhcixcblx0UHJvUGhvdG86IHByb3Bob3RvLFxuXHRQcm9QaG90b19MaW5lYXI6IFByb1Bob3RvTGluZWFyLFxuXHRSRUNfMjAyMDogUkVDMjAyMCxcblx0UkVDXzIwMjBfTGluZWFyOiBSRUMyMDIwTGluZWFyLFxuXHRSRUNfMjEwMF9ITEc6IHJlYzIxMDBIbGcsXG5cdFJFQ18yMTAwX1BROiByZWMyMTAwUHEsXG5cdFhZWl9BQlNfRDY1OiBYWVpfQWJzX0Q2NSxcblx0WFlaX0Q1MDogWFlaX0Q1MCxcblx0WFlaX0Q2NTogWFlaX0Q2NSxcblx0c1JHQjogc1JHQixcblx0c1JHQl9MaW5lYXI6IHNSR0JMaW5lYXJcbn0pO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGNvbG9yXG4gKi9cbmNsYXNzIENvbG9yIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29sb3IuXG5cdCAqIFNpZ25hdHVyZXM6XG5cdCAqIC0gYG5ldyBDb2xvcihzdHJpbmdUb1BhcnNlKWBcblx0ICogLSBgbmV3IENvbG9yKG90aGVyQ29sb3IpYFxuXHQgKiAtIGBuZXcgQ29sb3Ioe3NwYWNlLCBjb29yZHMsIGFscGhhfSlgXG5cdCAqIC0gYG5ldyBDb2xvcihzcGFjZSwgY29vcmRzLCBhbHBoYSlgXG5cdCAqIC0gYG5ldyBDb2xvcihzcGFjZUlkLCBjb29yZHMsIGFscGhhKWBcblx0ICovXG5cdGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG5cdFx0bGV0IGNvbG9yO1xuXG5cdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRjb2xvciA9IGdldENvbG9yKGFyZ3NbMF0pO1xuXHRcdH1cblxuXHRcdGxldCBzcGFjZSwgY29vcmRzLCBhbHBoYTtcblxuXHRcdGlmIChjb2xvcikge1xuXHRcdFx0c3BhY2UgPSBjb2xvci5zcGFjZSB8fCBjb2xvci5zcGFjZUlkO1xuXHRcdFx0Y29vcmRzID0gY29sb3IuY29vcmRzO1xuXHRcdFx0YWxwaGEgPSBjb2xvci5hbHBoYTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBkZWZhdWx0IHNpZ25hdHVyZSBuZXcgQ29sb3IoQ29sb3JTcGFjZSwgYXJyYXkgWywgYWxwaGFdKVxuXHRcdFx0W3NwYWNlLCBjb29yZHMsIGFscGhhXSA9IGFyZ3M7XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3BhY2VcIiwge1xuXHRcdFx0dmFsdWU6IENvbG9yU3BhY2UuZ2V0KHNwYWNlKSxcblx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsIC8vIHNlZSBub3RlIGluIGh0dHBzOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvOC4wLyNzZWMtcHJveHktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzLWdldC1wLXJlY2VpdmVyXG5cdFx0fSk7XG5cdFx0dGhpcy5jb29yZHMgPSBjb29yZHM/IGNvb3Jkcy5zbGljZSgpIDogWzAsIDAsIDBdO1xuXHRcdHRoaXMuYWxwaGEgPSBhbHBoYSA8IDE/IGFscGhhIDogMTsgLy8gdGhpcyBhbHNvIGRlYWxzIHdpdGggTmFOIGV0Y1xuXG5cdFx0Ly8gQ29udmVydCBcIk5hTlwiIHRvIE5hTlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb29yZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmNvb3Jkc1tpXSA9PT0gXCJOYU5cIikge1xuXHRcdFx0XHR0aGlzLmNvb3Jkc1tpXSA9IE5hTjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWZpbmUgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgZWFjaCBjb29yZGluYXRlXG5cdFx0Zm9yIChsZXQgaWQgaW4gdGhpcy5zcGFjZS5jb29yZHMpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpZCwge1xuXHRcdFx0XHRnZXQ6ICgpID0+IHRoaXMuZ2V0KGlkKSxcblx0XHRcdFx0c2V0OiB2YWx1ZSA9PiB0aGlzLnNldChpZCwgdmFsdWUpXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRnZXQgc3BhY2VJZCAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3BhY2UuaWQ7XG5cdH1cblxuXHRjbG9uZSAoKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcih0aGlzLnNwYWNlLCB0aGlzLmNvb3JkcywgdGhpcy5hbHBoYSk7XG5cdH1cblxuXHR0b0pTT04gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzcGFjZUlkOiB0aGlzLnNwYWNlSWQsXG5cdFx0XHRjb29yZHM6IHRoaXMuY29vcmRzLFxuXHRcdFx0YWxwaGE6IHRoaXMuYWxwaGFcblx0XHR9O1xuXHR9XG5cblx0ZGlzcGxheSAoLi4uYXJncykge1xuXHRcdGxldCByZXQgPSBkaXNwbGF5KHRoaXMsIC4uLmFyZ3MpO1xuXG5cdFx0Ly8gQ29udmVydCBjb2xvciBvYmplY3QgdG8gQ29sb3IgaW5zdGFuY2Vcblx0XHRyZXQuY29sb3IgPSBuZXcgQ29sb3IocmV0LmNvbG9yKTtcblxuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGEgY29sb3IgZnJvbSB0aGUgYXJndW1lbnQgcGFzc2VkXG5cdCAqIEJhc2ljYWxseSBnZXRzIHVzIHRoZSBzYW1lIHJlc3VsdCBhcyBuZXcgQ29sb3IoY29sb3IpIGJ1dCBkb2Vzbid0IGNsb25lIGFuIGV4aXN0aW5nIGNvbG9yIG9iamVjdFxuXHQgKi9cblx0c3RhdGljIGdldCAoY29sb3IsIC4uLmFyZ3MpIHtcblx0XHRpZiAoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikge1xuXHRcdFx0cmV0dXJuIGNvbG9yO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQ29sb3IoY29sb3IsIC4uLmFyZ3MpO1xuXHR9XG5cblx0c3RhdGljIGRlZmluZUZ1bmN0aW9uIChuYW1lLCBjb2RlLCBvID0gY29kZSkge1xuXHRcdGxldCB7aW5zdGFuY2UgPSB0cnVlLCByZXR1cm5zfSA9IG87XG5cblx0XHRsZXQgZnVuYyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0XHRsZXQgcmV0ID0gY29kZSguLi5hcmdzKTtcblxuXHRcdFx0aWYgKHJldHVybnMgPT09IFwiY29sb3JcIikge1xuXHRcdFx0XHRyZXQgPSBDb2xvci5nZXQocmV0KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHJldHVybnMgPT09IFwiZnVuY3Rpb248Y29sb3I+XCIpIHtcblx0XHRcdFx0bGV0IGYgPSByZXQ7XG5cdFx0XHRcdHJldCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0XHRcdFx0bGV0IHJldCA9IGYoLi4uYXJncyk7XG5cdFx0XHRcdFx0cmV0dXJuIENvbG9yLmdldChyZXQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBDb3B5IGFueSBmdW5jdGlvbiBtZXRhZGF0YVxuXHRcdFx0XHRPYmplY3QuYXNzaWduKHJldCwgZik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChyZXR1cm5zID09PSBcImFycmF5PGNvbG9yPlwiKSB7XG5cdFx0XHRcdHJldCA9IHJldC5tYXAoYyA9PiBDb2xvci5nZXQoYykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH07XG5cblx0XHRpZiAoIShuYW1lIGluIENvbG9yKSkge1xuXHRcdFx0Q29sb3JbbmFtZV0gPSBmdW5jO1xuXHRcdH1cblxuXHRcdGlmIChpbnN0YW5jZSkge1xuXHRcdFx0Q29sb3IucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmModGhpcywgLi4uYXJncyk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBkZWZpbmVGdW5jdGlvbnMgKG8pIHtcblx0XHRmb3IgKGxldCBuYW1lIGluIG8pIHtcblx0XHRcdENvbG9yLmRlZmluZUZ1bmN0aW9uKG5hbWUsIG9bbmFtZV0sIG9bbmFtZV0pO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBleHRlbmQgKGV4cG9ydHMpIHtcblx0XHRpZiAoZXhwb3J0cy5yZWdpc3Rlcikge1xuXHRcdFx0ZXhwb3J0cy5yZWdpc3RlcihDb2xvcik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTm8gcmVnaXN0ZXIgbWV0aG9kLCBqdXN0IGFkZCB0aGUgbW9kdWxlJ3MgZnVuY3Rpb25zXG5cdFx0XHRmb3IgKGxldCBuYW1lIGluIGV4cG9ydHMpIHtcblx0XHRcdFx0Q29sb3IuZGVmaW5lRnVuY3Rpb24obmFtZSwgZXhwb3J0c1tuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5Db2xvci5kZWZpbmVGdW5jdGlvbnMoe1xuXHRnZXQsXG5cdGdldEFsbCxcblx0c2V0LFxuXHRzZXRBbGwsXG5cdHRvLFxuXHRlcXVhbHMsXG5cdGluR2FtdXQsXG5cdHRvR2FtdXQsXG5cdGRpc3RhbmNlLFxuXHR0b1N0cmluZzogc2VyaWFsaXplLFxufSk7XG5cbk9iamVjdC5hc3NpZ24oQ29sb3IsIHtcblx0dXRpbCxcblx0aG9va3MsXG5cdFdISVRFUyxcblx0U3BhY2U6IENvbG9yU3BhY2UsXG5cdHNwYWNlczogQ29sb3JTcGFjZS5yZWdpc3RyeSxcblx0cGFyc2UsXG5cblx0Ly8gR2xvYmFsIGRlZmF1bHRzIG9uZSBtYXkgd2FudCB0byBjb25maWd1cmVcblx0ZGVmYXVsdHNcbn0pO1xuXG5mb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoc3BhY2VzKSkge1xuXHRDb2xvclNwYWNlLnJlZ2lzdGVyKHNwYWNlc1trZXldKTtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBkZWZpbmVzIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIGNvbG9yW3NwYWNlSWRdXG4gKiBlLmcuIGNvbG9yLmxjaCBvbiAqYW55KiBjb2xvciBnaXZlcyB1cyB0aGUgbGNoIGNvb3Jkc1xuICovXG5cbi8vIEFkZCBzcGFjZSBhY2Nlc3NvcnMgdG8gZXhpc3RpbmcgY29sb3Igc3BhY2VzXG5mb3IgKGxldCBpZCBpbiBDb2xvclNwYWNlLnJlZ2lzdHJ5KSB7XG5cdGFkZFNwYWNlQWNjZXNzb3JzKGlkLCBDb2xvclNwYWNlLnJlZ2lzdHJ5W2lkXSk7XG59XG5cbi8vIEFkZCBzcGFjZSBhY2Nlc3NvcnMgdG8gY29sb3Igc3BhY2VzIG5vdCB5ZXQgY3JlYXRlZFxuaG9va3MuYWRkKFwiY29sb3JzcGFjZS1pbml0LWVuZFwiLCBzcGFjZSA9PiB7XG5cdGFkZFNwYWNlQWNjZXNzb3JzKHNwYWNlLmlkLCBzcGFjZSk7XG5cdHNwYWNlLmFsaWFzZXM/LmZvckVhY2goYWxpYXMgPT4ge1xuXHRcdGFkZFNwYWNlQWNjZXNzb3JzKGFsaWFzLCBzcGFjZSk7XG5cdH0pO1xufSk7XG5cbmZ1bmN0aW9uIGFkZFNwYWNlQWNjZXNzb3JzIChpZCwgc3BhY2UpIHtcblx0Ly8gQ29vcmRpbmF0ZXMgY2FuIGJlIGxvb2tlZCB1cCBieSBib3RoIGlkIGFuZCBuYW1lXG5cdE9iamVjdC5rZXlzKHNwYWNlLmNvb3Jkcyk7XG5cdE9iamVjdC52YWx1ZXMoc3BhY2UuY29vcmRzKS5tYXAoYyA9PiBjLm5hbWUpO1xuXG5cblx0bGV0IHByb3BJZCA9IGlkLnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsIHByb3BJZCwge1xuXHRcdC8vIENvbnZlcnQgY29vcmRzIHRvIGNvb3JkcyBpbiBhbm90aGVyIGNvbG9yc3BhY2UgYW5kIHJldHVybiB0aGVtXG5cdFx0Ly8gU291cmNlIGNvbG9yc3BhY2U6IHRoaXMuc3BhY2VJZFxuXHRcdC8vIFRhcmdldCBjb2xvcnNwYWNlOiBpZFxuXHRcdGdldCAoKSB7XG5cdFx0XHRsZXQgcmV0ID0gdGhpcy5nZXRBbGwoaWQpO1xuXG5cdFx0XHRpZiAodHlwZW9mIFByb3h5ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdC8vIElmIHByb3hpZXMgYXJlIG5vdCBzdXBwb3J0ZWQsIGp1c3QgcmV0dXJuIGEgc3RhdGljIGFycmF5XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVuYWJsZSBjb2xvci5zcGFjZUlkLmNvb3JkTmFtZSBzeW50YXhcblx0XHRcdHJldHVybiBuZXcgUHJveHkocmV0LCB7XG5cdFx0XHRcdGhhczogKG9iaiwgcHJvcGVydHkpID0+IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Q29sb3JTcGFjZS5yZXNvbHZlQ29vcmQoW3NwYWNlLCBwcm9wZXJ0eV0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuaGFzKG9iaiwgcHJvcGVydHkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXQ6IChvYmosIHByb3BlcnR5LCByZWNlaXZlcikgPT4ge1xuXHRcdFx0XHRcdGlmIChwcm9wZXJ0eSAmJiB0eXBlb2YgcHJvcGVydHkgIT09IFwic3ltYm9sXCIgJiYgIShwcm9wZXJ0eSBpbiBvYmopKSB7XG5cdFx0XHRcdFx0XHRsZXQge2luZGV4fSA9IENvbG9yU3BhY2UucmVzb2x2ZUNvb3JkKFtzcGFjZSwgcHJvcGVydHldKTtcblxuXHRcdFx0XHRcdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG9ialtpbmRleF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KG9iaiwgcHJvcGVydHksIHJlY2VpdmVyKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiAob2JqLCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHByb3BlcnR5ICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJzeW1ib2xcIiAmJiAhKHByb3BlcnR5IGluIG9iaikgfHwgcHJvcGVydHkgPj0gMCkge1xuXHRcdFx0XHRcdFx0bGV0IHtpbmRleH0gPSBDb2xvclNwYWNlLnJlc29sdmVDb29yZChbc3BhY2UsIHByb3BlcnR5XSk7XG5cblx0XHRcdFx0XHRcdGlmIChpbmRleCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG9ialtpbmRleF0gPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgY29sb3IuY29vcmRzXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0QWxsKGlkLCBvYmopO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBSZWZsZWN0LnNldChvYmosIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHQvLyBDb252ZXJ0IGNvb3JkcyBpbiBhbm90aGVyIGNvbG9yc3BhY2UgdG8gaW50ZXJuYWwgY29vcmRzIGFuZCBzZXQgdGhlbVxuXHRcdC8vIFRhcmdldCBjb2xvcnNwYWNlOiB0aGlzLnNwYWNlSWRcblx0XHQvLyBTb3VyY2UgY29sb3JzcGFjZTogaWRcblx0XHRzZXQgKGNvb3Jkcykge1xuXHRcdFx0dGhpcy5zZXRBbGwoaWQsIGNvb3Jkcyk7XG5cdFx0fSxcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHR9KTtcbn1cblxuLy8gSW1wb3J0IGFsbCBtb2R1bGVzIG9mIENvbG9yLmpzXG5cbkNvbG9yLmV4dGVuZChkZWx0YUVNZXRob2RzKTtcbkNvbG9yLmV4dGVuZCh7ZGVsdGFFfSk7XG5PYmplY3QuYXNzaWduKENvbG9yLCB7ZGVsdGFFTWV0aG9kc30pO1xuQ29sb3IuZXh0ZW5kKHZhcmlhdGlvbnMpO1xuQ29sb3IuZXh0ZW5kKHtjb250cmFzdH0pO1xuQ29sb3IuZXh0ZW5kKGNocm9tYXRpY2l0eSk7XG5Db2xvci5leHRlbmQobHVtaW5hbmNlKTtcbkNvbG9yLmV4dGVuZChpbnRlcnBvbGF0aW9uKTtcbkNvbG9yLmV4dGVuZChjb250cmFzdE1ldGhvZHMpO1xuXG5leHBvcnQgeyBDb2xvciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/colorjs.io/dist/color.js\n");

/***/ })

};
;